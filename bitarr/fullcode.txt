Progress_Report.md:
<code>
# Bitarr Project Progress Report

## Project Overview
Bitarr is a web-based file integrity monitoring application designed to detect file corruption, unauthorized modifications, and missing files across multiple storage devices. The application is containerized for easy deployment on Linux systems.

## Current Progress

We have successfully implemented the following core components:

1. **Database Layer**
   - Complete SQLite schema for storing file metadata, checksums, scan results, and configuration
   - Object models for all database entities
   - Thread-safe database manager with CRUD operations
   - Database migration and maintenance utilities

2. **Core Scanner Engine**
   - File traversal system with filtering capabilities
   - Multi-threaded scanning with progress reporting
   - Support for multiple checksum algorithms (SHA-256, SHA-512, BLAKE3, xxHash64, etc.)
   - Change detection and corruption identification logic
   - Storage device detection and monitoring

3. **Web Application Framework**
   - Flask application with blueprints for organizing routes
   - Socket.IO integration for real-time progress updates
   - RESTful API endpoints for application control
   - Basic UI templates and responsive styling

## Files Created

### Database Layer
- `bitarr/db/__init__.py` - Package initialization
- `bitarr/db/schema.py` - Database schema definitions
- `bitarr/db/models.py` - ORM-style models for database entities
- `bitarr/db/db_manager.py` - Database manager with CRUD operations
- `bitarr/db/init_db.py` - Database initialization script
- `bitarr/db/__main__.py` - Command-line interface for database management

### Core Scanner
- `bitarr/core/__init__.py` - Package initialization
- `bitarr/core/scanner/__init__.py` - Scanner package initialization
- `bitarr/core/scanner/scanner.py` - Main file scanner implementation
- `bitarr/core/scanner/checksum.py` - Checksum calculation utilities
- `bitarr/core/scanner/device_detector.py` - Storage device detection
- `bitarr/core/scanner/file_utils.py` - File system utilities
- `bitarr/core/__main__.py` - Command-line interface for scanner

### Web Application
- `bitarr/web/__init__.py` - Package initialization
- `bitarr/web/app.py` - Flask application factory
- `bitarr/web/routes.py` - Web routes and view functions
- `bitarr/web/api.py` - API endpoints
- `bitarr/web/utils.py` - Utility functions for the web application
- `bitarr/web/__main__.py` - Entry point for the web application
- `bitarr/web/static/css/style.css` - Main stylesheet
- `bitarr/web/static/js/main.js` - Client-side JavaScript
- `bitarr/web/templates/layout.html` - Base template
- `bitarr/web/templates/index.html` - Home page template

### Project Setup
- `bitarr/__init__.py` - Package initialization
- `bitarr/__main__.py` - Main entry point
- `README.md` - Project documentation
- `setup.py` - Package setup script
- `requirements.txt` - Dependencies list
- `.gitignore` - Git ignore configuration

## Priorities for Next Steps

1. **Complete Web UI Templates**
   - Implement the remaining templates:
     - `scan_history.html` - For viewing all scan history
     - `scan_details.html` - For detailed view of a scan
     - `storage_health.html` - For storage device health monitoring
     - `scheduled_scans.html` - For managing scheduled scans
     - `configuration.html` - For application configuration
     - `database_management.html` - For database maintenance

2. **Scheduler Implementation**
   - Implement the scheduler service to run scans on a schedule
   - Create cron-like scheduling functionality
   - Build queue management for scan operations

3. **Advanced File Analysis**
   - Implement trend analysis for file corruption
   - Add directory-level corruption visualization
   - Create file type statistics and reporting

4. **Testing and Performance Optimization**
   - Create comprehensive unit tests
   - Optimize file scanning for large file systems
   - Implement performance tuning options

5. **Docker Containerization**
   - Create Dockerfile and docker-compose.yml
   - Configure volume mappings for file system access
   - Set up appropriate permissions and security

## Next Session Focus

In the next session, we should focus on:

1. Implementing the remaining web UI templates
2. Completing the client-side JavaScript for interactive features
3. Building the scheduler implementation
4. Adding comprehensive error handling and logging

## Running the Application

The application can be run using the following commands:

```bash
# Initialize the database
python -m bitarr db init

# Run the web application
python -m bitarr web --host 0.0.0.0 --port 8286

# Run a scan from the command line
python -m bitarr core scan /path/to/scan --algorithm sha256 --threads 4

# List available checksum algorithms
python -m bitarr core algorithms

# Detect storage devices
python -m bitarr core devices
```

## Conclusion

We've made significant progress in implementing the core functionality of Bitarr. The database layer, scanner engine, and web application framework are all in place, providing a solid foundation for completing the remaining features in the next session.

</code>

__init__.py:
<code>

</code>

__main__.py:
<code>
"""
Main entry point for Bitarr application.
"""
import argparse
import sys

def main():
    """
    Main entry point for Bitarr.
    """
    parser = argparse.ArgumentParser(description="Bitarr - File Integrity Scanner")
    subparsers = parser.add_subparsers(dest="command", help="Command")

    # Web command
    web_parser = subparsers.add_parser("web", help="Run the web interface")
    web_parser.add_argument('--host', default='127.0.0.1', help='Host to bind to')
    web_parser.add_argument('--port', type=int, default=8286, help='Port to bind to')
    web_parser.add_argument('--debug', action='store_true', help='Enable debug mode')

    # Core command
    core_parser = subparsers.add_parser("core", help="Run core scanner functions")
    core_subparsers = core_parser.add_subparsers(dest="core_command", help="Core command")

    # Scan command
    scan_parser = core_subparsers.add_parser("scan", help="Scan a directory")
    scan_parser.add_argument("path", help="Directory path to scan")
    scan_parser.add_argument("--name", help="Name for the scan")
    scan_parser.add_argument("--algorithm", default="sha256", help="Checksum algorithm to use")
    scan_parser.add_argument("--threads", type=int, default=4, help="Number of threads to use")
    scan_parser.add_argument("--exclude", help="Comma-separated list of directories to exclude")

    # Algorithms command
    algorithms_parser = core_subparsers.add_parser("algorithms", help="List available checksum algorithms")

    # Devices command
    devices_parser = core_subparsers.add_parser("devices", help="Detect storage devices")

    # DB command
    db_parser = subparsers.add_parser("db", help="Database management")
    db_subparsers = db_parser.add_subparsers(dest="db_command", help="Database command")

    # Init command
    init_parser = db_subparsers.add_parser("init", help="Initialize database")
    init_parser.add_argument("--path", type=str, help="Path to database file", default=None)

    # Info command
    info_parser = db_subparsers.add_parser("info", help="Show database information")
    info_parser.add_argument("--path", type=str, help="Path to database file", default=None)

    # Parse arguments
    args = parser.parse_args()

    if args.command == "web":
        # Import web module and run
        from bitarr.web import create_app, socketio
        from bitarr.db.init_db import init_db
        from bitarr.db.db_manager import DatabaseManager

        # Check if database exists, initialize if needed
        try:
            db = DatabaseManager()
            db.get_all_configuration()
        except Exception:
            print("Database not found or incomplete. Initializing...")
            init_db()

        # Create app and run
        app = create_app()
        socketio.run(app, host=args.host, port=args.port, debug=args.debug)

    elif args.command == "core":
        if args.core_command == "scan":
            # Import core module and run scan
            from bitarr.core.scanner import FileScanner, ScannerError
            from bitarr.db.db_manager import DatabaseManager

            # Parse exclude dirs
            exclude_dirs = None
            if args.exclude:
                exclude_dirs = [d.strip() for d in args.exclude.split(',')]

            try:
                # Create scanner
                db = DatabaseManager()
                scanner = FileScanner(db)

                # Define progress callback
                def progress_callback(progress_data):
                    """Callback function to display scan progress."""
                    status = progress_data["status"]
                    files_processed = progress_data["files_processed"]
                    total_files = progress_data["total_files"]
                    percent = progress_data["percent_complete"]

                    if status == "counting":
                        print(f"Counting files in {progress_data.get('current_path', '')}")
                    elif status == "starting":
                        print(f"Starting scan, found {total_files} files to process")
                    elif status == "scanning":
                        current_path = progress_data.get('current_path', '')
                        short_path = current_path.split('/')[-1] if current_path else ''
                        print(f"\rScanning: {files_processed}/{total_files} ({percent:.1f}%) - {short_path}", end="")
                    elif status == "completed":
                        print(f"\nScan completed: {files_processed} files processed")
                    elif status == "failed":
                        print(f"\nScan failed: {progress_data.get('error', 'Unknown error')}")

                # Add progress callback
                scanner.add_progress_callback(progress_callback)

                # Run scan
                scan_id = scanner.scan(
                    top_level_path=args.path,
                    name=args.name,
                    checksum_method=args.algorithm,
                    threads=args.threads,
                    exclude_dirs=exclude_dirs
                )

                # Get scan results
                scan_summary = scanner.get_scan_summary(scan_id)

                # Print results
                print("\nScan complete!")
                print(f"Scan ID: {scan_id}")
                print(f"Files scanned: {scan_summary['files_scanned']}")
                print(f"Files unchanged: {scan_summary['files_unchanged']}")
                print(f"Files modified: {scan_summary['files_modified']}")
                print(f"Files corrupted: {scan_summary['files_corrupted']}")
                print(f"Files missing: {scan_summary['files_missing']}")
                print(f"Files new: {scan_summary['files_new']}")

            except ScannerError as e:
                print(f"Error: {str(e)}")
                sys.exit(1)
            except KeyboardInterrupt:
                print("\nScan interrupted.")
                sys.exit(1)

        elif args.core_command == "algorithms":
            # Import core module and list algorithms
            from bitarr.core.scanner import ChecksumCalculator

            calculator = ChecksumCalculator()
            algorithms = calculator.get_supported_algorithms()

            print("Available checksum algorithms:")
            for algorithm in algorithms:
                print(f"  - {algorithm}")

            print("\nAlgorithm details:")
            info = calculator.algorithm_info()
            for algorithm, details in info.items():
                print(f"  {algorithm}:")
                print(f"    Description: {details['description']}")
                print(f"    Speed: {details['speed']}")
                print(f"    Security: {details['security']}")
                print(f"    Recommendation: {details['recommendation']}")
                print()

        elif args.core_command == "devices":
            # Import core module and detect devices
            from bitarr.core.scanner import DeviceDetector

            detector = DeviceDetector()
            devices = detector.detect_devices()

            print(f"Detected {len(devices)} storage devices:")
            for i, device in enumerate(devices, 1):
                print(f"  {i}. {device['name']} ({device['mount_point']})")
                print(f"     Type: {device['device_type']}")
                if 'total_size' in device and device['total_size'] > 0:
                    size_gb = device['total_size'] / (1024**3)
                    print(f"     Size: {size_gb:.1f} GB")
                    print(f"     Used: {device['usage_percent']:.1f}%")
                print(f"     Device ID: {device['device_id']}")
                print()

        else:
            core_parser.print_help()

    elif args.command == "db":
        if args.db_command == "init":
            # Import db module and initialize
            from bitarr.db.init_db import init_db

            db_path = init_db(args.path)
            print(f"Database initialized at: {db_path}")

        elif args.db_command == "info":
            # Import db module and show info
            from bitarr.db.db_manager import DatabaseManager

            db = DatabaseManager(args.path)
            info = db.get_database_info()

            print("\nDatabase Information:")
            print(f"Path: {db.db_path}")
            size_mb = info['database_size'] / (1024*1024) if 'database_size' in info else 0
            print(f"Size: {size_mb:.2f} MB")

            print("\nCounts:")
            print(f"  Storage Devices: {info.get('storage_devices_count', 0)}")
            print(f"  Files: {info.get('files_count', 0)}")
            print(f"  Scans: {info.get('scans_count', 0)}")
            print(f"  Checksums: {info.get('checksums_count', 0)}")
            print(f"  Scheduled Scans: {info.get('scheduled_scans_count', 0)}")
            print(f"  Scan Errors: {info.get('scan_errors_count', 0)}")
            print(f"  Configuration Items: {info.get('configuration_count', 0)}")

            if info.get('first_scan'):
                print(f"\nFirst Scan: {info['first_scan']}")
            if info.get('last_scan'):
                print(f"Last Scan: {info['last_scan']}")

        else:
            db_parser.print_help()

    else:
        parser.print_help()
        sys.exit(1)

if __name__ == "__main__":
    main()

</code>

core/__init__.py:
<code>
"""
Core module for Bitarr.
"""

</code>

core/__main__.py:
<code>
"""
Command-line interface for the Bitarr core scanner.
"""
import argparse
import os
import sys
import time
from datetime import datetime
from pathlib import Path

from bitarr.db.db_manager import DatabaseManager
from bitarr.core.scanner import FileScanner, ChecksumCalculator, DeviceDetector

def progress_callback(progress_data):
    """
    Callback function to display scan progress.
    """
    status = progress_data["status"]
    files_processed = progress_data["files_processed"]
    total_files = progress_data["total_files"]
    percent = progress_data["percent_complete"]

    if status == "counting":
        print(f"Counting files in {progress_data.get('current_path', '')}")
    elif status == "starting":
        print(f"Starting scan, found {total_files} files to process")
    elif status == "scanning":
        current_path = progress_data.get('current_path', '')
        short_path = os.path.basename(current_path) if current_path else ''
        print(f"\rScanning: {files_processed}/{total_files} ({percent:.1f}%) - {short_path}", end="")
    elif status == "completed":
        print(f"\nScan completed: {files_processed} files processed")
    elif status == "failed":
        print(f"\nScan failed: {progress_data.get('error', 'Unknown error')}")
    else:
        print(f"\rStatus: {status} - {files_processed}/{total_files} ({percent:.1f}%)", end="")

def list_checksum_algorithms():
    """
    List available checksum algorithms.
    """
    calculator = ChecksumCalculator()
    algorithms = calculator.get_supported_algorithms()

    print("Available checksum algorithms:")
    for algorithm in algorithms:
        print(f"  - {algorithm}")

    print("\nAlgorithm details:")
    info = calculator.algorithm_info()
    for algorithm, details in info.items():
        print(f"  {algorithm}:")
        print(f"    Description: {details['description']}")
        print(f"    Speed: {details['speed']}")
        print(f"    Security: {details['security']}")
        print(f"    Recommendation: {details['recommendation']}")
        print()

def detect_devices():
    """
    Detect and display storage devices.
    """
    detector = DeviceDetector()
    devices = detector.detect_devices()

    print(f"Detected {len(devices)} storage devices:")
    for i, device in enumerate(devices, 1):
        print(f"  {i}. {device['name']} ({device['mount_point']})")
        print(f"     Type: {device['device_type']}")
        if 'total_size' in device and device['total_size'] > 0:
            print(f"     Size: {device['total_size'] / (1024**3):.1f} GB")
            print(f"     Used: {device['usage_percent']:.1f}%")
        print(f"     Device ID: {device['device_id']}")
        print()

def run_scan(path, name=None, algorithm="sha256", threads=4, exclude=None):
    """
    Run a scan on a directory.

    Args:
        path: Directory path to scan
        name: Name for the scan
        algorithm: Checksum algorithm to use
        threads: Number of threads to use
        exclude: Comma-separated list of directories to exclude
    """
    # Normalize path
    path = os.path.abspath(path)

    # Parse exclusions
    exclude_dirs = None
    if exclude:
        exclude_dirs = [d.strip() for d in exclude.split(',')]

    # Create a database manager
    db = DatabaseManager()

    # Create a scanner
    scanner = FileScanner(db)

    # Add progress callback
    scanner.add_progress_callback(progress_callback)

    print(f"Starting scan of {path}")
    print(f"Using {algorithm} algorithm with {threads} threads")

    if exclude_dirs:
        print(f"Excluding directories: {', '.join(exclude_dirs)}")

    try:
        # Start scan
        start_time = time.time()
        scan_id = scanner.scan(
            top_level_path=path,
            name=name,
            checksum_method=algorithm,
            threads=threads,
            exclude_dirs=exclude_dirs
        )
        end_time = time.time()

        # Get scan summary
        summary = scanner.get_scan_summary(scan_id)

        print("\nScan complete!")
        print(f"Scan ID: {scan_id}")
        print(f"Time: {end_time - start_time:.2f} seconds")
        print(f"Files scanned: {summary['files_scanned']}")
        print(f"Files unchanged: {summary['files_unchanged']}")
        print(f"Files modified: {summary['files_modified']}")
        print(f"Files corrupted: {summary['files_corrupted']}")
        print(f"Files missing: {summary['files_missing']}")
        print(f"Files new: {summary['files_new']}")
        print(f"Errors: {summary['error_count']}")

        # Show storage devices
        print("\nStorage devices:")
        for device in summary['storage_devices']:
            print(f"  {device['name']} ({device['mount_point']}): {device['file_count']} files")

    except KeyboardInterrupt:
        print("\nScan interrupted, stopping...")
        scanner.stop()
        sys.exit(1)

    except Exception as e:
        print(f"\nError: {str(e)}")
        sys.exit(1)

def main():
    """
    Main entry point for the command-line interface.
    """
    parser = argparse.ArgumentParser(description="Bitarr core scanner")

    # Add subparsers
    subparsers = parser.add_subparsers(dest="command", help="Command")

    # Scan command
    scan_parser = subparsers.add_parser("scan", help="Scan a directory")
    scan_parser.add_argument("path", help="Directory path to scan")
    scan_parser.add_argument("--name", help="Name for the scan")
    scan_parser.add_argument("--algorithm", default="sha256", help="Checksum algorithm to use")
    scan_parser.add_argument("--threads", type=int, default=4, help="Number of threads to use")
    scan_parser.add_argument("--exclude", help="Comma-separated list of directories to exclude")

    # List algorithms command
    algorithms_parser = subparsers.add_parser("algorithms", help="List available checksum algorithms")

    # Detect devices command
    devices_parser = subparsers.add_parser("devices", help="Detect storage devices")

    # Parse arguments
    args = parser.parse_args()

    if args.command == "scan":
        run_scan(args.path, args.name, args.algorithm, args.threads, args.exclude)
    elif args.command == "algorithms":
        list_checksum_algorithms()
    elif args.command == "devices":
        detect_devices()
    else:
        parser.print_help()
        sys.exit(1)

if __name__ == "__main__":
    main()

</code>

core/scanner/checksum.py:
<code>
"""
Checksum calculation utilities for Bitarr.
"""
import os
import hashlib
import xxhash
import blake3
from typing import BinaryIO, Callable, Dict, Optional

# Define supported checksum algorithms and their functions
CHECKSUM_ALGORITHMS = {
    "md5": lambda: hashlib.md5(),
    "sha1": lambda: hashlib.sha1(),
    "sha256": lambda: hashlib.sha256(),
    "sha512": lambda: hashlib.sha512(),
    "xxhash64": lambda: xxhash.xxh64(),
    "blake2b": lambda: hashlib.blake2b(),
    "blake3": lambda: blake3.blake3()
}

class ChecksumCalculator:
    """
    Handles checksum calculation for files using various algorithms.
    """
    
    def __init__(self, algorithm: str = "sha256", block_size_mb: int = 4):
        """
        Initialize the checksum calculator.
        
        Args:
            algorithm: Checksum algorithm to use (md5, sha1, sha256, sha512, xxhash64, blake2b, blake3)
            block_size_mb: Size of blocks to read in MB
        
        Raises:
            ValueError: If algorithm is not supported
        """
        if algorithm not in CHECKSUM_ALGORITHMS:
            supported = ", ".join(CHECKSUM_ALGORITHMS.keys())
            raise ValueError(f"Unsupported checksum algorithm: {algorithm}. Supported algorithms: {supported}")
        
        self.algorithm = algorithm
        self.block_size = block_size_mb * 1024 * 1024  # Convert MB to bytes
    
    def calculate_file_checksum(self, file_path: str) -> Optional[str]:
        """
        Calculate checksum for a file.
        
        Args:
            file_path: Path to the file
        
        Returns:
            str: Hexadecimal checksum string or None if file is not accessible
        """
        try:
            with open(file_path, "rb") as f:
                return self.calculate_stream_checksum(f)
        except (IOError, PermissionError, FileNotFoundError) as e:
            print(f"Error calculating checksum for {file_path}: {str(e)}")
            return None
    
    def calculate_stream_checksum(self, stream: BinaryIO) -> str:
        """
        Calculate checksum for a binary stream.
        
        Args:
            stream: Binary stream to read from
        
        Returns:
            str: Hexadecimal checksum string
        """
        hasher = CHECKSUM_ALGORITHMS[self.algorithm]()
        
        # Read and update the hash in blocks
        while True:
            data = stream.read(self.block_size)
            if not data:
                break
            hasher.update(data)
        
        return hasher.hexdigest()
    
    def calculate_string_checksum(self, text: str) -> str:
        """
        Calculate checksum for a string.
        
        Args:
            text: String to calculate checksum for
        
        Returns:
            str: Hexadecimal checksum string
        """
        hasher = CHECKSUM_ALGORITHMS[self.algorithm]()
        hasher.update(text.encode('utf-8'))
        return hasher.hexdigest()
    
    @staticmethod
    def get_supported_algorithms() -> list:
        """
        Get a list of supported checksum algorithms.
        
        Returns:
            list: List of supported algorithm names
        """
        return list(CHECKSUM_ALGORITHMS.keys())
    
    @staticmethod
    def algorithm_info() -> Dict[str, Dict[str, str]]:
        """
        Get information about supported algorithms.
        
        Returns:
            Dict: Dictionary with algorithm information
        """
        return {
            "md5": {
                "description": "Fast, but cryptographically broken",
                "speed": "Very fast",
                "security": "Low",
                "recommendation": "Not recommended for security purposes"
            },
            "sha1": {
                "description": "Older algorithm with known weaknesses",
                "speed": "Fast",
                "security": "Medium-Low",
                "recommendation": "Not recommended for security purposes"
            },
            "sha256": {
                "description": "Secure hash algorithm (SHA-2 family)",
                "speed": "Medium",
                "security": "High",
                "recommendation": "Good balance of security and speed"
            },
            "sha512": {
                "description": "Secure hash algorithm with larger output (SHA-2 family)",
                "speed": "Medium",
                "security": "Very High",
                "recommendation": "Good for high-security needs"
            },
            "xxhash64": {
                "description": "Extremely fast non-cryptographic hash function",
                "speed": "Extremely Fast",
                "security": "Low (not cryptographic)",
                "recommendation": "Best for performance-critical scanning"
            },
            "blake2b": {
                "description": "Modern cryptographic hash function",
                "speed": "Fast",
                "security": "High",
                "recommendation": "Good balance of speed and security"
            },
            "blake3": {
                "description": "Latest generation hash function",
                "speed": "Very Fast",
                "security": "High",
                "recommendation": "Best balance of speed and security"
            }
        }

</code>

core/scanner/device_detector.py:
<code>
"""
Storage device detection for Bitarr.
"""
import os
import re
import subprocess
from pathlib import Path
from typing import Dict, List, Optional
from .file_utils import get_storage_device_info

class DeviceDetector:
    """
    Detects and provides information about storage devices.
    """
    
    def __init__(self):
        """
        Initialize the device detector.
        """
        self.devices = {}
    
    def detect_devices(self) -> List[Dict]:
        """
        Detect all storage devices.

        Returns:
            List[Dict]: List of storage device information dictionaries
        """
        devices = []

        # List of filesystem types to exclude
        exclude_fs_types = [
            'proc', 'sysfs', 'devpts', 'cgroup', 'tmpfs', 'securityfs',
            'fusectl', 'debugfs', 'configfs', 'hugetlbfs', 'mqueue',
            'pstore', 'efivarfs', 'fuse.snapfuse', 'fuse.gvfsd-fuse',
            'squashfs', 'nsfs', 'binfmt_misc', 'rpc_pipefs', 'devtmpfs'
        ]

        # List of mount point prefixes to exclude
        exclude_mount_prefixes = [
            '/proc', '/sys', '/dev', '/run', '/snap', '/boot',
            '/opt/piavpn', '/var/snap', '/run/snapd'
        ]

        # Try to get information from /proc/mounts
        if os.path.exists('/proc/mounts'):
            with open('/proc/mounts', 'r') as f:
                mounts = f.readlines()

            for mount in mounts:
                parts = mount.split()
                if len(parts) >= 4:  # Ensure we have enough parts to check filesystem type
                    device_id, mount_point, fs_type = parts[0], parts[1], parts[2]

                    # Skip virtual and system filesystems
                    if fs_type in exclude_fs_types:
                        continue

                    # Skip specific mount points
                    if any(mount_point.startswith(prefix) for prefix in exclude_mount_prefixes):
                        continue

                    # Skip loopback devices (snap packages)
                    if 'loop' in device_id:
                        continue

                    # Skip rootfs duplicate
                    if device_id == 'rootfs':
                        continue

                    # Get device info
                    if os.path.exists(mount_point) and os.access(mount_point, os.R_OK):
                        try:
                            device_info = get_storage_device_info(mount_point)
                            device_info.update({
                                "name": self._get_device_name(device_id, mount_point, fs_type),
                                "mount_point": mount_point,
                                "device_id": device_id,
                                "fs_type": fs_type
                            })
                            devices.append(device_info)
                        except Exception as e:
                            print(f"Error getting info for {mount_point}: {str(e)}")

        # Run lsblk command if available (Linux)
        try:
            result = subprocess.run(
                ['lsblk', '-o', 'NAME,SIZE,TYPE,MOUNTPOINT', '-J'],
                capture_output=True, text=True, check=True
            )
            import json
            lsblk_data = json.loads(result.stdout)

            # Process lsblk output to enhance device info
            if 'blockdevices' in lsblk_data:
                for device in devices:
                    for blk_device in lsblk_data['blockdevices']:
                        if device['device_id'].endswith(blk_device['name']):
                            device['size_human'] = blk_device.get('size', 'Unknown')
                            device['type'] = blk_device.get('type', 'Unknown')
        except (subprocess.SubprocessError, json.JSONDecodeError, FileNotFoundError):
            # lsblk not available or failed
            pass

        return devices

    def get_device_by_path(self, path: str) -> Optional[Dict]:
        """
        Get the storage device information for a path.
        
        Args:
            path: Path to check
        
        Returns:
            Dict: Storage device information or None if not found
        """
        path_obj = Path(path)
        if not path_obj.exists():
            return None
        
        # Get all devices
        devices = self.detect_devices()
        
        # Find the device with the most specific mount point
        matching_devices = []
        for device in devices:
            if path.startswith(device['mount_point']):
                matching_devices.append(device)
        
        if not matching_devices:
            return None
        
        # Return the device with the longest mount point path
        return sorted(matching_devices, key=lambda d: len(d['mount_point']), reverse=True)[0]
    
    def _get_device_name(self, device_id: str, mount_point: str, fs_type: str = None) -> str:
        """
        Generate a friendly name for a device.

        Args:
            device_id: Device identifier
            mount_point: Mount point path
            fs_type: Filesystem type

        Returns:
            str: Friendly device name
        """
        # For network shares, use the server name
        if 'nfs' in device_id or '//' in device_id or '192.168.' in device_id:
            match = re.search(r'//([^/]+)|(\d+\.\d+\.\d+\.\d+)', device_id)
            if match:
                server = match.group(1) or match.group(2)
                return f"Network Share ({server}) - {mount_point}"
            return f"Network Share - {mount_point}"

        # For standard block devices
        if '/dev/' in device_id:
            device_type = "Storage"

            # Try to determine if it's an SSD or HDD
            if 'nvme' in device_id:
                device_type = "Internal SSD"
            elif 'sd' in device_id:
                # Try to determine if it's external
                if self._is_likely_external(device_id):
                    device_type = "External Drive"
                else:
                    device_type = "Internal HDD"

            # Include filesystem type if available
            fs_info = f" ({fs_type})" if fs_type else ""

            # Make mount point more readable
            display_mount = mount_point
            if mount_point == '/':
                display_mount = "Root"
            elif mount_point == '/home':
                display_mount = "Home"

            return f"{device_type}{fs_info} - {display_mount}"

        # For root or home directories, use standard names
        if mount_point == '/':
            return f"Root Filesystem{' (' + fs_type + ')' if fs_type else ''}"
        elif mount_point == '/home':
            return f"Home Directory{' (' + fs_type + ')' if fs_type else ''}"

        # Default: use the mount point
        return f"Storage - {mount_point}{' (' + fs_type + ')' if fs_type else ''}"
    
    def _is_likely_external(self, device_id: str) -> bool:
        """
        Check if a device is likely to be external.
        
        Args:
            device_id: Device identifier
        
        Returns:
            bool: True if likely external, False otherwise
        """
        # Try to determine by checking for USB in the sysfs path
        try:
            dev_name = os.path.basename(device_id)
            if not dev_name.startswith('sd'):
                return False
            
            # Check if the device is connected via USB
            for path in [f'/sys/block/{dev_name}/device/driver']:
                if os.path.exists(path):
                    try:
                        real_path = os.path.realpath(path)
                        return 'usb' in real_path.lower()
                    except OSError:
                        pass
        except Exception:
            pass
        
        return False

</code>

core/scanner/__init__.py:
<code>
"""
Scanner module for Bitarr.
"""
from .scanner import FileScanner, ScannerError
from .checksum import ChecksumCalculator
from .device_detector import DeviceDetector
from .file_utils import get_file_metadata, walk_directory, split_path_components

__all__ = [
    'FileScanner',
    'ScannerError',
    'ChecksumCalculator',
    'DeviceDetector',
    'get_file_metadata',
    'walk_directory',
    'split_path_components'
]


</code>

core/scanner/file_utils.py:
<code>
"""
File utilities for Bitarr scanner.
"""
import os
import stat
import time
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Generator

def get_file_metadata(file_path: str) -> Dict:
    """
    Get metadata for a file.
    
    Args:
        file_path: Path to the file
    
    Returns:
        Dict: File metadata including size, last_modified, and file_type
    """
    try:
        file_stat = os.stat(file_path)
        file_type = determine_file_type(file_path)
        
        return {
            "size": file_stat.st_size,
            "last_modified": time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(file_stat.st_mtime)),
            "file_type": file_type,
            "is_directory": stat.S_ISDIR(file_stat.st_mode),
            "is_file": stat.S_ISREG(file_stat.st_mode),
            "is_symlink": stat.S_ISLNK(file_stat.st_mode),
            "permissions": stat.filemode(file_stat.st_mode)
        }
    except (OSError, PermissionError, FileNotFoundError):
        return {
            "size": 0,
            "last_modified": None,
            "file_type": None,
            "is_directory": False,
            "is_file": False,
            "is_symlink": False,
            "permissions": None
        }

def determine_file_type(file_path: str) -> str:
    """
    Determine file type based on extension.
    
    Args:
        file_path: Path to the file
    
    Returns:
        str: File type or "unknown"
    """
    extension = Path(file_path).suffix.lower()
    
    # Common file type mappings
    type_map = {
        # Documents
        '.txt': 'text',
        '.pdf': 'pdf',
        '.doc': 'word',
        '.docx': 'word',
        '.xls': 'excel',
        '.xlsx': 'excel',
        '.ppt': 'powerpoint',
        '.pptx': 'powerpoint',
        
        # Images
        '.jpg': 'image',
        '.jpeg': 'image',
        '.png': 'image',
        '.gif': 'image',
        '.bmp': 'image',
        '.svg': 'image',
        '.webp': 'image',
        
        # Audio
        '.mp3': 'audio',
        '.wav': 'audio',
        '.ogg': 'audio',
        '.flac': 'audio',
        '.aac': 'audio',
        
        # Video
        '.mp4': 'video',
        '.avi': 'video',
        '.mkv': 'video',
        '.mov': 'video',
        '.wmv': 'video',
        
        # Archives
        '.zip': 'archive',
        '.rar': 'archive',
        '.7z': 'archive',
        '.tar': 'archive',
        '.gz': 'archive',
        
        # Programming
        '.py': 'code',
        '.js': 'code',
        '.html': 'code',
        '.css': 'code',
        '.java': 'code',
        '.cpp': 'code',
        '.c': 'code',
        '.php': 'code',
        '.go': 'code',
        '.rb': 'code',
        
        # System
        '.exe': 'executable',
        '.dll': 'library',
        '.so': 'library',
        '.sys': 'system',
        '.conf': 'config',
        '.log': 'log',
        '.db': 'database',
        '.sqlite': 'database',
    }
    
    return type_map.get(extension, "unknown")

def walk_directory(
    top_dir: str,
    exclude_dirs: List[str] = None,
    exclude_patterns: List[str] = None,
    max_depth: int = None
) -> Generator[str, None, None]:
    """
    Walk a directory recursively and yield file paths.

    Args:
        top_dir: Top-level directory to start walking from
        exclude_dirs: List of directory names to exclude
        exclude_patterns: List of glob patterns to exclude
        max_depth: Maximum depth to traverse

    Yields:
        str: Absolute file path
    """
    exclude_dirs = exclude_dirs or []
    exclude_patterns = exclude_patterns or []

    top_dir_path = Path(top_dir)
    if not top_dir_path.exists() or not top_dir_path.is_dir():
        print(f"Error: {top_dir} is not a valid directory")
        return

    # Walk the directory
    for root, dirs, files in os.walk(top_dir):
        # Calculate current depth
        rel_path = os.path.relpath(root, top_dir)
        current_depth = 0 if rel_path == '.' else len(rel_path.split(os.sep))

        # Check max depth
        if max_depth is not None and current_depth >= max_depth:
            dirs.clear()  # Don't go deeper
            continue

        # Exclude directories (in-place to avoid traversing them)
        dirs[:] = [d for d in dirs if d not in exclude_dirs]

        # Process files
        for file in files:
            file_path = os.path.join(root, file)

            # Check exclude patterns
            exclude_file = False
            for pattern in exclude_patterns:
                if Path(file_path).match(pattern):
                    exclude_file = True
                    break

            if exclude_file:
                continue

            yield file_path

def get_storage_device_info(path: str) -> Dict:
    """
    Get information about the storage device containing the path.
    
    Args:
        path: Path to check
    
    Returns:
        Dict: Storage device information
    """
    try:
        path_obj = Path(path)
        if not path_obj.exists():
            return {"error": "Path does not exist"}
        
        # Get disk usage statistics
        usage = os.statvfs(path)
        total_size = usage.f_frsize * usage.f_blocks
        free_size = usage.f_frsize * usage.f_bfree
        used_size = total_size - free_size
        
        # Try to determine device type (basic detection)
        device_type = "unknown"
        mount_point = "/"
        device_id = None
        
        # On Linux, we can read /proc/mounts for more information
        if os.path.exists('/proc/mounts'):
            with open('/proc/mounts', 'r') as f:
                mounts = f.readlines()
            
            # Find the mount point that is a parent of the path
            mount_points = []
            for mount in mounts:
                parts = mount.split()
                if len(parts) >= 2:
                    device, mount_point = parts[0], parts[1]
                    if path.startswith(mount_point):
                        mount_points.append((mount_point, device))
            
            # Get the most specific mount point (longest path)
            if mount_points:
                mount_points.sort(key=lambda x: len(x[0]), reverse=True)
                mount_point, device_id = mount_points[0]
                
                # Determine device type
                if 'tmpfs' in device_id:
                    device_type = 'tmpfs'
                elif 'loop' in device_id:
                    device_type = 'loopback'
                elif 'nfs' in device_id:
                    device_type = 'network'
                elif '/dev/sd' in device_id:
                    device_type = 'internal_hdd'
                elif '/dev/nvme' in device_id:
                    device_type = 'internal_ssd'
        
        return {
            "mount_point": mount_point,
            "device_type": device_type,
            "device_id": device_id,
            "total_size": total_size,
            "used_size": used_size,
            "free_size": free_size,
            "usage_percent": (used_size / total_size) * 100 if total_size > 0 else 0
        }
    except Exception as e:
        return {
            "error": f"Failed to get storage device info: {str(e)}",
            "mount_point": "/",
            "device_type": "unknown",
            "device_id": None,
            "total_size": 0,
            "used_size": 0,
            "free_size": 0,
            "usage_percent": 0
        }

def split_path_components(file_path: str) -> Tuple[str, str, str]:
    """
    Split a file path into directory, filename, and path.
    
    Args:
        file_path: Path to split
    
    Returns:
        Tuple: (directory, filename, path)
    """
    path_obj = Path(file_path)
    directory = str(path_obj.parent)
    filename = path_obj.name
    path = str(path_obj)
    
    return directory, filename, path

</code>

core/scanner/scanner.py:
<code>
"""
Core scanner implementation for Bitarr.
"""
import os
import threading
import time
import queue
from datetime import datetime, timezone
from typing import Dict, List, Optional, Callable, Tuple, Any
from pathlib import Path

from bitarr.db.db_manager import DatabaseManager
from bitarr.db.models import File, Scan, Checksum, StorageDevice, ScanError
from .checksum import ChecksumCalculator
from .device_detector import DeviceDetector
from .file_utils import get_file_metadata, walk_directory, split_path_components

class ScannerError(Exception):
    """Exception raised for scanner errors."""
    pass

class FileScanner:
    """
    Core file scanner for Bitarr.
    
    Handles file system scanning, checksum calculation, and change detection.
    """
    
    def __init__(self, db_manager: Optional[DatabaseManager] = None):
        """
        Initialize the file scanner.
        
        Args:
            db_manager: Database manager instance, or None to create a new one
        """
        self.db = db_manager or DatabaseManager()
        self.device_detector = DeviceDetector()
        self.checksum_calculator = None  # Will be initialized in scan
        self.current_scan = None
        self.stop_event = threading.Event()
        self.queue = queue.Queue()
        self.threads = []
        self.files_processed = 0
        self.total_files = 0
        self.progress_callbacks = []
    
    def add_progress_callback(self, callback: Callable[[Dict], None]) -> None:
        """
        Add a callback to receive progress updates.
        
        Args:
            callback: Function that takes a dictionary with progress information
        """
        self.progress_callbacks.append(callback)
    
    def _report_progress(self, status: str, **kwargs) -> None:
        """
        Report progress to all registered callbacks.
        
        Args:
            status: Current status
            **kwargs: Additional information to include
        """
        progress_data = {
            "status": status,
            "scan_id": self.current_scan.id if self.current_scan else None,
            "files_processed": self.files_processed,
            "total_files": self.total_files,
            "percent_complete": (self.files_processed / self.total_files * 100) if self.total_files > 0 else 0,
            "timestamp": datetime.now(timezone.utc),
            **kwargs
        }
        
        for callback in self.progress_callbacks:
            try:
                callback(progress_data)
            except Exception as e:
                print(f"Error in progress callback: {str(e)}")
    
    def scan(
        self, 
        top_level_path: str, 
        name: Optional[str] = None,
        checksum_method: str = "sha256", 
        threads: int = 4,
        exclude_dirs: List[str] = None,
        exclude_patterns: List[str] = None,
        scheduled_scan_id: Optional[int] = None
    ) -> int:
        """
        Scan a directory tree, calculate checksums, and detect changes.
        
        Args:
            top_level_path: Top-level directory to scan
            name: Name for the scan
            checksum_method: Checksum algorithm to use
            threads: Number of threads to use
            exclude_dirs: List of directory names to exclude
            exclude_patterns: List of glob patterns to exclude
            scheduled_scan_id: ID of the scheduled scan, if any
        
        Returns:
            int: ID of the created scan
        
        Raises:
            ScannerError: If the scan fails
        """
        # Validate input
        if not os.path.exists(top_level_path) or not os.path.isdir(top_level_path):
            raise ScannerError(f"Invalid top_level_path: {top_level_path}")
        
        # Normalize path
        top_level_path = os.path.abspath(top_level_path)
        
        # Initialize checksum calculator
        self.checksum_calculator = ChecksumCalculator(algorithm=checksum_method)
        
        # Default exclusions
        exclude_dirs = exclude_dirs or ['.git', 'node_modules', '.venv', 'venv', '__pycache__']
        exclude_patterns = exclude_patterns or ['*.tmp', '*.temp', '*.swp', '*.bak']
        
        # Create a new scan
        self.current_scan = Scan(
            name=name or f"Scan of {os.path.basename(top_level_path)}",
            top_level_path=top_level_path,
            status="running",
            checksum_method=checksum_method,
            scheduled_scan_id=scheduled_scan_id
        )
        
        # Add scan to database
        self.current_scan.id = self.db.add_scan(self.current_scan)
        
        # Detect the storage device
        device_info = self.device_detector.get_device_by_path(top_level_path)
        if not device_info:
            # If device not found, create a default one
            device_info = {
                "name": "Unknown Device",
                "mount_point": "/",
                "device_type": "unknown",
                "device_id": None,
                "total_size": 0,
                "used_size": 0
            }
        
        # Check if the device exists in the database
        storage_device = self.db.get_storage_device(
            device_id=device_info['device_id'], 
            mount_point=device_info['mount_point']
        )
        
        if not storage_device:
            # Create a new storage device
            storage_device = StorageDevice(
                name=device_info['name'],
                mount_point=device_info['mount_point'],
                device_type=device_info['device_type'],
                total_size=device_info['total_size'],
                used_size=device_info['used_size'],
                device_id=device_info['device_id']
            )
            storage_device.id = self.db.add_storage_device(storage_device)
        else:
            # Update the existing device
            storage_device.last_seen = datetime.now(timezone.utc)
            storage_device.is_connected = True
            storage_device.total_size = device_info['total_size']
            storage_device.used_size = device_info['used_size']
            self.db.update_storage_device(storage_device)
        
        # Reset counters
        self.files_processed = 0
        self.total_files = 0
        self.stop_event.clear()
        
        try:
            # Estimate total files
            self._report_progress("counting", current_path=top_level_path)
            self.total_files = self._count_files(top_level_path, exclude_dirs, exclude_patterns)
            self._report_progress("starting", storage_device_id=storage_device.id)
            
            # Use a thread pool to process files
            self.threads = []
            for _ in range(threads):
                thread = threading.Thread(target=self._worker, daemon=True)
                thread.start()
                self.threads.append(thread)
            
            # Enqueue all files
            for file_path in walk_directory(top_level_path, exclude_dirs, exclude_patterns):
                if self.stop_event.is_set():
                    break
                
                self.queue.put((file_path, storage_device.id))
            
            # Add sentinel values to signal worker threads to exit
            for _ in range(threads):
                self.queue.put(None)
            
            # Wait for all threads to finish
            for thread in self.threads:
                thread.join()
            
            # Update scan completion
            if self.stop_event.is_set():
                self.current_scan.status = "aborted"
            else:
                self.current_scan.status = "completed"
            
            self.current_scan.end_time = datetime.now(timezone.utc)
            self.current_scan.files_scanned = self.files_processed
            self.db.update_scan(self.current_scan)
            
            self._report_progress("completed", current_path=None)
            
            return self.current_scan.id
        
        except Exception as e:
            error_message = f"Scan failed: {str(e)}"
            print(error_message)
            
            # Update scan with error
            if self.current_scan:
                self.current_scan.status = "failed"
                self.current_scan.end_time = datetime.now(timezone.utc)
                self.current_scan.error_message = error_message
                self.db.update_scan(self.current_scan)
            
            self._report_progress("failed", error=error_message)
            
            raise ScannerError(error_message) from e
    
    def stop(self) -> None:
        """
        Stop the current scan.
        """
        self.stop_event.set()
    
    def _count_files(self, path: str, exclude_dirs: List[str], exclude_patterns: List[str]) -> int:
        """
        Count the number of files to be processed.
        
        Args:
            path: Directory path to count
            exclude_dirs: List of directory names to exclude
            exclude_patterns: List of glob patterns to exclude
        
        Returns:
            int: Number of files
        """
        count = 0
        for _ in walk_directory(path, exclude_dirs, exclude_patterns):
            count += 1
        return count
    
    def _worker(self) -> None:
        """
        Worker thread function to process files.
        """
        while not self.stop_event.is_set():
            # Get a file from the queue
            item = self.queue.get()
            if item is None:  # Sentinel value
                self.queue.task_done()
                break
            
            file_path, storage_device_id = item
            
            try:
                if self.stop_event.is_set():
                    self.queue.task_done()
                    break
                
                self._process_file(file_path, storage_device_id)
                
                self.files_processed += 1
                if self.files_processed % 10 == 0:  # Report progress every 10 files
                    self._report_progress("scanning", current_path=file_path)

            except Exception as e:
                print(f"Error processing file {file_path}: {str(e)}")

                # Record the error
                error = ScanError(
                    scan_id=self.current_scan.id,
                    file_path=file_path,
                    error_type="processing_error",
                    error_message=str(e)
                )
                self.db.add_scan_error(error)

            finally:
                self.queue.task_done()

    def _process_file(self, file_path: str, storage_device_id: int) -> None:
        """
        Process a single file.

        Args:
            file_path: Path to the file
            storage_device_id: ID of the storage device
        """
        # Get file metadata
        metadata = get_file_metadata(file_path)
        if not metadata["is_file"]:
            return  # Skip directories, symlinks, etc.

        # Split path components
        directory, filename, path = split_path_components(file_path)

        # Check if file exists in database
        db_file = self.db.get_file(path=path, storage_device_id=storage_device_id)

        if not db_file:
            # New file, add to database
            db_file = File(
                path=path,
                filename=filename,
                directory=directory,
                storage_device_id=storage_device_id,
                size=metadata["size"],
                last_modified=metadata["last_modified"],
                file_type=metadata["file_type"]
            )
            db_file.id = self.db.add_file(db_file)
            file_status = "new"
            prev_checksum_id = None
        else:
            # Update existing file
            db_file.last_seen = datetime.now(timezone.utc)
            db_file.size = metadata["size"]
            db_file.last_modified = metadata["last_modified"]
            db_file.is_deleted = False
            self.db.update_file(db_file)

            # Get previous checksum to compare
            prev_checksums = self.db.get_file_checksums(db_file.id, limit=1)
            prev_checksum = prev_checksums[0] if prev_checksums else None
            prev_checksum_id = prev_checksum.id if prev_checksum else None

            # Initially mark as unchanged, will update after checksum calculation
            file_status = "unchanged"

        # Calculate checksum
        checksum_value = self.checksum_calculator.calculate_file_checksum(file_path)
        if not checksum_value:
            # Record error if checksum calculation failed
            error = ScanError(
                scan_id=self.current_scan.id,
                file_path=file_path,
                error_type="checksum_error",
                error_message="Failed to calculate checksum"
            )
            self.db.add_scan_error(error)
            return

        # Create checksum record
        checksum = Checksum(
            file_id=db_file.id,
            scan_id=self.current_scan.id,
            checksum_value=checksum_value,
            checksum_method=self.current_scan.checksum_method,
            status=file_status,
            previous_checksum_id=prev_checksum_id
        )

        # Check for changes if this is an existing file
        if file_status == "unchanged" and prev_checksum:
            if checksum_value != prev_checksum.checksum_value:
                # Check if modification or corruption
                if db_file.last_modified != prev_checksum.timestamp:
                    # File was modified
                    checksum.status = "modified"
                    self.current_scan.files_modified += 1
                else:
                    # File was likely corrupted
                    checksum.status = "corrupted"
                    self.current_scan.files_corrupted += 1
            else:
                # File is unchanged
                self.current_scan.files_unchanged += 1
        elif file_status == "new":
            # Count new files
            self.current_scan.files_new += 1

        # Add checksum to database
        checksum.id = self.db.add_checksum(checksum)

        # Update scan statistics
        self.db.update_scan(self.current_scan)

    def find_missing_files(self, top_level_path: str, storage_device_id: int) -> List[File]:
        """
        Find files that are in the database but no longer exist on disk.

        Args:
            top_level_path: Top-level directory path
            storage_device_id: ID of the storage device

        Returns:
            List[File]: List of missing files
        """
        # Get all files for this path and storage device
        query = """
            SELECT * FROM files
            WHERE directory LIKE ? AND storage_device_id = ? AND is_deleted = 0
        """
        params = (f"{top_level_path}%", storage_device_id)

        with self.db.lock:
            conn = self.db.get_connection()
            try:
                cursor = conn.cursor()
                cursor.execute(query, params)

                # Check each file's existence
                missing_files = []
                for row in cursor.fetchall():
                    db_file = File(**dict(row))
                    if not os.path.exists(db_file.path):
                        db_file.is_deleted = True
                        self.db.update_file(db_file)
                        missing_files.append(db_file)

                return missing_files
            finally:
                conn.close()

    def update_missing_files_status(self, scan_id: int, missing_files: List[File]) -> int:
        """
        Update the status of missing files in a scan.

        Args:
            scan_id: ID of the scan
            missing_files: List of missing files

        Returns:
            int: Number of missing files
        """
        if not missing_files:
            return 0

        # Create checksums for missing files
        for file in missing_files:
            # Create a 'missing' checksum
            checksum = Checksum(
                file_id=file.id,
                scan_id=scan_id,
                checksum_value="",  # Empty for missing files
                checksum_method=self.current_scan.checksum_method,
                status="missing"
            )
            self.db.add_checksum(checksum)

        # Update scan statistics
        if self.current_scan and self.current_scan.id == scan_id:
            self.current_scan.files_missing = len(missing_files)
            self.db.update_scan(self.current_scan)

        return len(missing_files)

    def get_scan_summary(self, scan_id: int) -> Dict[str, Any]:
        """
        Get a summary of scan results.

        Args:
            scan_id: ID of the scan

        Returns:
            Dict: Summary of scan results
        """
        scan = self.db.get_scan(scan_id)
        if not scan:
            return {"error": "Scan not found"}

        # Get counts by status
        query = """
            SELECT status, COUNT(*) as count
            FROM checksums
            WHERE scan_id = ?
            GROUP BY status
        """
        params = (scan_id,)

        with self.db.lock:
            conn = self.db.get_connection()
            try:
                cursor = conn.cursor()
                cursor.execute(query, params)

                status_counts = {}
                for row in cursor.fetchall():
                    status_counts[row['status']] = row['count']

                # Get storage device information
                storage_query = """
                    SELECT sd.id, sd.name, sd.mount_point, sd.device_type,
                           COUNT(DISTINCT f.id) as file_count
                    FROM storage_devices sd
                    JOIN files f ON sd.id = f.storage_device_id
                    JOIN checksums c ON f.id = c.file_id
                    WHERE c.scan_id = ?
                    GROUP BY sd.id
                """
                cursor.execute(storage_query, params)
                storage_devices = [dict(row) for row in cursor.fetchall()]

                # Get error count
                error_query = "SELECT COUNT(*) as count FROM scan_errors WHERE scan_id = ?"
                cursor.execute(error_query, params)
                error_count = cursor.fetchone()['count']

                return {
                    "scan_id": scan.id,
                    "name": scan.name,
                    "top_level_path": scan.top_level_path,
                    "start_time": scan.start_time,
                    "end_time": scan.end_time,
                    "status": scan.status,
                    "files_scanned": scan.files_scanned,
                    "files_unchanged": scan.files_unchanged,
                    "files_modified": scan.files_modified,
                    "files_corrupted": scan.files_corrupted,
                    "files_missing": scan.files_missing,
                    "files_new": scan.files_new,
                    "status_counts": status_counts,
                    "storage_devices": storage_devices,
                    "error_count": error_count,
                    "checksum_method": scan.checksum_method
                }
            finally:
                conn.close()

</code>

utils/__init__.py:
<code>

</code>

db/schema.py:
<code>
"""
SQLite database schema for Bitarr.
"""
import sqlite3
from pathlib import Path
import os

# SQL for enabling foreign keys
PRAGMA_FOREIGN_KEYS = "PRAGMA foreign_keys = ON;"

# SQL for enabling WAL mode for better concurrency
PRAGMA_JOURNAL_MODE = "PRAGMA journal_mode = WAL;"

# Table creation SQL statements
CREATE_STORAGE_DEVICES_TABLE = """
CREATE TABLE IF NOT EXISTS storage_devices (
    id           INTEGER PRIMARY KEY AUTOINCREMENT,
    name         TEXT NOT NULL,
    mount_point  TEXT NOT NULL,
    device_type  TEXT,
    total_size   INTEGER,
    used_size    INTEGER,
    first_seen   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_seen    TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    is_connected BOOLEAN NOT NULL DEFAULT 1,
    device_id    TEXT,
    UNIQUE (device_id)
);
"""

CREATE_FILES_TABLE = """
CREATE TABLE IF NOT EXISTS files (
    id                INTEGER PRIMARY KEY AUTOINCREMENT,
    path              TEXT NOT NULL,
    filename          TEXT NOT NULL,
    directory         TEXT NOT NULL,
    storage_device_id INTEGER NOT NULL,
    size              INTEGER,
    last_modified     TIMESTAMP,
    file_type         TEXT,
    first_seen        TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_seen         TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    is_deleted        BOOLEAN NOT NULL DEFAULT 0,
    FOREIGN KEY (storage_device_id) REFERENCES storage_devices(id),
    UNIQUE (path, storage_device_id)
);
"""

CREATE_SCHEDULED_SCANS_TABLE = """
CREATE TABLE IF NOT EXISTS scheduled_scans (
    id           INTEGER PRIMARY KEY AUTOINCREMENT,
    name         TEXT NOT NULL,
    paths        TEXT NOT NULL,
    frequency    TEXT NOT NULL,
    parameters   TEXT NOT NULL,
    last_run     TIMESTAMP,
    next_run     TIMESTAMP,
    status       TEXT NOT NULL DEFAULT 'active',
    priority     INTEGER NOT NULL DEFAULT 0,
    max_runtime  INTEGER,
    is_active    BOOLEAN NOT NULL DEFAULT 1,
    created_at   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
"""

CREATE_SCANS_TABLE = """
CREATE TABLE IF NOT EXISTS scans (
    id                INTEGER PRIMARY KEY AUTOINCREMENT,
    name              TEXT,
    top_level_path    TEXT NOT NULL,
    start_time        TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    end_time          TIMESTAMP,
    status            TEXT NOT NULL,
    files_scanned     INTEGER DEFAULT 0,
    files_unchanged   INTEGER DEFAULT 0,
    files_modified    INTEGER DEFAULT 0,
    files_corrupted   INTEGER DEFAULT 0,
    files_missing     INTEGER DEFAULT 0,
    files_new         INTEGER DEFAULT 0,
    checksum_method   TEXT NOT NULL,
    scheduled_scan_id INTEGER,
    error_message     TEXT,
    notes             TEXT,
    FOREIGN KEY (scheduled_scan_id) REFERENCES scheduled_scans(id)
);
"""

CREATE_CHECKSUMS_TABLE = """
CREATE TABLE IF NOT EXISTS checksums (
    id               INTEGER PRIMARY KEY AUTOINCREMENT,
    file_id          INTEGER NOT NULL,
    scan_id          INTEGER NOT NULL,
    checksum_value   TEXT NOT NULL,
    checksum_method  TEXT NOT NULL,
    timestamp        TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    status           TEXT NOT NULL,
    previous_checksum_id INTEGER,
    FOREIGN KEY (file_id) REFERENCES files(id),
    FOREIGN KEY (scan_id) REFERENCES scans(id),
    FOREIGN KEY (previous_checksum_id) REFERENCES checksums(id),
    UNIQUE (file_id, scan_id)
);
"""

CREATE_SCAN_ERRORS_TABLE = """
CREATE TABLE IF NOT EXISTS scan_errors (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    scan_id     INTEGER NOT NULL,
    file_path   TEXT,
    error_type  TEXT NOT NULL,
    error_message TEXT,
    timestamp   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (scan_id) REFERENCES scans(id)
);
"""

CREATE_CONFIGURATION_TABLE = """
CREATE TABLE IF NOT EXISTS configuration (
    key         TEXT PRIMARY KEY,
    value       TEXT NOT NULL,
    type        TEXT NOT NULL,
    description TEXT,
    updated_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
"""

# Create indexes
CREATE_INDEXES = [
    "CREATE INDEX IF NOT EXISTS idx_files_path ON files(path);",
    "CREATE INDEX IF NOT EXISTS idx_files_storage_device ON files(storage_device_id);",
    "CREATE INDEX IF NOT EXISTS idx_files_directory ON files(directory);",
    "CREATE INDEX IF NOT EXISTS idx_files_is_deleted ON files(is_deleted);",
    
    "CREATE INDEX IF NOT EXISTS idx_checksums_file_id ON checksums(file_id);",
    "CREATE INDEX IF NOT EXISTS idx_checksums_scan_id ON checksums(scan_id);",
    "CREATE INDEX IF NOT EXISTS idx_checksums_status ON checksums(status);",
    "CREATE INDEX IF NOT EXISTS idx_checksums_previous ON checksums(previous_checksum_id);",
    
    "CREATE INDEX IF NOT EXISTS idx_scans_path ON scans(top_level_path);",
    "CREATE INDEX IF NOT EXISTS idx_scans_time ON scans(start_time);",
    "CREATE INDEX IF NOT EXISTS idx_scans_status ON scans(status);",
    "CREATE INDEX IF NOT EXISTS idx_scans_scheduled ON scans(scheduled_scan_id);",
    
    "CREATE INDEX IF NOT EXISTS idx_storage_devices_mount ON storage_devices(mount_point);",
    "CREATE INDEX IF NOT EXISTS idx_storage_devices_connected ON storage_devices(is_connected);",
    
    "CREATE INDEX IF NOT EXISTS idx_scheduled_scans_active ON scheduled_scans(is_active);",
    "CREATE INDEX IF NOT EXISTS idx_scheduled_scans_next_run ON scheduled_scans(next_run);",
    
    "CREATE INDEX IF NOT EXISTS idx_scan_errors_scan ON scan_errors(scan_id);"
]

# Default configuration values
DEFAULT_CONFIG = [
    (
        'web_ui_port', '8286', 'integer', 
        'Port for the web interface'
    ),
    (
        'scan_threads', '4', 'integer', 
        'Number of threads to use for scanning'
    ),
    (
        'checksum_method', 'sha256', 'string', 
        'Default checksum method'
    ),
    (
        'checksum_block_size', '4', 'integer', 
        'Size of blocks read when calculating checksums (MB)'
    ),
    (
        'db_auto_vacuum', '1', 'integer', 
        'Enable auto-vacuum (0=none, 1=full, 2=incremental)'
    ),
    (
        'db_auto_backup', '1', 'boolean', 
        'Enable automatic database backups'
    ),
    (
        'db_backup_frequency', 'weekly', 'string', 
        'How often to perform database backups'
    ),
    (
        'db_backup_retain', '10', 'integer', 
        'Number of backup copies to retain'
    ),
    (
        'schema_version', '1', 'integer', 
        'Database schema version'
    )
]

def get_default_db_path():
    """Get the default database file path."""
    # Get the user's home directory
    home_dir = Path.home()
    app_dir = home_dir / ".bitarr"
    
    # Create the directory if it doesn't exist
    os.makedirs(app_dir, exist_ok=True)
    
    return app_dir / "bitarr.db"

</code>

db/db_manager.py:
<code>
"""
Database manager for Bitarr.
"""
import os
import shutil
import tempfile
import time
from datetime import datetime, timezone, timedelta
from pathlib import Path
import sqlite3
import json
import threading
from typing import List, Dict, Any, Optional, Union, Tuple
from .models import (
    StorageDevice, File, Scan, Checksum, 
    ScheduledScan, ScanError, Configuration
)
from .schema import get_default_db_path

class DatabaseManager:
    """
    Manager for database operations.
    
    This class provides methods to interact with the SQLite database,
    handling connections, transactions, and CRUD operations for all entities.
    """
    
    def __init__(self, db_path=None):
        """
        Initialize the database manager.
        
        Args:
            db_path: Path to the database file. If None, uses the default path.
        """
        self.db_path = db_path or get_default_db_path()
        self.lock = threading.RLock()  # Reentrant lock for thread safety
    
    def get_connection(self):
        """
        Get a connection to the database.
        
        Returns:
            sqlite3.Connection: A connection to the database.
        """
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row  # Enable dictionary-like access to rows
        conn.execute("PRAGMA foreign_keys = ON;")  # Enable foreign key constraints
        return conn
    
    def execute_query(self, query, params=None, commit=True):
        """
        Execute a SQL query.
        
        Args:
            query: SQL query to execute.
            params: Parameters for the query.
            commit: Whether to commit the transaction.
            
        Returns:
            cursor: SQLite cursor after execution.
        """
        with self.lock:
            conn = self.get_connection()
            try:
                cursor = conn.cursor()
                if params:
                    cursor.execute(query, params)
                else:
                    cursor.execute(query)
                
                if commit:
                    conn.commit()
                
                return cursor
            finally:
                conn.close()
    
    def execute_many(self, query, params_list, commit=True):
        """
        Execute a SQL query with multiple parameter sets.
        
        Args:
            query: SQL query to execute.
            params_list: List of parameter sets.
            commit: Whether to commit the transaction.
            
        Returns:
            cursor: SQLite cursor after execution.
        """
        with self.lock:
            conn = self.get_connection()
            try:
                cursor = conn.cursor()
                cursor.executemany(query, params_list)
                
                if commit:
                    conn.commit()
                
                return cursor
            finally:
                conn.close()
    
    def fetch_one(self, query, params=None):
        """
        Fetch a single row from the database.
        
        Args:
            query: SQL query to execute.
            params: Parameters for the query.
            
        Returns:
            row: The first row returned by the query, or None.
        """
        with self.lock:
            conn = self.get_connection()
            try:
                cursor = conn.cursor()
                if params:
                    cursor.execute(query, params)
                else:
                    cursor.execute(query)
                
                row = cursor.fetchone()
                return dict(row) if row else None
            finally:
                conn.close()
    
    def fetch_all(self, query, params=None):
        """
        Fetch all rows from the database.
        
        Args:
            query: SQL query to execute.
            params: Parameters for the query.
            
        Returns:
            rows: List of rows returned by the query.
        """
        with self.lock:
            conn = self.get_connection()
            try:
                cursor = conn.cursor()
                if params:
                    cursor.execute(query, params)
                else:
                    cursor.execute(query)
                
                rows = cursor.fetchall()
                return [dict(row) for row in rows]
            finally:
                conn.close()
    
    # ===== Storage Devices =====
    
    def get_storage_device(self, device_id=None, mount_point=None, id=None):
        """
        Get a storage device by ID, device_id, or mount point.
        
        Args:
            device_id: System device ID.
            mount_point: Mount point path.
            id: Database ID.
            
        Returns:
            StorageDevice: The storage device, or None if not found.
        """
        if id is not None:
            query = "SELECT * FROM storage_devices WHERE id = ?"
            params = (id,)
        elif device_id is not None:
            query = "SELECT * FROM storage_devices WHERE device_id = ?"
            params = (device_id,)
        elif mount_point is not None:
            query = "SELECT * FROM storage_devices WHERE mount_point = ?"
            params = (mount_point,)
        else:
            return None
        
        row = self.fetch_one(query, params)
        if row:
            return StorageDevice(**row)
        return None
    
    def get_all_storage_devices(self, connected_only=False):
        """
        Get all storage devices.
        
        Args:
            connected_only: Whether to only return connected devices.
            
        Returns:
            List[StorageDevice]: List of storage devices.
        """
        if connected_only:
            query = "SELECT * FROM storage_devices WHERE is_connected = 1"
        else:
            query = "SELECT * FROM storage_devices"
        
        rows = self.fetch_all(query)
        return [StorageDevice(**row) for row in rows]
    
    def add_storage_device(self, device):
        """
        Add a storage device to the database.
        
        Args:
            device: StorageDevice object to add.
            
        Returns:
            int: ID of the added storage device.
        """
        query = """
            INSERT INTO storage_devices (
                name, mount_point, device_type, total_size, 
                used_size, first_seen, last_seen, is_connected, device_id
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        params = (
            device.name, device.mount_point, device.device_type, 
            device.total_size, device.used_size, device.first_seen,
            device.last_seen, device.is_connected, device.device_id
        )
        
        cursor = self.execute_query(query, params)
        return cursor.lastrowid
    
    def update_storage_device(self, device):
        """
        Update a storage device in the database.
        
        Args:
            device: StorageDevice object to update.
            
        Returns:
            bool: Whether the update was successful.
        """
        query = """
            UPDATE storage_devices SET
                name = ?, mount_point = ?, device_type = ?,
                total_size = ?, used_size = ?, last_seen = ?,
                is_connected = ?, device_id = ?
            WHERE id = ?
        """
        params = (
            device.name, device.mount_point, device.device_type,
            device.total_size, device.used_size, device.last_seen,
            device.is_connected, device.device_id, device.id
        )
        
        cursor = self.execute_query(query, params)
        return cursor.rowcount > 0
    
    def delete_storage_device(self, device_id):
        """
        Delete a storage device from the database.
        
        Args:
            device_id: ID of the storage device to delete.
            
        Returns:
            bool: Whether the deletion was successful.
        """
        query = "DELETE FROM storage_devices WHERE id = ?"
        params = (device_id,)
        
        cursor = self.execute_query(query, params)
        return cursor.rowcount > 0
    
    # ===== Files =====
    
    def get_file(self, id=None, path=None, storage_device_id=None):
        """
        Get a file by ID or path and storage device.
        
        Args:
            id: Database ID.
            path: File path.
            storage_device_id: ID of the storage device.
            
        Returns:
            File: The file, or None if not found.
        """
        if id is not None:
            query = "SELECT * FROM files WHERE id = ?"
            params = (id,)
        elif path is not None and storage_device_id is not None:
            query = "SELECT * FROM files WHERE path = ? AND storage_device_id = ?"
            params = (path, storage_device_id)
        else:
            return None
        
        row = self.fetch_one(query, params)
        if row:
            return File(**row)
        return None
    
    def get_files_by_directory(self, directory, storage_device_id=None, include_deleted=False):
        """
        Get files in a directory.
        
        Args:
            directory: Directory path.
            storage_device_id: ID of the storage device.
            include_deleted: Whether to include deleted files.
            
        Returns:
            List[File]: List of files.
        """
        params = [directory]
        if storage_device_id is not None:
            query = "SELECT * FROM files WHERE directory = ? AND storage_device_id = ?"
            params.append(storage_device_id)
        else:
            query = "SELECT * FROM files WHERE directory = ?"
        
        if not include_deleted:
            query += " AND is_deleted = 0"
        
        rows = self.fetch_all(query, tuple(params))
        return [File(**row) for row in rows]
    
    def add_file(self, file):
        """
        Add a file to the database.
        
        Args:
            file: File object to add.
            
        Returns:
            int: ID of the added file.
        """
        query = """
            INSERT INTO files (
                path, filename, directory, storage_device_id,
                size, last_modified, file_type, first_seen, 
                last_seen, is_deleted
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        params = (
            file.path, file.filename, file.directory, file.storage_device_id,
            file.size, file.last_modified, file.file_type, file.first_seen,
            file.last_seen, file.is_deleted
        )
        
        cursor = self.execute_query(query, params)
        return cursor.lastrowid
    
    def update_file(self, file):
        """
        Update a file in the database.
        
        Args:
            file: File object to update.
            
        Returns:
            bool: Whether the update was successful.
        """
        query = """
            UPDATE files SET
                path = ?, filename = ?, directory = ?, storage_device_id = ?,
                size = ?, last_modified = ?, file_type = ?, last_seen = ?,
                is_deleted = ?
            WHERE id = ?
        """
        params = (
            file.path, file.filename, file.directory, file.storage_device_id,
            file.size, file.last_modified, file.file_type, file.last_seen,
            file.is_deleted, file.id
        )
        
        cursor = self.execute_query(query, params)
        return cursor.rowcount > 0
    
    def mark_files_as_deleted(self, file_ids):
        """
        Mark files as deleted.
        
        Args:
            file_ids: List of file IDs to mark as deleted.
            
        Returns:
            int: Number of files marked as deleted.
        """
        if not file_ids:
            return 0
        
        placeholders = ", ".join(["?"] * len(file_ids))
        query = f"UPDATE files SET is_deleted = 1 WHERE id IN ({placeholders})"
        
        cursor = self.execute_query(query, file_ids)
        return cursor.rowcount
    
    # ===== Scans =====
    
    def get_scan(self, id):
        """
        Get a scan by ID.
        
        Args:
            id: Database ID.
            
        Returns:
            Scan: The scan, or None if not found.
        """
        query = "SELECT * FROM scans WHERE id = ?"
        params = (id,)
        
        row = self.fetch_one(query, params)
        if row:
            return Scan(**row)
        return None
    
    def get_scans_by_path(self, path, limit=10):
        """
        Get scans for a specific path.
        
        Args:
            path: Top-level path.
            limit: Maximum number of scans to return.
            
        Returns:
            List[Scan]: List of scans.
        """
        query = """
            SELECT * FROM scans 
            WHERE top_level_path = ? 
            ORDER BY start_time DESC 
            LIMIT ?
        """
        params = (path, limit)
        
        rows = self.fetch_all(query, params)
        return [Scan(**row) for row in rows]
    
    def get_recent_scansx(self, limit=10):
        """
        Get recent scans.
        
        Args:
            limit: Maximum number of scans to return.
            
        Returns:
            List[Scan]: List of scans.
        """
        query = """
            SELECT * FROM scans 
            ORDER BY start_time DESC 
            LIMIT ?
        """
        params = (limit,)
        
        rows = self.fetch_all(query, params)
        return [Scan(**row) for row in rows]

    def get_recent_scans(self, limit=10, offset=0):
        """
        Get recent scans with pagination.

        Args:
            limit: Maximum number of scans to return.
            offset: Number of scans to skip (for pagination).

        Returns:
            List[Scan]: List of scans.
        """
        query = """
            SELECT * FROM scans
            ORDER BY start_time DESC
            LIMIT ? OFFSET ?
        """
        params = (limit, offset)

        rows = self.fetch_all(query, params)
        return [Scan(**row) for row in rows]

    
    def add_scan(self, scan):
        """
        Add a scan to the database.
        
        Args:
            scan: Scan object to add.
            
        Returns:
            int: ID of the added scan.
        """
        query = """
            INSERT INTO scans (
                name, top_level_path, start_time, end_time, status,
                files_scanned, files_unchanged, files_modified,
                files_corrupted, files_missing, files_new,
                checksum_method, scheduled_scan_id, error_message, notes
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        params = (
            scan.name, scan.top_level_path, scan.start_time, scan.end_time, scan.status,
            scan.files_scanned, scan.files_unchanged, scan.files_modified,
            scan.files_corrupted, scan.files_missing, scan.files_new,
            scan.checksum_method, scan.scheduled_scan_id, scan.error_message, scan.notes
        )
        
        cursor = self.execute_query(query, params)
        return cursor.lastrowid
    
    def update_scan(self, scan):
        """
        Update a scan in the database.
        
        Args:
            scan: Scan object to update.
            
        Returns:
            bool: Whether the update was successful.
        """
        query = """
            UPDATE scans SET
                name = ?, top_level_path = ?, end_time = ?, status = ?,
                files_scanned = ?, files_unchanged = ?, files_modified = ?,
                files_corrupted = ?, files_missing = ?, files_new = ?,
                error_message = ?, notes = ?
            WHERE id = ?
        """
        params = (
            scan.name, scan.top_level_path, scan.end_time, scan.status,
            scan.files_scanned, scan.files_unchanged, scan.files_modified,
            scan.files_corrupted, scan.files_missing, scan.files_new,
            scan.error_message, scan.notes, scan.id
        )
        
        cursor = self.execute_query(query, params)
        return cursor.rowcount > 0
    
    def delete_scan(self, scan_id):
        """
        Delete a scan from the database.
        
        Args:
            scan_id: ID of the scan to delete.
            
        Returns:
            bool: Whether the deletion was successful.
        """
        # This will cascade and delete associated checksums and scan errors
        query = "DELETE FROM scans WHERE id = ?"
        params = (scan_id,)
        
        cursor = self.execute_query(query, params)
        return cursor.rowcount > 0
    
    # ===== Checksums =====
    
    def get_checksum(self, id):
        """
        Get a checksum by ID.
        
        Args:
            id: Database ID.
            
        Returns:
            Checksum: The checksum, or None if not found.
        """
        query = "SELECT * FROM checksums WHERE id = ?"
        params = (id,)
        
        row = self.fetch_one(query, params)
        if row:
            return Checksum(**row)
        return None
    
    def get_file_checksums(self, file_id, limit=10):
        """
        Get checksums for a file.
        
        Args:
            file_id: ID of the file.
            limit: Maximum number of checksums to return.
            
        Returns:
            List[Checksum]: List of checksums.
        """
        query = """
            SELECT * FROM checksums 
            WHERE file_id = ? 
            ORDER BY timestamp DESC 
            LIMIT ?
        """
        params = (file_id, limit)
        
        rows = self.fetch_all(query, params)
        return [Checksum(**row) for row in rows]
    
    def get_scan_checksums(self, scan_id, status=None, limit=100, offset=0):
        """
        Get checksums for a scan.
        
        Args:
            scan_id: ID of the scan.
            status: Filter by status.
            limit: Maximum number of checksums to return.
            offset: Offset for pagination.
            
        Returns:
            List[Checksum]: List of checksums.
        """
        if status:
            query = """
                SELECT * FROM checksums 
                WHERE scan_id = ? AND status = ?
                ORDER BY id 
                LIMIT ? OFFSET ?
            """
            params = (scan_id, status, limit, offset)
        else:
            query = """
                SELECT * FROM checksums 
                WHERE scan_id = ? 
                ORDER BY id 
                LIMIT ? OFFSET ?
            """
            params = (scan_id, limit, offset)
        
        rows = self.fetch_all(query, params)
        return [Checksum(**row) for row in rows]
    
    def add_checksum(self, checksum):
        """
        Add a checksum to the database.
        
        Args:
            checksum: Checksum object to add.
            
        Returns:
            int: ID of the added checksum.
        """
        query = """
            INSERT INTO checksums (
                file_id, scan_id, checksum_value, checksum_method,
                timestamp, status, previous_checksum_id
            ) VALUES (?, ?, ?, ?, ?, ?, ?)
        """
        params = (
            checksum.file_id, checksum.scan_id, checksum.checksum_value,
            checksum.checksum_method, checksum.timestamp, checksum.status,
            checksum.previous_checksum_id
        )
        
        cursor = self.execute_query(query, params)
        return cursor.lastrowid
    
    def update_checksum_status(self, checksum_id, status):
        """
        Update the status of a checksum.
        
        Args:
            checksum_id: ID of the checksum.
            status: New status.
            
        Returns:
            bool: Whether the update was successful.
        """
        query = "UPDATE checksums SET status = ? WHERE id = ?"
        params = (status, checksum_id)
        
        cursor = self.execute_query(query, params)
        return cursor.rowcount > 0
    
    # ===== Scheduled Scans =====
    
    def get_scheduled_scan(self, id):
        """
        Get a scheduled scan by ID.
        
        Args:
            id: Database ID.
            
        Returns:
            ScheduledScan: The scheduled scan, or None if not found.
        """
        query = "SELECT * FROM scheduled_scans WHERE id = ?"
        params = (id,)
        
        row = self.fetch_one(query, params)
        if row:
            return ScheduledScan(**row)
        return None
    
    def get_active_scheduled_scans(self):
        """
        Get all active scheduled scans.
        
        Returns:
            List[ScheduledScan]: List of scheduled scans.
        """
        query = "SELECT * FROM scheduled_scans WHERE is_active = 1"
        
        rows = self.fetch_all(query)
        return [ScheduledScan(**row) for row in rows]
    
    def get_all_scheduled_scans(self):
        """
        Get all scheduled scans.
        
        Returns:
            List[ScheduledScan]: List of scheduled scans.
        """
        query = "SELECT * FROM scheduled_scans ORDER BY name"
        
        rows = self.fetch_all(query)
        return [ScheduledScan(**row) for row in rows]
    
    def get_due_scheduled_scans(self, current_time=None):
        """
        Get scheduled scans that are due to run.
        
        Args:
            current_time: Current time.
            
        Returns:
            List[ScheduledScan]: List of scheduled scans.
        """
        if current_time is None:
            current_time = datetime.now(timezone.utc)
        
        query = """
            SELECT * FROM scheduled_scans 
            WHERE is_active = 1 
            AND status = 'active' 
            AND next_run <= ?
            ORDER BY priority DESC
        """
        params = (current_time,)
        
        rows = self.fetch_all(query, params)
        return [ScheduledScan(**row) for row in rows]
    
    def add_scheduled_scan(self, scheduled_scan):
        """
        Add a scheduled scan to the database.
        
        Args:
            scheduled_scan: ScheduledScan object to add.
            
        Returns:
            int: ID of the added scheduled scan.
        """
        query = """
            INSERT INTO scheduled_scans (
                name, paths, frequency, parameters, last_run,
                next_run, status, priority, max_runtime, is_active
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        params = (
            scheduled_scan.name, scheduled_scan.paths, scheduled_scan.frequency,
            scheduled_scan.parameters, scheduled_scan.last_run, scheduled_scan.next_run,
            scheduled_scan.status, scheduled_scan.priority, scheduled_scan.max_runtime,
            scheduled_scan.is_active
        )
        
        cursor = self.execute_query(query, params)
        return cursor.lastrowid
    
    def update_scheduled_scan(self, scheduled_scan):
        """
        Update a scheduled scan in the database.
        
        Args:
            scheduled_scan: ScheduledScan object to update.
            
        Returns:
            bool: Whether the update was successful.
        """
        query = """
            UPDATE scheduled_scans SET
                name = ?, paths = ?, frequency = ?, parameters = ?,
                last_run = ?, next_run = ?, status = ?, priority = ?,
                max_runtime = ?, is_active = ?
            WHERE id = ?
        """
        params = (
            scheduled_scan.name, scheduled_scan.paths, scheduled_scan.frequency,
            scheduled_scan.parameters, scheduled_scan.last_run, scheduled_scan.next_run,
            scheduled_scan.status, scheduled_scan.priority, scheduled_scan.max_runtime,
            scheduled_scan.is_active, scheduled_scan.id
        )
        
        cursor = self.execute_query(query, params)
        return cursor.rowcount > 0
    
    def delete_scheduled_scan(self, scheduled_scan_id):
        """
        Delete a scheduled scan from the database.
        
        Args:
            scheduled_scan_id: ID of the scheduled scan to delete.
            
        Returns:
            bool: Whether the deletion was successful.
        """
        query = "DELETE FROM scheduled_scans WHERE id = ?"
        params = (scheduled_scan_id,)
        
        cursor = self.execute_query(query, params)
        return cursor.rowcount > 0
    
    # ===== Scan Errors =====
    
    def add_scan_error(self, scan_error):
        """
        Add a scan error to the database.
        
        Args:
            scan_error: ScanError object to add.
            
        Returns:
            int: ID of the added scan error.
        """
        query = """
            INSERT INTO scan_errors (
                scan_id, file_path, error_type, error_message, timestamp
            ) VALUES (?, ?, ?, ?, ?)
        """
        params = (
            scan_error.scan_id, scan_error.file_path, scan_error.error_type,
            scan_error.error_message, scan_error.timestamp
        )
        
        cursor = self.execute_query(query, params)
        return cursor.lastrowid
    
    def get_scan_errors(self, scan_id, limit=100, offset=0):
        """
        Get errors for a scan.
        
        Args:
            scan_id: ID of the scan.
            limit: Maximum number of errors to return.
            offset: Offset for pagination.
            
        Returns:
            List[ScanError]: List of scan errors.
        """
        query = """
            SELECT * FROM scan_errors 
            WHERE scan_id = ? 
            ORDER BY timestamp DESC 
            LIMIT ? OFFSET ?
        """
        params = (scan_id, limit, offset)
        
        rows = self.fetch_all(query, params)
        return [ScanError(**row) for row in rows]
    
    # ===== Configuration =====
    
    def get_configuration(self, key):
        """
        Get a configuration value.
        
        Args:
            key: Configuration key.
            
        Returns:
            Configuration: The configuration, or None if not found.
        """
        query = "SELECT key, value, type AS value_type, description, updated_at FROM configuration WHERE key = ?"
        params = (key,)
        
        row = self.fetch_one(query, params)
        if row:
            return Configuration(**row)
        return None
    
    def get_all_configuration(self):
        """
        Get all configuration values.
        
        Returns:
            dict: Dictionary of configuration values.
        """
        query = "SELECT key, value, type AS value_type, description, updated_at FROM configuration"
        
        rows = self.fetch_all(query)
        config_dict = {}
        for row in rows:
            config = Configuration(**row)
            config_dict[config.key] = config.get_typed_value()
        
        return config_dict
    
    def set_configuration(self, key, value, value_type=None, description=None):
        """
        Set a configuration value.
        
        Args:
            key: Configuration key.
            value: Configuration value.
            value_type: Value type.
            description: Configuration description.
            
        Returns:
            bool: Whether the operation was successful.
        """
        # Get existing configuration to determine type if not provided
        if value_type is None or description is None:
            existing = self.get_configuration(key)
            if existing:
                value_type = value_type or existing.value_type
                description = description or existing.description
        
        # If value_type is still None, guess from the value
        if value_type is None:
            if isinstance(value, bool):
                value_type = "boolean"
                value = "true" if value else "false"
            elif isinstance(value, int):
                value_type = "integer"
                value = str(value)
            elif isinstance(value, float):
                value_type = "float"
                value = str(value)
            elif isinstance(value, (dict, list)):
                value_type = "json"
                value = json.dumps(value)
            else:
                value_type = "string"
                value = str(value)
        
        # Convert value to string if it's not already
        if not isinstance(value, str):
            if value_type == "json":
                value = json.dumps(value)
            else:
                value = str(value)
        
        # Update or insert
        query = """
            INSERT OR REPLACE INTO configuration 
            (key, value, type, description, updated_at) 
            VALUES (?, ?, ?, ?, ?)
        """
        params = (key, value, value_type, description, datetime.now(timezone.utc))
        
        cursor = self.execute_query(query, params)
        return cursor.rowcount > 0
    
    # ===== Database Maintenance =====
    
    def vacuum(self):
        """
        Run VACUUM to reclaim space.
        
        Returns:
            bool: Whether the operation was successful.
        """
        with self.lock:
            conn = self.get_connection()
            try:
                conn.execute("VACUUM")
                conn.commit()
                return True
            except sqlite3.Error:
                return False
            finally:
                conn.close()
    
    def backup(self, backup_path=None):
        """
        Create a backup of the database.
        
        Args:
            backup_path: Path for the backup file.
            
        Returns:
            str: Path to the backup file.
        """
        if backup_path is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_path = f"{self.db_path}.backup_{timestamp}"
        
        with self.lock:
            source_conn = self.get_connection()
            try:
                dest_conn = sqlite3.connect(backup_path)
                source_conn.backup(dest_conn)
                dest_conn.close()
                return backup_path
            finally:
                source_conn.close()
    
    def get_database_info(self):
        """
        Get information about the database.
        
        Returns:
            dict: Database information.
        """
        result = {}
        
        # Get table counts
        tables = [
            "storage_devices", "files", "scans", "checksums",
            "scheduled_scans", "scan_errors", "configuration"
        ]
        
        for table in tables:
            query = f"SELECT COUNT(*) as count FROM {table}"
            row = self.fetch_one(query)
            result[f"{table}_count"] = row["count"] if row else 0
        
        # Get database size
        try:
            result["database_size"] = Path(self.db_path).stat().st_size
        except OSError:
            result["database_size"] = 0
        
        # Get last scan date
        query = "SELECT MAX(start_time) as last_scan FROM scans"
        row = self.fetch_one(query)
        result["last_scan"] = row["last_scan"] if row and "last_scan" in row else None

        # Get first scan date
        query = "SELECT MIN(start_time) as first_scan FROM scans"
        row = self.fetch_one(query)
        result["first_scan"] = row["first_scan"] if row and "first_scan" in row else None

        return result

    def prune_old_scans(self, days_old):
        """
        Delete scans older than a specified number of days.

        Args:
            days_old: Number of days old.

        Returns:
            int: Number of scans deleted.
        """
        query = """
            DELETE FROM scans
            WHERE start_time < datetime('now', '-' || ? || ' days')
        """
        params = (days_old,)

        cursor = self.execute_query(query, params)
        return cursor.rowcount


    def reset(self):
        """Reset the database, keeping only configuration."""
        # Implementation needed
        return True

    def reset_scan_history(self):
        """
        Delete all scan history while preserving schedules and configuration.

        This deletes all checksums, scan errors, scans, and files, but keeps
        scheduled scans, configuration, and storage device information.

        Returns:
            bool: True if successful, False otherwise
        """
        with self.lock:
            conn = self.get_connection()
            try:
                cursor = conn.cursor()

                # Begin transaction
                cursor.execute("BEGIN TRANSACTION")

                # Count records to be deleted (for reporting)
                cursor.execute("SELECT COUNT(*) FROM checksums")
                checksum_count = cursor.fetchone()[0]

                cursor.execute("SELECT COUNT(*) FROM scan_errors")
                error_count = cursor.fetchone()[0]

                cursor.execute("SELECT COUNT(*) FROM scans")
                scan_count = cursor.fetchone()[0]

                cursor.execute("SELECT COUNT(*) FROM files")
                file_count = cursor.fetchone()[0]

                # Delete all checksums (must be first due to foreign key constraints)
                cursor.execute("DELETE FROM checksums")

                # Delete all scan errors
                cursor.execute("DELETE FROM scan_errors")

                # Delete all scans
                cursor.execute("DELETE FROM scans")

                # Delete all files
                cursor.execute("DELETE FROM files")

                # Commit transaction
                conn.commit()

                return {
                    "success": True,
                    "checksums_deleted": checksum_count,
                    "errors_deleted": error_count,
                    "scans_deleted": scan_count,
                    "files_deleted": file_count
                }
            except sqlite3.Error as e:
                conn.rollback()
                print(f"Error resetting scan history: {str(e)}")
                return {
                    "success": False,
                    "error": str(e)
                }
            finally:
                conn.close()

    def reset_full(self):
        """
        Reset database but keep configuration.

        This performs a scan history reset and additionally deletes all
        scheduled scans and storage devices. Only configuration is preserved.

        Returns:
            dict: Status dictionary with success flag and counts
        """
        # First, reset scan history
        result = self.reset_scan_history()
        if not result["success"]:
            return result

        with self.lock:
            conn = self.get_connection()
            try:
                cursor = conn.cursor()

                # Begin transaction
                cursor.execute("BEGIN TRANSACTION")

                # Count records to be deleted (for reporting)
                cursor.execute("SELECT COUNT(*) FROM scheduled_scans")
                scheduled_scan_count = cursor.fetchone()[0]

                cursor.execute("SELECT COUNT(*) FROM storage_devices")
                device_count = cursor.fetchone()[0]

                # Delete all scheduled scans
                cursor.execute("DELETE FROM scheduled_scans")

                # Delete all storage devices
                cursor.execute("DELETE FROM storage_devices")

                # Commit transaction
                conn.commit()

                # Add the additional deletions to the result
                result.update({
                    "scheduled_scans_deleted": scheduled_scan_count,
                    "devices_deleted": device_count
                })

                return result
            except sqlite3.Error as e:
                conn.rollback()
                print(f"Error performing full reset: {str(e)}")
                return {
                    "success": False,
                    "error": str(e)
                }
            finally:
                conn.close()

    def reset_complete(self):
        """
        Reset everything to default values.

        This completely resets the database, including configuration.
        Only schema and essential default values are preserved.

        Returns:
            dict: Status dictionary with success flag and counts
        """
        # First, backup configuration
        config_backup = {}
        try:
            # Get configuration to backup
            config_backup = self.get_all_configuration()
        except Exception as e:
            print(f"Warning: Could not backup configuration: {str(e)}")

        # Then perform full reset
        result = self.reset_full()
        if not result["success"]:
            return result

        with self.lock:
            conn = self.get_connection()
            try:
                cursor = conn.cursor()

                # Begin transaction
                cursor.execute("BEGIN TRANSACTION")

                # Get count of configuration items
                cursor.execute("SELECT COUNT(*) FROM configuration")
                config_count = cursor.fetchone()[0]

                # Delete all configuration (except schema_version)
                cursor.execute("DELETE FROM configuration WHERE key != 'schema_version'")

                # Re-initialize default configuration
                from .init_db import DEFAULT_CONFIG
                for key, value, type_str, description in DEFAULT_CONFIG:
                    # Skip schema_version as it was preserved
                    if key == 'schema_version':
                        continue

                    cursor.execute(
                        """
                        INSERT OR REPLACE INTO configuration
                        (key, value, type, description, updated_at)
                        VALUES (?, ?, ?, ?, ?)
                        """,
                        (key, value, type_str, description, datetime.now(timezone.utc))
                    )

                # Commit transaction
                conn.commit()

                # Add the additional deletions to the result
                result.update({
                    "configuration_reset": True,
                    "config_items_deleted": config_count
                })

                return result
            except sqlite3.Error as e:
                conn.rollback()
                print(f"Error performing complete reset: {str(e)}")
                return {
                    "success": False,
                    "error": str(e)
                }
            finally:
                conn.close()

    def reindex(self):
        """
        Rebuild all database indexes.

        Returns:
            bool: True if successful, False otherwise
        """
        with self.lock:
            conn = self.get_connection()
            try:
                cursor = conn.cursor()

                # Get a list of all indexes
                cursor.execute("""
                    SELECT name FROM sqlite_master
                    WHERE type = 'index' AND name NOT LIKE 'sqlite_%'
                """)

                indexes = [row[0] for row in cursor.fetchall()]
                reindexed_count = 0

                # Reindex each index
                for index in indexes:
                    cursor.execute(f"REINDEX {index}")
                    reindexed_count += 1

                conn.commit()
                return {
                    "success": True,
                    "indexes_reindexed": reindexed_count,
                    "index_names": indexes
                }
            except sqlite3.Error as e:
                print(f"Error reindexing database: {str(e)}")
                return {
                    "success": False,
                    "error": str(e)
                }
            finally:
                conn.close()

    def clear_old_scans(self, days):
        """
        Delete scans older than the specified number of days.

        Args:
            days: Number of days old to delete

        Returns:
            dict: Status dictionary with success flag and count of deleted scans
        """
        with self.lock:
            conn = self.get_connection()
            try:
                cursor = conn.cursor()

                # Find the cutoff date
                cutoff_date = datetime.now(timezone.utc) - timedelta(days=days)
                cutoff_str = cutoff_date.isoformat()

                # Begin transaction
                cursor.execute("BEGIN TRANSACTION")

                # Get list of scan IDs to delete
                cursor.execute("""
                    SELECT id FROM scans
                    WHERE start_time < ?
                """, (cutoff_str,))

                scan_ids = [row[0] for row in cursor.fetchall()]

                if not scan_ids:
                    # No scans to delete
                    return {
                        "success": True,
                        "scans_deleted": 0,
                        "message": f"No scans found older than {days} days"
                    }

                # Get counts for reporting
                cursor.execute("""
                    SELECT COUNT(*) FROM checksums
                    WHERE scan_id IN ({})
                """.format(','.join('?' * len(scan_ids))), scan_ids)
                checksum_count = cursor.fetchone()[0]

                cursor.execute("""
                    SELECT COUNT(*) FROM scan_errors
                    WHERE scan_id IN ({})
                """.format(','.join('?' * len(scan_ids))), scan_ids)
                error_count = cursor.fetchone()[0]

                # Delete checksums for these scans
                cursor.execute("""
                    DELETE FROM checksums
                    WHERE scan_id IN ({})
                """.format(','.join('?' * len(scan_ids))), scan_ids)

                # Delete scan errors for these scans
                cursor.execute("""
                    DELETE FROM scan_errors
                    WHERE scan_id IN ({})
                """.format(','.join('?' * len(scan_ids))), scan_ids)

                # Delete the scans
                cursor.execute("""
                    DELETE FROM scans
                    WHERE id IN ({})
                """.format(','.join('?' * len(scan_ids))), scan_ids)

                # Commit transaction
                conn.commit()

                return {
                    "success": True,
                    "scans_deleted": len(scan_ids),
                    "checksums_deleted": checksum_count,
                    "errors_deleted": error_count
                }
            except sqlite3.Error as e:
                conn.rollback()
                print(f"Error clearing old scans: {str(e)}")
                return {
                    "success": False,
                    "error": str(e)
                }
            finally:
                conn.close()

    def purge_missing_files(self, days):
        """
        Delete files marked as missing for longer than the specified days.

        Args:
            days: Number of days to consider a file as permanently missing

        Returns:
            dict: Status dictionary with success flag and count of purged files
        """
        with self.lock:
            conn = self.get_connection()
            try:
                cursor = conn.cursor()

                # Begin transaction
                cursor.execute("BEGIN TRANSACTION")

                # Find the cutoff date
                cutoff_date = datetime.now(timezone.utc) - timedelta(days=days)
                cutoff_str = cutoff_date.isoformat()

                # Find files that have been marked as missing
                # and where the last_seen date is older than the cutoff
                cursor.execute("""
                    SELECT id FROM files
                    WHERE is_deleted = 1 AND last_seen < ?
                """, (cutoff_str,))

                file_ids = [row[0] for row in cursor.fetchall()]

                if not file_ids:
                    # No files to purge
                    return {
                        "success": True,
                        "files_purged": 0,
                        "message": f"No files found missing for more than {days} days"
                    }

                # Get counts for reporting
                cursor.execute("""
                    SELECT COUNT(*) FROM checksums
                    WHERE file_id IN ({})
                """.format(','.join('?' * len(file_ids))), file_ids)
                checksum_count = cursor.fetchone()[0]

                # Delete checksums for these files
                cursor.execute("""
                    DELETE FROM checksums
                    WHERE file_id IN ({})
                """.format(','.join('?' * len(file_ids))), file_ids)

                # Delete the files
                cursor.execute("""
                    DELETE FROM files
                    WHERE id IN ({})
                """.format(','.join('?' * len(file_ids))), file_ids)

                # Commit transaction
                conn.commit()

                return {
                    "success": True,
                    "files_purged": len(file_ids),
                    "checksums_deleted": checksum_count
                }
            except sqlite3.Error as e:
                conn.rollback()
                print(f"Error purging missing files: {str(e)}")
                return {
                    "success": False,
                    "error": str(e)
                }
            finally:
                conn.close()

    def purge_orphaned_records(self):
        """
        Clean up orphaned records in the database.

        This removes:
        - Checksums without valid file or scan references
        - Scan errors without valid scan references

        Returns:
            dict: Status dictionary with success flag and counts
        """
        with self.lock:
            conn = self.get_connection()
            try:
                cursor = conn.cursor()

                # Begin transaction
                cursor.execute("BEGIN TRANSACTION")

                # Delete checksums with invalid file references
                cursor.execute("""
                    DELETE FROM checksums
                    WHERE file_id NOT IN (SELECT id FROM files)
                """)
                orphaned_checksums_file = cursor.rowcount

                # Delete checksums with invalid scan references
                cursor.execute("""
                    DELETE FROM checksums
                    WHERE scan_id NOT IN (SELECT id FROM scans)
                """)
                orphaned_checksums_scan = cursor.rowcount

                # Delete scan errors with invalid scan references
                cursor.execute("""
                    DELETE FROM scan_errors
                    WHERE scan_id NOT IN (SELECT id FROM scans)
                """)
                orphaned_errors = cursor.rowcount

                # Commit transaction
                conn.commit()

                return {
                    "success": True,
                    "orphaned_checksums_removed": orphaned_checksums_file + orphaned_checksums_scan,
                    "orphaned_errors_removed": orphaned_errors
                }
            except sqlite3.Error as e:
                conn.rollback()
                print(f"Error purging orphaned records: {str(e)}")
                return {
                    "success": False,
                    "error": str(e)
                }
            finally:
                conn.close()

    def create_backup(self, name=None):
        """
        Create a named backup of the database.

        Args:
            name: Optional name for the backup

        Returns:
            dict: Status dictionary with backup information
        """
        # Create a backup directory if it doesn't exist
        db_dir = os.path.dirname(self.db_path)
        backup_dir = os.path.join(db_dir, "backups")
        os.makedirs(backup_dir, exist_ok=True)

        # Generate a timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

        # Create backup filename
        if name:
            # Sanitize name to be filesystem-safe
            name = ''.join(c for c in name if c.isalnum() or c in ' _-').strip()
            name = name.replace(' ', '_')
            backup_filename = f"{timestamp}_{name}.db"
        else:
            backup_filename = f"{timestamp}_backup.db"

        backup_path = os.path.join(backup_dir, backup_filename)

        try:
            # Perform the backup
            with self.lock:
                source_conn = self.get_connection()
                try:
                    dest_conn = sqlite3.connect(backup_path)
                    source_conn.backup(dest_conn)
                    dest_conn.close()

                    # Get backup file size
                    backup_size = os.path.getsize(backup_path)

                    # Create a metadata record for this backup
                    metadata = {
                        "id": timestamp,  # Use timestamp as ID
                        "name": name or "Auto backup",
                        "date": timestamp,
                        "size": backup_size,
                        "path": backup_path,
                        "type": "manual" if name else "auto"
                    }

                    # Store metadata in backups registry
                    self._save_backup_metadata(metadata)

                    return {
                        "success": True,
                        "backup_id": timestamp,
                        "backup_name": name or "Auto backup",
                        "backup_date": timestamp,
                        "backup_size": backup_size,
                        "backup_path": backup_path
                    }
                finally:
                    source_conn.close()
        except Exception as e:
            print(f"Error creating backup: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    def _save_backup_metadata(self, metadata):
        """
        Save backup metadata to the backup registry file.

        Args:
            metadata: Dictionary with backup metadata
        """
        # Get the backup registry file path
        db_dir = os.path.dirname(self.db_path)
        backup_dir = os.path.join(db_dir, "backups")
        registry_path = os.path.join(backup_dir, "backup_registry.json")

        # Load existing registry or create new one
        registry = []
        if os.path.exists(registry_path):
            try:
                with open(registry_path, 'r') as f:
                    registry = json.load(f)
            except json.JSONDecodeError:
                # If the file is corrupted, start with an empty registry
                registry = []

        # Add or update this backup in the registry
        existing_index = next((i for i, x in enumerate(registry) if x.get('id') == metadata['id']), None)
        if existing_index is not None:
            registry[existing_index] = metadata
        else:
            registry.append(metadata)

        # Write registry back to file
        with open(registry_path, 'w') as f:
            json.dump(registry, f, indent=2)

    def list_backups(self):
        """
        List all available backups.

        Returns:
            list: List of backup metadata dictionaries
        """
        # Get the backup registry file path
        db_dir = os.path.dirname(self.db_path)
        backup_dir = os.path.join(db_dir, "backups")
        registry_path = os.path.join(backup_dir, "backup_registry.json")

        # Load existing registry or return empty list
        if os.path.exists(registry_path):
            try:
                with open(registry_path, 'r') as f:
                    registry = json.load(f)

                    # Sort by date (newest first)
                    registry.sort(key=lambda x: x.get('date', ''), reverse=True)

                    return {
                        "success": True,
                        "backups": registry
                    }
            except json.JSONDecodeError as e:
                return {
                    "success": False,
                    "error": f"Error reading backup registry: {str(e)}",
                    "backups": []
                }

        return {
            "success": True,
            "backups": []
        }

    def restore_backup(self, backup_id):
        """
        Restore database from a backup.

        Args:
            backup_id: ID of the backup to restore

        Returns:
            dict: Status dictionary
        """
        # Get backup metadata
        registry_result = self.list_backups()
        if not registry_result["success"]:
            return registry_result

        registry = registry_result["backups"]
        backup_metadata = next((x for x in registry if x.get('id') == backup_id), None)

        if not backup_metadata:
            return {
                "success": False,
                "error": f"Backup with ID {backup_id} not found"
            }

        backup_path = backup_metadata.get('path')

        if not backup_path or not os.path.exists(backup_path):
            return {
                "success": False,
                "error": f"Backup file not found at {backup_path}"
            }

        try:
            # Create a temporary file for the current database
            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.db')
            temp_file.close()
            temp_path = temp_file.name

            # Copy current database to temp file as a safety measure
            shutil.copy2(self.db_path, temp_path)

            # Replace current database with backup
            with self.lock:
                # Close any open connections
                # This is necessary to replace the file on Windows
                time.sleep(0.5)  # Brief pause to ensure connections are released

                # Copy backup to the database path
                shutil.copy2(backup_path, self.db_path)

                return {
                    "success": True,
                    "message": f"Database restored from backup {backup_metadata.get('name')}",
                    "temp_backup_path": temp_path
                }
        except Exception as e:
            # Try to restore from temporary backup if the restore failed
            try:
                if 'temp_path' in locals() and os.path.exists(temp_path):
                    shutil.copy2(temp_path, self.db_path)
                    os.unlink(temp_path)
            except Exception as restore_error:
                print(f"Error restoring from temp backup: {str(restore_error)}")

            print(f"Error restoring backup: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    def delete_backup(self, backup_id):
        """
        Delete a backup.

        Args:
            backup_id: ID of the backup to delete

        Returns:
            dict: Status dictionary
        """
        # Get backup metadata
        registry_result = self.list_backups()
        if not registry_result["success"]:
            return registry_result

        registry = registry_result["backups"]
        backup_metadata = next((x for x in registry if x.get('id') == backup_id), None)

        if not backup_metadata:
            return {
                "success": False,
                "error": f"Backup with ID {backup_id} not found"
            }

        backup_path = backup_metadata.get('path')

        try:
            # Delete the backup file
            if backup_path and os.path.exists(backup_path):
                os.unlink(backup_path)

            # Get the backup registry file path
            db_dir = os.path.dirname(self.db_path)
            backup_dir = os.path.join(db_dir, "backups")
            registry_path = os.path.join(backup_dir, "backup_registry.json")

            # Update registry
            if os.path.exists(registry_path):
                with open(registry_path, 'r') as f:
                    registry = json.load(f)

                # Remove the backup from the registry
                registry = [x for x in registry if x.get('id') != backup_id]

                # Write updated registry
                with open(registry_path, 'w') as f:
                    json.dump(registry, f, indent=2)

            return {
                "success": True,
                "message": f"Backup {backup_metadata.get('name')} deleted successfully"
            }
        except Exception as e:
            print(f"Error deleting backup: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    def get_backup_settings(self):
        """
        Get automatic backup settings.

        Returns:
            dict: Backup settings
        """
        config = self.get_all_configuration()

        return {
            "success": True,
            "enabled": config.get('db_auto_backup', True),
            "frequency": config.get('db_backup_frequency', 'weekly'),
            "retain_count": config.get('db_backup_retain', 10)
        }

    def set_backup_settings(self, enabled, frequency, retain_count):
        """
        Configure automatic backup settings.

        Args:
            enabled: Whether automatic backups are enabled
            frequency: Backup frequency (daily, weekly, monthly)
            retain_count: Number of backups to keep

        Returns:
            dict: Status dictionary
        """
        try:
            # Validate frequency
            valid_frequencies = ['daily', 'weekly', 'monthly']
            if frequency not in valid_frequencies:
                return {
                    "success": False,
                    "error": f"Invalid frequency. Must be one of {', '.join(valid_frequencies)}"
                }

            # Validate retain_count
            try:
                retain_count = int(retain_count)
                if retain_count < 1 or retain_count > 100:
                    return {
                        "success": False,
                        "error": "Retain count must be between 1 and 100"
                    }
            except ValueError:
                return {
                    "success": False,
                    "error": "Retain count must be an integer"
                }

            # Update settings
            self.set_configuration('db_auto_backup', str(bool(enabled)).lower(), 'boolean', 'Enable automatic database backups')
            self.set_configuration('db_backup_frequency', frequency, 'string', 'How often to perform database backups')
            self.set_configuration('db_backup_retain', str(retain_count), 'integer', 'Number of backup copies to retain')

            # Enforce retention policy
            self._enforce_backup_retention(retain_count)

            return {
                "success": True,
                "message": "Backup settings updated successfully",
                "enabled": enabled,
                "frequency": frequency,
                "retain_count": retain_count
            }
        except Exception as e:
            print(f"Error setting backup settings: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    def _enforce_backup_retention(self, retain_count):
        """
        Enforce backup retention policy by deleting oldest backups.

        Args:
            retain_count: Number of backups to keep
        """
        # Get all backups
        registry_result = self.list_backups()
        if not registry_result["success"] or not registry_result["backups"]:
            return

        registry = registry_result["backups"]

        # If we have more backups than the retention count, delete the oldest ones
        if len(registry) > retain_count:
            # Sort by date (oldest first)
            registry.sort(key=lambda x: x.get('date', ''))

            # Delete the oldest backups
            for i in range(len(registry) - retain_count):
                self.delete_backup(registry[i].get('id'))

    def run_integrity_check(self):
        """
        Run an integrity check on the database.

        Returns:
            dict: Status dictionary with integrity check results
        """
        with self.lock:
            conn = self.get_connection()
            try:
                cursor = conn.cursor()

                # Run integrity check
                cursor.execute("PRAGMA integrity_check")
                result = cursor.fetchall()

                # If the result is just ["ok"], the database is fine
                if len(result) == 1 and result[0][0] == "ok":
                    return {
                        "success": True,
                        "integrity_status": "ok",
                        "message": "Database integrity check passed"
                    }
                else:
                    # Collect error messages
                    errors = [row[0] for row in result]
                    return {
                        "success": True,
                        "integrity_status": "error",
                        "message": "Database integrity check failed",
                        "errors": errors
                    }
            except sqlite3.Error as e:
                print(f"Error running integrity check: {str(e)}")
                return {
                    "success": False,
                    "error": str(e)
                }
            finally:
                conn.close()

    def repair_database(self):
        """
        Attempt to repair the database by dumping and recreating it.

        Returns:
            dict: Status dictionary
        """
        try:
            # Create a backup first
            backup_result = self.create_backup("pre_repair_backup")
            if not backup_result["success"]:
                return backup_result

            # Create temporary files for dump and new database
            temp_dump = tempfile.NamedTemporaryFile(delete=False, suffix='.sql')
            temp_dump.close()
            temp_dump_path = temp_dump.name

            temp_db = tempfile.NamedTemporaryFile(delete=False, suffix='.db')
            temp_db.close()
            temp_db_path = temp_db.name

            # Dump the database schema and contents
            with self.lock:
                conn = self.get_connection()
                try:
                    # Dump to SQL file
                    with open(temp_dump_path, 'w') as f:
                        for line in conn.iterdump():
                            f.write(f"{line}\n")
                finally:
                    conn.close()

            # Create a new database from the dump
            conn = sqlite3.connect(temp_db_path)
            try:
                with open(temp_dump_path, 'r') as f:
                    script = f.read()
                    conn.executescript(script)

                conn.close()

                # Replace the original database with the repaired one
                with self.lock:
                    # Close any open connections
                    time.sleep(0.5)  # Brief pause to ensure connections are released

                    # Copy repaired database to the database path
                    shutil.copy2(temp_db_path, self.db_path)

                return {
                    "success": True,
                    "message": "Database repair completed successfully",
                    "backup_id": backup_result.get("backup_id")
                }
            except Exception as e:
                # If repair fails, don't replace the original database
                print(f"Error repairing database: {str(e)}")
                return {
                    "success": False,
                    "error": str(e),
                    "backup_id": backup_result.get("backup_id")
                }
            finally:
                # Clean up temporary files
                try:
                    os.unlink(temp_dump_path)
                    os.unlink(temp_db_path)
                except Exception as e:
                    print(f"Error cleaning up temporary files: {str(e)}")
        except Exception as e:
            print(f"Error during database repair: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    def export_schema(self):
        """
        Export the database schema to a SQL file.

        Returns:
            dict: Status dictionary with path to the exported schema
        """
        try:
            # Create export directory if it doesn't exist
            db_dir = os.path.dirname(self.db_path)
            export_dir = os.path.join(db_dir, "exports")
            os.makedirs(export_dir, exist_ok=True)

            # Generate a timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

            # Create export filename
            export_path = os.path.join(export_dir, f"schema_export_{timestamp}.sql")

            with self.lock:
                conn = self.get_connection()
                try:
                    cursor = conn.cursor()

                    # Get all table definitions
                    cursor.execute("""
                        SELECT name, sql FROM sqlite_master
                        WHERE type='table' AND name NOT LIKE 'sqlite_%'
                    """)

                    tables = cursor.fetchall()

                    # Get all index definitions
                    cursor.execute("""
                        SELECT name, sql FROM sqlite_master
                        WHERE type='index' AND name NOT LIKE 'sqlite_%'
                    """)

                    indexes = cursor.fetchall()

                    # Get all trigger definitions
                    cursor.execute("""
                        SELECT name, sql FROM sqlite_master
                        WHERE type='trigger' AND name NOT LIKE 'sqlite_%'
                    """)

                    triggers = cursor.fetchall()

                    # Get all view definitions
                    cursor.execute("""
                        SELECT name, sql FROM sqlite_master
                        WHERE type='view' AND name NOT LIKE 'sqlite_%'
                    """)

                    views = cursor.fetchall()

                    # Write schema to file
                    with open(export_path, 'w') as f:
                        # Write header
                        f.write("-- SQLite schema export\n")
                        f.write(f"-- Generated: {datetime.now().isoformat()}\n\n")

                        # Write PRAGMA statements
                        f.write("PRAGMA foreign_keys = ON;\n")
                        f.write("PRAGMA journal_mode = WAL;\n\n")

                        # Write tables
                        f.write("-- Tables\n")
                        for name, sql in tables:
                            if sql:
                                f.write(f"{sql};\n\n")

                        # Write views
                        if views:
                            f.write("-- Views\n")
                            for name, sql in views:
                                if sql:
                                    f.write(f"{sql};\n\n")

                        # Write indexes
                        if indexes:
                            f.write("-- Indexes\n")
                            for name, sql in indexes:
                                if sql:
                                    f.write(f"{sql};\n\n")

                        # Write triggers
                        if triggers:
                            f.write("-- Triggers\n")
                            for name, sql in triggers:
                                if sql:
                                    f.write(f"{sql};\n\n")

                    return {
                        "success": True,
                        "export_path": export_path,
                        "tables_count": len(tables),
                        "indexes_count": len(indexes),
                        "triggers_count": len(triggers),
                        "views_count": len(views)
                    }
                finally:
                    conn.close()
        except Exception as e:
            print(f"Error exporting schema: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    def export_all_data(self):
        """
        Export all database data to a SQL file.

        Returns:
            dict: Status dictionary with path to the exported data
        """
        try:
            # Create export directory if it doesn't exist
            db_dir = os.path.dirname(self.db_path)
            export_dir = os.path.join(db_dir, "exports")
            os.makedirs(export_dir, exist_ok=True)

            # Generate a timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

            # Create export filename
            export_path = os.path.join(export_dir, f"data_export_{timestamp}.sql")

            with self.lock:
                conn = self.get_connection()
                try:
                    # Dump entire database to SQL file
                    with open(export_path, 'w') as f:
                        for line in conn.iterdump():
                            f.write(f"{line}\n")

                    return {
                        "success": True,
                        "export_path": export_path,
                        "message": "All database data exported successfully"
                    }
                finally:
                    conn.close()
        except Exception as e:
            print(f"Error exporting data: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    def export_configuration(self):
        """
        Export database configuration to a JSON file.

        Returns:
            dict: Status dictionary with path to the exported configuration
        """
        try:
            # Create export directory if it doesn't exist
            db_dir = os.path.dirname(self.db_path)
            export_dir = os.path.join(db_dir, "exports")
            os.makedirs(export_dir, exist_ok=True)

            # Generate a timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

            # Create export filename
            export_path = os.path.join(export_dir, f"config_export_{timestamp}.json")

            # Get configuration
            config = self.get_all_configuration()

            # Write to JSON file
            with open(export_path, 'w') as f:
                json.dump(config, f, indent=2, default=str)

            return {
                "success": True,
                "export_path": export_path,
                "config_items": len(config),
                "message": "Configuration exported successfully"
            }
        except Exception as e:
            print(f"Error exporting configuration: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    def count_scans(self):
        """
        Count the total number of scans in the database.

        Returns:
            int: Number of scans
        """
        with self.lock:
            conn = self.get_connection()
            try:
                cursor = conn.cursor()
                cursor.execute("SELECT COUNT(*) FROM scans")
                count = cursor.fetchone()[0]
                return count
            except sqlite3.Error as e:
                print(f"Error counting scans: {str(e)}")
                return 0
            finally:
                conn.close()

    def check_for_active_scans(self):
        """
        Check if there are any running scans.

        Returns:
            dict: Status dictionary with active scan info
        """
        with self.lock:
            conn = self.get_connection()
            try:
                cursor = conn.cursor()
                cursor.execute("""
                    SELECT id, name, top_level_path, start_time
                    FROM scans
                    WHERE status = 'running'
                """)
                active_scans = [
                    {
                        "id": row[0],
                        "name": row[1],
                        "top_level_path": row[2],
                        "start_time": row[3]
                    }
                    for row in cursor.fetchall()
                ]

                return {
                    "success": True,
                    "active_scan_count": len(active_scans),
                    "active_scans": active_scans
                }
            except sqlite3.Error as e:
                print(f"Error checking for active scans: {str(e)}")
                return {
                    "success": False,
                    "error": str(e)
                }
            finally:
                conn.close()

    def mark_scans_as_aborted(self):
        """
        Mark all running scans as aborted.

        Returns:
            dict: Status dictionary with count of aborted scans
        """
        with self.lock:
            conn = self.get_connection()
            try:
                cursor = conn.cursor()
                cursor.execute("""
                    UPDATE scans
                    SET status = 'aborted', end_time = CURRENT_TIMESTAMP
                    WHERE status = 'running'
                """)

                conn.commit()
                return {
                    "success": True,
                    "scans_aborted": cursor.rowcount
                }
            except sqlite3.Error as e:
                print(f"Error marking scans as aborted: {str(e)}")
                return {
                    "success": False,
                    "error": str(e)
                }
            finally:
                conn.close()

</code>

db/init_db.py:
<code>
"""
Database initialization script for Bitarr.
"""
import sqlite3
import os
from pathlib import Path
from .schema import (
    PRAGMA_FOREIGN_KEYS, PRAGMA_JOURNAL_MODE,
    CREATE_STORAGE_DEVICES_TABLE, CREATE_FILES_TABLE,
    CREATE_SCHEDULED_SCANS_TABLE, CREATE_SCANS_TABLE,
    CREATE_CHECKSUMS_TABLE, CREATE_SCAN_ERRORS_TABLE,
    CREATE_CONFIGURATION_TABLE, CREATE_INDEXES,
    DEFAULT_CONFIG, get_default_db_path
)

def init_db(db_path=None):
    """
    Initialize the SQLite database with the schema.
    
    Args:
        db_path: Path to the database file. If None, uses the default path.
    
    Returns:
        str: Path to the initialized database
    """
    if db_path is None:
        db_path = get_default_db_path()
    
    # Ensure the directory exists
    db_dir = os.path.dirname(db_path)
    os.makedirs(db_dir, exist_ok=True)
    
    # Connect to the database
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    # Enable foreign keys and WAL mode
    cursor.execute(PRAGMA_FOREIGN_KEYS)
    cursor.execute(PRAGMA_JOURNAL_MODE)
    
    # Create tables
    cursor.execute(CREATE_STORAGE_DEVICES_TABLE)
    cursor.execute(CREATE_FILES_TABLE)
    cursor.execute(CREATE_SCHEDULED_SCANS_TABLE)
    cursor.execute(CREATE_SCANS_TABLE)
    cursor.execute(CREATE_CHECKSUMS_TABLE)
    cursor.execute(CREATE_SCAN_ERRORS_TABLE)
    cursor.execute(CREATE_CONFIGURATION_TABLE)
    
    # Create indexes
    for index_sql in CREATE_INDEXES:
        cursor.execute(index_sql)
    
    # Insert default configuration values if they don't exist
    for key, value, type_str, description in DEFAULT_CONFIG:
        cursor.execute(
            """
            INSERT OR IGNORE INTO configuration 
            (key, value, type, description) 
            VALUES (?, ?, ?, ?)
            """, 
            (key, value, type_str, description)
        )
    
    # Commit changes and close the connection
    conn.commit()
    conn.close()
    
    return str(db_path)

if __name__ == "__main__":
    db_path = init_db()
    print(f"Database initialized at: {db_path}")

</code>

db/__init__.py:
<code>

</code>

db/models.py:
<code>
"""
Database models for Bitarr.
"""
import json
import sqlite3
import time
from datetime import datetime, timezone

class StorageDevice:
    """Represents a storage device in the system."""
    
    def __init__(
        self, id=None, name=None, mount_point=None, 
        device_type=None, total_size=None, used_size=None,
        first_seen=None, last_seen=None, is_connected=True, 
        device_id=None
    ):
        self.id = id
        self.name = name
        self.mount_point = mount_point
        self.device_type = device_type
        self.total_size = total_size
        self.used_size = used_size
        self.first_seen = first_seen or datetime.now(timezone.utc)
        self.last_seen = last_seen or datetime.now(timezone.utc)
        self.is_connected = is_connected
        self.device_id = device_id
    
    @classmethod
    def from_row(cls, row):
        """Create a StorageDevice object from a database row."""
        if not row:
            return None
        
        return cls(
            id=row[0],
            name=row[1],
            mount_point=row[2],
            device_type=row[3],
            total_size=row[4],
            used_size=row[5],
            first_seen=row[6],
            last_seen=row[7],
            is_connected=bool(row[8]),
            device_id=row[9]
        )
    
    def to_dict(self):
        """Convert the object to a dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "mount_point": self.mount_point,
            "device_type": self.device_type,
            "total_size": self.total_size,
            "used_size": self.used_size,
            "first_seen": self.first_seen,
            "last_seen": self.last_seen,
            "is_connected": self.is_connected,
            "device_id": self.device_id
        }

class File:
    """Represents a file tracked in the system."""
    
    def __init__(
        self, id=None, path=None, filename=None, 
        directory=None, storage_device_id=None,
        size=None, last_modified=None, file_type=None,
        first_seen=None, last_seen=None, is_deleted=False
    ):
        self.id = id
        self.path = path
        self.filename = filename
        self.directory = directory
        self.storage_device_id = storage_device_id
        self.size = size
        self.last_modified = last_modified
        self.file_type = file_type
        self.first_seen = first_seen or datetime.now(timezone.utc)
        self.last_seen = last_seen or datetime.now(timezone.utc)
        self.is_deleted = is_deleted
    
    @classmethod
    def from_row(cls, row):
        """Create a File object from a database row."""
        if not row:
            return None
        
        return cls(
            id=row[0],
            path=row[1],
            filename=row[2],
            directory=row[3],
            storage_device_id=row[4],
            size=row[5],
            last_modified=row[6],
            file_type=row[7],
            first_seen=row[8],
            last_seen=row[9],
            is_deleted=bool(row[10])
        )
    
    def to_dict(self):
        """Convert the object to a dictionary."""
        return {
            "id": self.id,
            "path": self.path,
            "filename": self.filename,
            "directory": self.directory,
            "storage_device_id": self.storage_device_id,
            "size": self.size,
            "last_modified": self.last_modified,
            "file_type": self.file_type,
            "first_seen": self.first_seen,
            "last_seen": self.last_seen,
            "is_deleted": self.is_deleted
        }

class Scan:
    """Represents a scan operation."""
    
    def __init__(
        self, id=None, name=None, top_level_path=None,
        start_time=None, end_time=None, status="running",
        files_scanned=0, files_unchanged=0, files_modified=0,
        files_corrupted=0, files_missing=0, files_new=0,
        checksum_method="sha256", scheduled_scan_id=None,
        error_message=None, notes=None
    ):
        self.id = id
        self.name = name
        self.top_level_path = top_level_path
        self.start_time = start_time or datetime.now(timezone.utc)
        self.end_time = end_time
        self.status = status
        self.files_scanned = files_scanned
        self.files_unchanged = files_unchanged
        self.files_modified = files_modified
        self.files_corrupted = files_corrupted
        self.files_missing = files_missing
        self.files_new = files_new
        self.checksum_method = checksum_method
        self.scheduled_scan_id = scheduled_scan_id
        self.error_message = error_message
        self.notes = notes
    
    @classmethod
    def from_row(cls, row):
        """Create a Scan object from a database row."""
        if not row:
            return None
        
        return cls(
            id=row[0],
            name=row[1],
            top_level_path=row[2],
            start_time=row[3],
            end_time=row[4],
            status=row[5],
            files_scanned=row[6],
            files_unchanged=row[7],
            files_modified=row[8],
            files_corrupted=row[9],
            files_missing=row[10],
            files_new=row[11],
            checksum_method=row[12],
            scheduled_scan_id=row[13],
            error_message=row[14],
            notes=row[15]
        )
    
    def to_dict(self):
        """Convert the object to a dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "top_level_path": self.top_level_path,
            "start_time": self.start_time,
            "end_time": self.end_time,
            "status": self.status,
            "files_scanned": self.files_scanned,
            "files_unchanged": self.files_unchanged,
            "files_modified": self.files_modified,
            "files_corrupted": self.files_corrupted,
            "files_missing": self.files_missing,
            "files_new": self.files_new,
            "checksum_method": self.checksum_method,
            "scheduled_scan_id": self.scheduled_scan_id,
            "error_message": self.error_message,
            "notes": self.notes
        }

class Checksum:
    """Represents a file checksum."""
    
    def __init__(
        self, id=None, file_id=None, scan_id=None,
        checksum_value=None, checksum_method="sha256",
        timestamp=None, status="new", previous_checksum_id=None
    ):
        self.id = id
        self.file_id = file_id
        self.scan_id = scan_id
        self.checksum_value = checksum_value
        self.checksum_method = checksum_method
        self.timestamp = timestamp or datetime.now(timezone.utc)
        self.status = status
        self.previous_checksum_id = previous_checksum_id
    
    @classmethod
    def from_row(cls, row):
        """Create a Checksum object from a database row."""
        if not row:
            return None
        
        return cls(
            id=row[0],
            file_id=row[1],
            scan_id=row[2],
            checksum_value=row[3],
            checksum_method=row[4],
            timestamp=row[5],
            status=row[6],
            previous_checksum_id=row[7]
        )
    
    def to_dict(self):
        """Convert the object to a dictionary."""
        return {
            "id": self.id,
            "file_id": self.file_id,
            "scan_id": self.scan_id,
            "checksum_value": self.checksum_value,
            "checksum_method": self.checksum_method,
            "timestamp": self.timestamp,
            "status": self.status,
            "previous_checksum_id": self.previous_checksum_id
        }

class ScheduledScan:
    """Represents a scheduled scan configuration."""
    
    def __init__(
        self, id=None, name=None, paths=None,
        frequency=None, parameters=None, last_run=None,
        next_run=None, status="active", priority=0,
        max_runtime=None, is_active=True, created_at=None
    ):
        self.id = id
        self.name = name
        self.paths = paths if isinstance(paths, str) else json.dumps(paths or [])
        self.frequency = frequency
        self.parameters = parameters if isinstance(parameters, str) else json.dumps(parameters or {})
        self.last_run = last_run
        self.next_run = next_run
        self.status = status
        self.priority = priority
        self.max_runtime = max_runtime
        self.is_active = is_active
        self.created_at = created_at or datetime.now(timezone.utc)
    
    @classmethod
    def from_row(cls, row):
        """Create a ScheduledScan object from a database row."""
        if not row:
            return None
        
        return cls(
            id=row[0],
            name=row[1],
            paths=row[2],
            frequency=row[3],
            parameters=row[4],
            last_run=row[5],
            next_run=row[6],
            status=row[7],
            priority=row[8],
            max_runtime=row[9],
            is_active=bool(row[10]),
            created_at=row[11]
        )

    def to_dict(self):
        """Convert the object to a dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "paths": json.loads(self.paths) if isinstance(self.paths, str) else self.paths,
            "frequency": self.frequency,
            "parameters": json.loads(self.parameters) if isinstance(self.parameters, str) else self.parameters,
            "last_run": self.last_run,
            "next_run": self.next_run,
            "status": self.status,
            "priority": self.priority,
            "max_runtime": self.max_runtime,
            "is_active": self.is_active,
            "created_at": self.created_at
        }

class ScanError:
    """Represents an error that occurred during a scan."""
    
    def __init__(
        self, id=None, scan_id=None, file_path=None,
        error_type=None, error_message=None, timestamp=None
    ):
        self.id = id
        self.scan_id = scan_id
        self.file_path = file_path
        self.error_type = error_type
        self.error_message = error_message
        self.timestamp = timestamp or datetime.now(timezone.utc)
    
    @classmethod
    def from_row(cls, row):
        """Create a ScanError object from a database row."""
        if not row:
            return None
        
        return cls(
            id=row[0],
            scan_id=row[1],
            file_path=row[2],
            error_type=row[3],
            error_message=row[4],
            timestamp=row[5]
        )
    
    def to_dict(self):
        """Convert the object to a dictionary."""
        return {
            "id": self.id,
            "scan_id": self.scan_id,
            "file_path": self.file_path,
            "error_type": self.error_type,
            "error_message": self.error_message,
            "timestamp": self.timestamp
        }

class Configuration:
    """Represents a configuration setting."""

    def __init__(
        self, key=None, value=None, value_type=None,
        description=None, updated_at=None
    ):
        self.key = key
        self.value = value
        self.value_type = value_type
        self.description = description
        self.updated_at = updated_at or datetime.now(timezone.utc)

    @classmethod
    def from_row(cls, row):
        """Create a Configuration object from a database row."""
        if not row:
            return None

        return cls(
            key=row[0],
            value=row[1],
            value_type=row[2],
            description=row[3],
            updated_at=row[4]
        )

    def to_dict(self):
        """Convert the object to a dictionary."""
        return {
            "key": self.key,
            "value": self.value,
            "value_type": self.value_type,
            "description": self.description,
            "updated_at": self.updated_at
        }

    def get_typed_value(self):
        """Get the value converted to its appropriate type."""
        if self.value_type == "integer":
            return int(self.value)
        elif self.value_type == "float":
            return float(self.value)
        elif self.value_type == "boolean":
            return self.value.lower() in ("1", "true", "yes", "y", "t")
        elif self.value_type == "json":
            return json.loads(self.value)
        else:  # string or other
            return self.value

</code>

db/__main__.py:
<code>
"""
Command-line interface for database management.
"""
import sys
import argparse
from pathlib import Path
from .init_db import init_db
from .db_manager import DatabaseManager

def main():
    """Main entry point for database management CLI."""
    parser = argparse.ArgumentParser(description="Bitarr Database Management")
    
    # Add subparsers
    subparsers = parser.add_subparsers(dest="command", help="Command")
    
    # Init command
    init_parser = subparsers.add_parser("init", help="Initialize database")
    init_parser.add_argument(
        "--path", type=str, help="Path to database file", default=None
    )
    
    # Info command
    info_parser = subparsers.add_parser("info", help="Show database information")
    info_parser.add_argument(
        "--path", type=str, help="Path to database file", default=None
    )
    
    # Vacuum command
    vacuum_parser = subparsers.add_parser("vacuum", help="Run VACUUM on database")
    vacuum_parser.add_argument(
        "--path", type=str, help="Path to database file", default=None
    )
    
    # Backup command
    backup_parser = subparsers.add_parser("backup", help="Create database backup")
    backup_parser.add_argument(
        "--path", type=str, help="Path to database file", default=None
    )
    backup_parser.add_argument(
        "--backup-path", type=str, help="Path for backup file", default=None
    )
    
    # Prune command
    prune_parser = subparsers.add_parser("prune", help="Prune old scans")
    prune_parser.add_argument(
        "--path", type=str, help="Path to database file", default=None
    )
    prune_parser.add_argument(
        "--days", type=int, help="Days old to prune", required=True
    )
    
    # Parse arguments
    args = parser.parse_args()
    
    if args.command == "init":
        db_path = init_db(args.path)
        print(f"Database initialized at: {db_path}")
    
    elif args.command == "info":
        db = DatabaseManager(args.path)
        info = db.get_database_info()
        print("\nDatabase Information:")
        print(f"Path: {db.db_path}")
        print(f"Size: {info['database_size'] / (1024*1024):.2f} MB")
        print("\nCounts:")
        print(f"  Storage Devices: {info['storage_devices_count']}")
        print(f"  Files: {info['files_count']}")
        print(f"  Scans: {info['scans_count']}")
        print(f"  Checksums: {info['checksums_count']}")
        print(f"  Scheduled Scans: {info['scheduled_scans_count']}")
        print(f"  Scan Errors: {info['scan_errors_count']}")
        print(f"  Configuration Items: {info['configuration_count']}")
        
        if info["first_scan"]:
            print(f"\nFirst Scan: {info['first_scan']}")
        if info["last_scan"]:
            print(f"Last Scan: {info['last_scan']}")
    
    elif args.command == "vacuum":
        db = DatabaseManager(args.path)
        success = db.vacuum()
        if success:
            print("VACUUM completed successfully")
        else:
            print("VACUUM failed")
            sys.exit(1)
    
    elif args.command == "backup":
        db = DatabaseManager(args.path)
        backup_path = db.backup(args.backup_path)
        print(f"Backup created at: {backup_path}")
    
    elif args.command == "prune":
        db = DatabaseManager(args.path)
        pruned = db.prune_old_scans(args.days)
        print(f"Pruned {pruned} scans older than {args.days} days")
    
    else:
        parser.print_help()
        sys.exit(1)

if __name__ == "__main__":
    main()

</code>

web/api.py:
<code>
"""
API endpoints for Bitarr application.
"""
import os
import json
from datetime import datetime
from flask import Blueprint, request, jsonify, current_app, send_file
from bitarr.db.db_manager import DatabaseManager
from bitarr.db.models import ScheduledScan, Configuration
from .routes import active_scans

# Create blueprint
bp = Blueprint('api', __name__, url_prefix='/api')

# Create blueprint
db_api = Blueprint('db_api', __name__, url_prefix='/api/db')

# Create database manager
db = DatabaseManager()

# === Scheduled Scans APIs ===

@bp.route('/scheduled_scans', methods=['GET'])
def get_scheduled_scans():
    """
    Get all scheduled scans.

    Returns:
        dict: List of scheduled scans
    """
    # Get scheduled scans
    scheduled_scans = db.get_all_scheduled_scans()

    return jsonify([scan.to_dict() for scan in scheduled_scans])

@bp.route('/scheduled_scans', methods=['POST'])
def create_scheduled_scan():
    """
    Create a new scheduled scan.

    Returns:
        dict: Created scheduled scan
    """
    # Get request data
    data = request.json
    if not data:
        return jsonify({'success': False, 'error': 'No data provided'}), 400

    # Validate input
    required_fields = ['name', 'paths', 'frequency', 'parameters']
    for field in required_fields:
        if field not in data:
            return jsonify({'success': False, 'error': f'Missing required field: {field}'}), 400

    # Convert paths to JSON if it's a list
    paths = data['paths']
    if isinstance(paths, list):
        paths = json.dumps(paths)

    # Convert parameters to JSON if it's a dict
    parameters = data['parameters']
    if isinstance(parameters, dict):
        parameters = json.dumps(parameters)

    scheduled_scan = ScheduledScan(
        name=data['name'],
        paths=paths,
        frequency=data['frequency'],
        parameters=parameters,
        next_run=data.get('next_run'),
        status=data.get('status', 'active'),
        priority=data.get('priority', 0),
        max_runtime=data.get('max_runtime'),
        is_active=data.get('is_active', True)
    )

    # Add to database
    scheduled_scan.id = db.add_scheduled_scan(scheduled_scan)

    return jsonify({'success': True, 'scheduled_scan': scheduled_scan.to_dict()})

@bp.route('/scheduled_scans/<int:scheduled_scan_id>', methods=['GET'])
def get_scheduled_scan(scheduled_scan_id):
    """
    Get a scheduled scan.

    Args:
        scheduled_scan_id: ID of the scheduled scan

    Returns:
        dict: Scheduled scan details
    """
    # Get scheduled scan
    scheduled_scan = db.get_scheduled_scan(scheduled_scan_id)
    if not scheduled_scan:
        return jsonify({'success': False, 'error': 'Scheduled scan not found'}), 404

    return jsonify({'success': True, 'scheduled_scan': scheduled_scan.to_dict()})

@bp.route('/scheduled_scans/<int:scheduled_scan_id>', methods=['PUT'])
def update_scheduled_scan(scheduled_scan_id):
    """
    Update a scheduled scan.

    Args:
        scheduled_scan_id: ID of the scheduled scan

    Returns:
        dict: Updated scheduled scan
    """
    # Get request data
    data = request.json
    if not data:
        return jsonify({'success': False, 'error': 'No data provided'}), 400

    # Get scheduled scan
    scheduled_scan = db.get_scheduled_scan(scheduled_scan_id)
    if not scheduled_scan:
        return jsonify({'success': False, 'error': 'Scheduled scan not found'}), 404

    # Update fields
    if 'name' in data:
        scheduled_scan.name = data['name']

    if 'paths' in data:
        paths = data['paths']
        if isinstance(paths, list):
            paths = json.dumps(paths)
        scheduled_scan.paths = paths

    if 'frequency' in data:
        scheduled_scan.frequency = data['frequency']

    if 'parameters' in data:
        parameters = data['parameters']
        if isinstance(parameters, dict):
            parameters = json.dumps(parameters)
        scheduled_scan.parameters = parameters

    if 'next_run' in data:
        scheduled_scan.next_run = data['next_run']

    if 'status' in data:
        scheduled_scan.status = data['status']

    if 'priority' in data:
        scheduled_scan.priority = data['priority']

    if 'max_runtime' in data:
        scheduled_scan.max_runtime = data['max_runtime']

    if 'is_active' in data:
        scheduled_scan.is_active = data['is_active']

    # Update in database
    db.update_scheduled_scan(scheduled_scan)

    return jsonify({'success': True, 'scheduled_scan': scheduled_scan.to_dict()})

@bp.route('/scheduled_scans/<int:scheduled_scan_id>', methods=['DELETE'])
def delete_scheduled_scan(scheduled_scan_id):
    """
    Delete a scheduled scan.

    Args:
        scheduled_scan_id: ID of the scheduled scan

    Returns:
        dict: Success message
    """
    # Delete scheduled scan
    result = db.delete_scheduled_scan(scheduled_scan_id)

    if result:
        return jsonify({'success': True, 'message': 'Scheduled scan deleted'})

    return jsonify({'success': False, 'error': 'Scheduled scan not found'}), 404

@bp.route('/scheduled_scans/<int:scheduled_scan_id>/run', methods=['POST'])
def run_scheduled_scan(scheduled_scan_id):
    """
    Run a scheduled scan immediately.

    Args:
        scheduled_scan_id: ID of the scheduled scan

    Returns:
        dict: Success message
    """
    # Get scheduled scan
    scheduled_scan = db.get_scheduled_scan(scheduled_scan_id)
    if not scheduled_scan:
        return jsonify({'success': False, 'error': 'Scheduled scan not found'}), 404

    # TODO: Implement immediate execution of the scheduled scan
    # This would involve parsing the scheduled scan's paths and parameters,
    # then starting a scan similar to how it's done in the routes.py file.

    return jsonify({'success': False, 'error': 'Not implemented yet'}), 501

# === Configuration APIs ===

@bp.route('/configuration', methods=['GET'])
def get_configuration():
    """
    Get all configuration values.

    Returns:
        dict: Configuration values
    """
    # Get configuration
    config = db.get_all_configuration()

    return jsonify({'success': True, 'configuration': config})

@bp.route('/configuration/<key>', methods=['GET'])
def get_configuration_value(key):
    """
    Get a specific configuration value.

    Args:
        key: Configuration key

    Returns:
        dict: Configuration value
    """
    # Get configuration
    config = db.get_configuration(key)
    if not config:
        return jsonify({'success': False, 'error': 'Configuration key not found'}), 404

    return jsonify({
        'success': True,
        'key': config.key,
        'value': config.get_typed_value(),
        'value_type': config.value_type,
        'description': config.description
    })

@bp.route('/configuration/<key>', methods=['PUT'])
def update_configuration(key):
    """
    Update a configuration value.

    Args:
        key: Configuration key

    Returns:
        dict: Updated configuration
    """
    # Get request data
    data = request.json
    if not data or 'value' not in data:
        return jsonify({'success': False, 'error': 'No value provided'}), 400

    # Update configuration
    value = data['value']
    value_type = data.get('value_type')
    description = data.get('description')

    result = db.set_configuration(key, value, value_type, description)

    if result:
        config = db.get_configuration(key)
        return jsonify({
            'success': True,
            'key': config.key,
            'value': config.get_typed_value(),
            'value_type': config.value_type,
            'description': config.description
        })

    return jsonify({'success': False, 'error': 'Failed to update configuration'}), 500

# === Database Management APIs ===

@bp.route('/database/info', methods=['GET'])
def get_database_info():
    """
    Get information about the database.

    Returns:
        dict: Database information
    """
    # Get database info
    info = db.get_database_info()

    return jsonify({'success': True, 'info': info})

@bp.route('/database/vacuum', methods=['POST'])
def vacuum_database():
    """
    Run VACUUM on the database.

    Returns:
        dict: Success message
    """
    # Run vacuum
    result = db.vacuum()

    if result:
        return jsonify({'success': True, 'message': 'Database vacuum completed'})

    return jsonify({'success': False, 'error': 'Failed to vacuum database'}), 500

@bp.route('/database/backup', methods=['POST'])
def backup_database():
    """
    Create a database backup.

    Returns:
        dict: Success message with backup path
    """
    # Create backup
    backup_path = db.backup()

    return jsonify({'success': True, 'message': 'Database backup created', 'backup_path': backup_path})

@bp.route('/database/prune', methods=['POST'])
def prune_database():
    """
    Prune old scans from the database.

    Returns:
        dict: Success message with number of scans pruned
    """
    # Get request data
    data = request.json
    if not data or 'days_old' not in data:
        return jsonify({'success': False, 'error': 'No days_old provided'}), 400

    days_old = int(data['days_old'])

    # Prune scans
    pruned = db.prune_old_scans(days_old)

    return jsonify({'success': True, 'message': f'Pruned {pruned} scans older than {days_old} days'})

# === Stats and Metrics APIs ===

@bp.route('/stats/overview', methods=['GET'])
def get_stats_overview():
    """
    Get overview statistics.

    Returns:
        dict: Overview statistics
    """
    # Get database info
    db_info = db.get_database_info()

    # Get active scans
    active_scan_count = len(active_scans)

    # Get last day's corruption stats
    # TODO: Implement query for corruption stats

    stats = {
        'files_count': db_info.get('files_count', 0),
        'scans_count': db_info.get('scans_count', 0),
        'storage_devices_count': db_info.get('storage_devices_count', 0),
        'active_scans': active_scan_count,
        'database_size': db_info.get('database_size', 0),
        'last_scan': db_info.get('last_scan'),
        'first_scan': db_info.get('first_scan')
    }

    return jsonify({'success': True, 'stats': stats})

@bp.route('/stats/storage_health', methods=['GET'])
def get_storage_health_stats():
    """
    Get storage health statistics.

    Returns:
        dict: Storage health statistics
    """
    # Get storage devices from database
    from bitarr.core.scanner import DeviceDetector

    detector = DeviceDetector()
    devices = detector.detect_devices()

    # Get corruption stats for each device
    device_stats = []

    for device in devices:
        device_id = device.get('device_id')

        # Skip devices without ID
        if not device_id:
            continue

        # Get storage device from database
        storage_device = db.get_storage_device(device_id=device_id)

        if not storage_device:
            continue

        # Get corruption stats
        query = """
            SELECT c.status, COUNT(*) as count
            FROM checksums c
            JOIN files f ON c.file_id = f.id
            WHERE f.storage_device_id = ?
            GROUP BY c.status
        """

        with db.lock:
            conn = db.get_connection()
            try:
                cursor = conn.cursor()
                cursor.execute(query, (storage_device.id,))

                status_counts = {}
                for row in cursor.fetchall():
                    status_counts[row['status']] = row['count']

                # Calculate health score (simple calculation for now)
                total_files = sum(status_counts.values())
                corrupted = status_counts.get('corrupted', 0)
                missing = status_counts.get('missing', 0)

                health_score = 100.0
                if total_files > 0:
                    health_score = max(0, 100 - (corrupted + missing) * 100.0 / total_files)

                device_stats.append({
                    'device_id': device_id,
                    'name': device.get('name'),
                    'mount_point': device.get('mount_point'),
                    'device_type': device.get('device_type'),
                    'total_size': device.get('total_size'),
                    'used_size': device.get('used_size'),
                    'total_files': total_files,
                    'status_counts': status_counts,
                    'health_score': health_score
                })
            finally:
                conn.close()

    return jsonify({'success': True, 'device_stats': device_stats})

@bp.route('/stats/scan_trends', methods=['GET'])
def get_scan_trends():
    """
    Get scan trends over time.

    Returns:
        dict: Scan trends statistics
    """
    # Get request parameters
    days = request.args.get('days', 30, type=int)

    # TODO: Implement query for scan trends
    # This would track metrics like corrupted files over time

    return jsonify({'success': False, 'error': 'Not implemented yet'}), 501

@db_api.route('/info', methods=['GET'])
def get_database_info():
    """
    Get information about the database.

    Returns:
        dict: Database information
    """
    # Get database info
    info = db.get_database_info()

    return jsonify({'success': True, 'info': info})

# === Reset Database Endpoints ===

@db_api.route('/reset/scan_history', methods=['POST'])
def reset_scan_history():
    """
    Reset scan history only, keeping schedules and configuration.

    Returns:
        dict: Status dictionary
    """
    # Verify confirmation code
    data = request.json
    if not data or data.get('confirmation') != 'RESET':
        return jsonify({
            'success': False,
            'error': 'Invalid confirmation code. Expected "RESET".'
        }), 400

    # Check for active scans
    active_scans_result = db.check_for_active_scans()
    if not active_scans_result['success']:
        return jsonify(active_scans_result), 500

    if active_scans_result['active_scan_count'] > 0:
        # Mark active scans as aborted
        db.mark_scans_as_aborted()

    # Perform reset
    result = db.reset_scan_history()

    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

@db_api.route('/reset/full', methods=['POST'])
def reset_full():
    """
    Reset database but keep configuration.

    Returns:
        dict: Status dictionary
    """
    # Verify confirmation code
    data = request.json
    if not data or data.get('confirmation') != 'RESET':
        return jsonify({
            'success': False,
            'error': 'Invalid confirmation code. Expected "RESET".'
        }), 400

    # Check for active scans
    active_scans_result = db.check_for_active_scans()
    if not active_scans_result['success']:
        return jsonify(active_scans_result), 500

    if active_scans_result['active_scan_count'] > 0:
        # Mark active scans as aborted
        db.mark_scans_as_aborted()

    # Perform reset
    result = db.reset_full()

    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

@db_api.route('/reset/complete', methods=['POST'])
def reset_complete():
    """
    Reset everything to default values.

    Returns:
        dict: Status dictionary
    """
    # Verify confirmation code
    data = request.json
    if not data or data.get('confirmation') != 'RESET':
        return jsonify({
            'success': False,
            'error': 'Invalid confirmation code. Expected "RESET".'
        }), 400

    # Check for active scans
    active_scans_result = db.check_for_active_scans()
    if not active_scans_result['success']:
        return jsonify(active_scans_result), 500

    if active_scans_result['active_scan_count'] > 0:
        # Mark active scans as aborted
        db.mark_scans_as_aborted()

    # Perform reset
    result = db.reset_complete()

    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

# === Maintenance Endpoints ===

@db_api.route('/vacuum', methods=['POST'])
def vacuum_database():
    """
    Run VACUUM on the database.

    Returns:
        dict: Success message
    """
    # Run vacuum
    result = db.vacuum()

    if result:
        return jsonify({'success': True, 'message': 'Database vacuum completed'})
    else:
        return jsonify({'success': False, 'error': 'Failed to vacuum database'}), 500

@db_api.route('/reindex', methods=['POST'])
def reindex_database():
    """
    Rebuild all database indexes.

    Returns:
        dict: Status dictionary
    """
    # Run reindex
    result = db.reindex()

    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

@db_api.route('/clear_old_scans', methods=['POST'])
def clear_old_scans():
    """
    Delete scans older than the specified number of days.

    Returns:
        dict: Status dictionary
    """
    # Get request data
    data = request.json
    if not data or 'days' not in data:
        return jsonify({
            'success': False,
            'error': 'Missing required parameter: days'
        }), 400

    days = int(data['days'])

    # Clear old scans
    result = db.clear_old_scans(days)

    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

@db_api.route('/purge_missing_files', methods=['POST'])
def purge_missing_files():
    """
    Delete files marked as missing for longer than the specified days.

    Returns:
        dict: Status dictionary
    """
    # Get request data
    data = request.json
    if not data or 'days' not in data:
        return jsonify({
            'success': False,
            'error': 'Missing required parameter: days'
        }), 400

    days = int(data['days'])

    # Purge missing files
    result = db.purge_missing_files(days)

    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

@db_api.route('/purge_orphaned_records', methods=['POST'])
def purge_orphaned_records():
    """
    Clean up orphaned records in the database.

    Returns:
        dict: Status dictionary
    """
    # Purge orphaned records
    result = db.purge_orphaned_records()

    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

@db_api.route('/integrity_check', methods=['GET'])
def integrity_check():
    """
    Run an integrity check on the database.

    Returns:
        dict: Status dictionary
    """
    # Run integrity check
    result = db.run_integrity_check()

    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

@db_api.route('/repair', methods=['POST'])
def repair_database():
    """
    Attempt to repair the database.

    Returns:
        dict: Status dictionary
    """
    # Repair database
    result = db.repair_database()

    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

# === Backup Endpoints ===

@db_api.route('/backups', methods=['GET'])
def list_backups():
    """
    List all available backups.

    Returns:
        dict: List of backups
    """
    # List backups
    result = db.list_backups()

    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

@db_api.route('/backup', methods=['POST'])
def create_backup():
    """
    Create a database backup.

    Returns:
        dict: Status dictionary
    """
    # Get request data
    data = request.json or {}
    name = data.get('name')

    # Create backup
    result = db.create_backup(name)

    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

@db_api.route('/backup/settings', methods=['GET'])
def get_backup_settings():
    """
    Get automatic backup settings.

    Returns:
        dict: Backup settings
    """
    # Get settings
    result = db.get_backup_settings()

    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

@db_api.route('/backup/settings', methods=['PUT'])
def set_backup_settings():
    """
    Configure automatic backup settings.

    Returns:
        dict: Status dictionary
    """
    # Get request data
    data = request.json
    if not data:
        return jsonify({
            'success': False,
            'error': 'No data provided'
        }), 400

    # Validate input
    required_fields = ['enabled', 'frequency', 'retain_count']
    for field in required_fields:
        if field not in data:
            return jsonify({
                'success': False,
                'error': f'Missing required field: {field}'
            }), 400

    # Update settings
    result = db.set_backup_settings(
        data['enabled'],
        data['frequency'],
        data['retain_count']
    )

    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

@db_api.route('/backup/<backup_id>/restore', methods=['POST'])
def restore_backup(backup_id):
    """
    Restore database from a backup.

    Args:
        backup_id: ID of the backup

    Returns:
        dict: Status dictionary
    """
    # Verify confirmation code
    data = request.json
    if not data or data.get('confirmation') != 'RESTORE':
        return jsonify({
            'success': False,
            'error': 'Invalid confirmation code. Expected "RESTORE".'
        }), 400

    # Check for active scans
    active_scans_result = db.check_for_active_scans()
    if not active_scans_result['success']:
        return jsonify(active_scans_result), 500

    if active_scans_result['active_scan_count'] > 0:
        # Mark active scans as aborted
        db.mark_scans_as_aborted()

    # Restore backup
    result = db.restore_backup(backup_id)

    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

@db_api.route('/backup/<backup_id>', methods=['DELETE'])
def delete_backup(backup_id):
    """
    Delete a backup.

    Args:
        backup_id: ID of the backup

    Returns:
        dict: Status dictionary
    """
    # Delete backup
    result = db.delete_backup(backup_id)

    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

# === Export Endpoints ===

@db_api.route('/export/schema', methods=['GET'])
def export_schema():
    """
    Export the database schema to a SQL file.

    Returns:
        file: Downloaded SQL file
    """
    # Export schema
    result = db.export_schema()

    if result['success']:
        # Return the file for download
        return send_file(
            result['export_path'],
            mimetype='text/plain',
            as_attachment=True,
            download_name=os.path.basename(result['export_path'])
        )
    else:
        return jsonify(result), 500

@db_api.route('/export/all_data', methods=['GET'])
def export_all_data():
    """
    Export all database data to a SQL file.

    Returns:
        file: Downloaded SQL file
    """
    # Export data
    result = db.export_all_data()

    if result['success']:
        # Return the file for download
        return send_file(
            result['export_path'],
            mimetype='text/plain',
            as_attachment=True,
            download_name=os.path.basename(result['export_path'])
        )
    else:
        return jsonify(result), 500

@db_api.route('/export/configuration', methods=['GET'])
def export_configuration():
    """
    Export database configuration to a JSON file.

    Returns:
        file: Downloaded JSON file
    """
    # Export configuration
    result = db.export_configuration()

    if result['success']:
        # Return the file for download
        return send_file(
            result['export_path'],
            mimetype='application/json',
            as_attachment=True,
            download_name=os.path.basename(result['export_path'])
        )
    else:
        return jsonify(result), 500

</code>

web/socket.py:
<code>

</code>

web/forms.py:
<code>

</code>

web/__init__.py:
<code>
"""
Web application module for Bitarr.
"""
from .app import create_app, socketio

__all__ = ['create_app', 'socketio']

</code>

web/utils.py:
<code>
"""
Utility functions for the web application.
"""
import os
import json
from datetime import datetime, timedelta
from dateutil import parser

def format_size(size_bytes):
    """
    Format size in bytes to human-readable format.

    Args:
        size_bytes: Size in bytes

    Returns:
        str: Formatted size string
    """
    if size_bytes is None:
        return "Unknown"

    # Convert to integer
    try:
        size_bytes = int(size_bytes)
    except (ValueError, TypeError):
        return "Unknown"

    # Format
    for unit in ['B', 'KB', 'MB', 'GB', 'TB', 'PB']:
        if size_bytes < 1024.0:
            return f"{size_bytes:.2f} {unit}"
        size_bytes /= 1024.0

    return f"{size_bytes:.2f} EB"

def format_timestamp(timestamp):
    """
    Format timestamp to human-readable format.

    Args:
        timestamp: Timestamp string or datetime object

    Returns:
        str: Formatted timestamp string
    """
    if not timestamp:
        return "Unknown"

    # Convert to datetime if string
    if isinstance(timestamp, str):
        try:
            timestamp = parser.parse(timestamp)
        except ValueError:
            return timestamp

    # Format
    now = datetime.now()
    diff = now - timestamp

    if diff < timedelta(minutes=1):
        return "Just now"
    elif diff < timedelta(hours=1):
        minutes = int(diff.total_seconds() / 60)
        return f"{minutes} minute{'s' if minutes != 1 else ''} ago"
    elif diff < timedelta(days=1):
        hours = int(diff.total_seconds() / 3600)
        return f"{hours} hour{'s' if hours != 1 else ''} ago"
    elif diff < timedelta(days=30):
        days = int(diff.total_seconds() / 86400)
        return f"{days} day{'s' if days != 1 else ''} ago"
    else:
        return timestamp.strftime("%Y-%m-%d %H:%M")

def parse_schedule_parameters(parameters):
    """
    Parse schedule parameters from JSON.

    Args:
        parameters: JSON string or dict

    Returns:
        dict: Parsed parameters
    """
    if isinstance(parameters, str):
        try:
            return json.loads(parameters)
        except json.JSONDecodeError:
            return {}
    elif isinstance(parameters, dict):
        return parameters
    else:
        return {}

def get_next_run_time(frequency, parameters):
    """
    Calculate the next run time based on frequency and parameters.

    Args:
        frequency: Frequency string (daily, weekly, monthly, quarterly, custom)
        parameters: Parameters dict

    Returns:
        datetime: Next run time
    """
    now = datetime.now()
    params = parse_schedule_parameters(parameters)

    if frequency == 'daily':
        # Get hour and minute
        hour = int(params.get('hour', 0))
        minute = int(params.get('minute', 0))

        # Create next run time
        next_run = now.replace(hour=hour, minute=minute, second=0, microsecond=0)

        # If next run is in the past, add one day
        if next_run <= now:
            next_run += timedelta(days=1)

    elif frequency == 'weekly':
        # Get day of week, hour, and minute
        day_of_week = int(params.get('day_of_week', 0))  # 0 = Monday, 6 = Sunday
        hour = int(params.get('hour', 0))
        minute = int(params.get('minute', 0))

        # Create next run time
        next_run = now.replace(hour=hour, minute=minute, second=0, microsecond=0)

        # Adjust day of week
        current_day_of_week = now.weekday()
        days_to_add = (day_of_week - current_day_of_week) % 7

        # If next run is today but in the past, add a week
        if days_to_add == 0 and next_run <= now:
            days_to_add = 7

        next_run += timedelta(days=days_to_add)

    elif frequency == 'monthly':
        # Get day of month, hour, and minute
        day_of_month = int(params.get('day_of_month', 1))
        hour = int(params.get('hour', 0))
        minute = int(params.get('minute', 0))

        # Create next run time
        next_run = now.replace(day=day_of_month, hour=hour, minute=minute, second=0, microsecond=0)

        # If next run is in the past, add one month
        if next_run <= now:
            # Add a month
            if now.month == 12:
                next_run = next_run.replace(year=now.year + 1, month=1)
            else:
                next_run = next_run.replace(month=now.month + 1)

    elif frequency == 'quarterly':
        # Get day of quarter, hour, and minute
        day_of_quarter = int(params.get('day_of_quarter', 1))
        hour = int(params.get('hour', 0))
        minute = int(params.get('minute', 0))

        # Calculate current quarter
        current_quarter = (now.month - 1) // 3 + 1

        # Calculate next quarter start
        next_quarter = current_quarter + 1 if current_quarter < 4 else 1
        next_quarter_year = now.year if next_quarter > current_quarter else now.year + 1
        next_quarter_month = (next_quarter - 1) * 3 + 1

        # Create next run time
        next_run = datetime(year=next_quarter_year, month=next_quarter_month, day=day_of_quarter,
                           hour=hour, minute=minute, second=0, microsecond=0)

    elif frequency == 'custom':
        # Get interval and unit
        interval = int(params.get('interval', 1))
        unit = params.get('unit', 'days')
        hour = int(params.get('hour', 0))
        minute = int(params.get('minute', 0))

        # Create next run time
        next_run = now.replace(hour=hour, minute=minute, second=0, microsecond=0)

        # If next run is in the past, add interval
        if next_run <= now:
            if unit == 'days':
                next_run += timedelta(days=interval)
            elif unit == 'weeks':
                next_run += timedelta(weeks=interval)
            elif unit == 'months':
                # Approximate months as 30 days
                next_run += timedelta(days=30 * interval)
            elif unit == 'years':
                # Approximate years as 365 days
                next_run += timedelta(days=365 * interval)

    else:
        # Default to daily at midnight
        next_run = now.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)

    return next_run

</code>

web/filters.py:
<code>
"""
Custom filters for the web templates.

This file contains Jinja2 filter functions that can be used in templates
to format values.
"""
from flask import Blueprint

# Create a blueprint for the filters
filters_bp = Blueprint('filters', __name__)

@filters_bp.app_template_filter('thousands_separator')
def thousands_separator(value):
    """
    Format a number with thousands separators.

    Args:
        value: Number to format

    Returns:
        str: Formatted number with thousands separators
    """
    try:
        return f"{int(value):,}"
    except (ValueError, TypeError):
        return str(value)

@filters_bp.app_template_filter('format_size')
def format_size(size_bytes):
    """
    Format a size in bytes to a human-readable format.

    Args:
        size_bytes: Size in bytes

    Returns:
        str: Human-readable size (e.g., "1.23 MB")
    """
    try:
        size_bytes = float(size_bytes)
    except (ValueError, TypeError):
        return "0 B"

    if size_bytes == 0:
        return "0 B"

    # Define size units and their scales
    units = ["B", "KB", "MB", "GB", "TB", "PB"]
    scale = 1024.0

    # Calculate the appropriate unit
    unit_index = 0
    while size_bytes >= scale and unit_index < len(units) - 1:
        size_bytes /= scale
        unit_index += 1

    # Format with appropriate precision
    if unit_index == 0:  # Bytes
        return f"{int(size_bytes)} {units[unit_index]}"
    else:
        # Use 2 decimal places for KB and higher
        return f"{size_bytes:.2f} {units[unit_index]}"

def register_filters(app):
    """
    Register all custom filters with the Flask app.

    Args:
        app: Flask application instance
    """
    app.register_blueprint(filters_bp)

</code>

web/app.py:
<code>
"""
Flask application for Bitarr.
"""
import os
from flask import Flask
from flask_socketio import SocketIO

# Create Socket.IO instance
socketio = SocketIO()

def create_app(test_config=None):
    """
    Create and configure the Flask application.

    Args:
        test_config: Test configuration

    Returns:
        Flask: Configured Flask application
    """
    # Create and configure the app
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_mapping(
        SECRET_KEY=os.environ.get('SECRET_KEY', 'dev'),
        DATABASE_PATH=os.path.join(app.instance_path, 'bitarr.db'),
    )

    if test_config is None:
        # Load the instance config, if it exists, when not testing
        app.config.from_pyfile('config.py', silent=True)
    else:
        # Load the test config if passed in
        app.config.from_mapping(test_config)

    # Ensure the instance folder exists
    try:
        os.makedirs(app.instance_path)
    except OSError:
        pass

    # Initialize extensions
    socketio.init_app(app, cors_allowed_origins="*")

    # Register custom template filters
    from .filters import register_filters
    register_filters(app)

    # Register blueprints
    from .routes import bp as routes_bp
    from .api import bp as api_bp
    from .api import db_api

    app.register_blueprint(routes_bp)
    app.register_blueprint(api_bp)
    app.register_blueprint(db_api)

    return app

</code>

web/routes.py:
<code>
"""
Routes for the Bitarr web application.
"""
from datetime import datetime
import json
import os
import platform
import psutil
from flask import (
    Blueprint, render_template, request, redirect, url_for,
    flash, jsonify, current_app, Response, stream_with_context
)
from werkzeug.exceptions import NotFound
import threading

from .app import socketio
from bitarr.db.db_manager import DatabaseManager
from bitarr.core.scanner import FileScanner, DeviceDetector
from bitarr.core.scanner.checksum import ChecksumCalculator

# Create blueprint
bp = Blueprint('routes', __name__)

# Create global objects
db = DatabaseManager()
device_detector = DeviceDetector()
active_scans = {}  # Store active scan threads

# Template filters
@bp.app_template_filter('format_size')
def format_size(size):
    """Format a size in bytes to a human-readable form."""
    if size is None:
        return "0 B"

    size = int(size)
    units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']
    unit_index = 0

    while size >= 1024 and unit_index < len(units) - 1:
        size /= 1024
        unit_index += 1

    return f"{size:.1f} {units[unit_index]}"

@bp.app_template_filter('thousands_separator')
def thousands_separator(value):
    """Add a thousands separator to a number."""
    if value is None:
        return "0"

    return f"{int(value):,}"

@bp.app_template_filter('from_json')
def from_json(value):
    """Convert a JSON string to a Python object."""
    if not value:
        return None

    try:
        return json.loads(value)
    except:
        return None

# Socket.IO progress handler
def handle_scan_progress(progress_data):
    """
    Handle scan progress updates.

    Args:
        progress_data: Progress data dictionary
    """
    socketio.emit('scan_progress', progress_data)

@bp.context_processor
def inject_now():
    """
    Inject the current datetime into all templates.
    """
    return {'now': datetime.now()}

@bp.route('/')
def index():
    """
    Home page / dashboard.
    """
    # Get recent scans
    recent_scans = db.get_recent_scans(limit=5)

    # Get storage devices
    devices = device_detector.detect_devices()

    # Get database info
    db_info = db.get_database_info()

    return render_template(
        'index.html',
        recent_scans=recent_scans,
        storage_devices=devices,
        active_scans=active_scans,
        db_info=db_info
    )

@bp.route('/scan_history')
def scan_history():
    """
    Scan history page.
    """
    # Get page parameters
    current_page = request.args.get('page', 1, type=int)
    page_size = 10

    # Get total count for pagination
    total_scans = db.count_scans()

    # Calculate offset
    offset = (current_page - 1) * page_size

    # Get paginated scans
    scans = db.get_recent_scans(limit=page_size, offset=offset)

    return render_template(
        'scan_history.html',
        scans=scans,
        total_scans=total_scans,
        current_page=current_page,
        page_size=page_size
    )

@bp.route('/scan_details/<int:scan_id>')
def scan_details(scan_id):
    """
    Scan detail page.

    Args:
        scan_id: ID of the scan
    """
    # Get scan details
    scan = db.get_scan(scan_id)
    if not scan:
        flash('Scan not found', 'error')
        return redirect(url_for('routes.scan_history'))

    # Get scan errors
    errors = db.get_scan_errors(scan_id)

    # Create scanner to get summary
    scanner = FileScanner(db)
    summary = scanner.get_scan_summary(scan_id)

    return render_template(
        'scan_details.html',
        scan=scan,
        summary=summary,
        errors=errors
    )

@bp.route('/scheduled_scans')
def scheduled_scans():
    """
    Scheduled scans page.
    """
    # Get all scheduled scans
    schedules = db.get_all_scheduled_scans()

    return render_template(
        'scheduled_scans.html',
        schedules=schedules,
        active_scans=active_scans,
        now=datetime.now()
    )

@bp.route('/storage_health')
def storage_health():
    """
    Storage health page.
    """
    # Get storage devices
    devices = device_detector.detect_devices()

    # Get database manager
    db_manager = DatabaseManager()

    # Get storage device health information
    device_health = {}
    for device in devices:
        device_id = device['device_id']
        storage_device = db_manager.get_storage_device(device_id=device_id)

        if storage_device:
            # Get file counts
            query = """
                SELECT c.status, COUNT(*) as count
                FROM checksums c
                JOIN files f ON c.file_id = f.id
                WHERE f.storage_device_id = ?
                GROUP BY c.status
            """
            params = (storage_device.id,)

            with db_manager.lock:
                conn = db_manager.get_connection()
                try:
                    cursor = conn.cursor()
                    cursor.execute(query, params)

                    status_counts = {}
                    for row in cursor.fetchall():
                        status_counts[row['status']] = row['count']

                    # Calculate corruption trend (dummy data for now)
                    trend = 0
                    if 'corrupted' in status_counts and status_counts['corrupted'] > 0:
                        # In a real implementation, we would compare with historical data
                        trend = 0.5  # Positive means increasing corruption

                    # Add corruption events (dummy data for now)
                    corruption_events = []
                    if 'corrupted' in status_counts and status_counts['corrupted'] > 0:
                        # In a real implementation, we would get actual corruption events
                        corruption_events = [
                            {
                                'date': '2025-05-15',
                                'corrupted_files': 3,
                                'path': device['mount_point'] + '/path/to/files',
                                'most_affected_directory': '/path/to/corruption',
                                'directory_corrupted_files': 2,
                                'scan_id': 1
                            }
                        ]

                    # Add to device health
                    device_health[device_id] = {
                        'storage_device': storage_device,
                        'status_counts': status_counts,
                        'trend': trend,
                        'corruption_events': corruption_events
                    }
                finally:
                    conn.close()

    return render_template(
        'storage_health.html',
        storage_devices=devices,
        device_health=device_health,
        now=datetime.now()
    )

@bp.route('/configuration')
def configuration():
    """
    Configuration page.
    """
    # Get all configuration values
    config = db.get_all_configuration()

    # Get available checksum algorithms
    calculator = ChecksumCalculator()
    algorithms = calculator.get_supported_algorithms()
    algo_info = calculator.algorithm_info()

    # Get system info
    system_info = {
        'os': platform.platform(),
        'python_version': platform.python_version(),
        'cpu_cores': os.cpu_count(),
        'memory': f"{psutil.virtual_memory().total / (1024**3):.1f} GB"
    }

    # App version and other metadata
    app_version = "1.0.0"  # Replace with actual version

    return render_template(
        'configuration.html',
        config=config,
        algorithms=algorithms,
        algo_info=algo_info,
        system_info=system_info,
        app_version=app_version,
        release_date="May 18, 2025",
        license="MIT"
    )

@bp.route('/database_management')
def database_management():
    """
    Database management page.
    """
    # Create database manager
    db_manager = DatabaseManager()

    # Get database info
    db_info = db_manager.get_database_info()

    # Get recent scans (for Manage Scans tab)
    scans = db_manager.get_recent_scans(limit=10)

    # Get total scan count
    total_scans = db_manager.count_scans()

    # Get storage devices
    from bitarr.core.scanner import DeviceDetector
    detector = DeviceDetector()
    storage_devices = detector.detect_devices()

    # Get active scans count
    active_scans_result = db_manager.check_for_active_scans()
    active_scan_count = 0
    active_scans = []
    if active_scans_result['success']:
        active_scan_count = active_scans_result['active_scan_count']
        active_scans = active_scans_result['active_scans']

    # Calculate storage statistics
    storage_stats = {}
    for device in storage_devices:
        device_id = device.get('device_id')

        # Skip devices without ID
        if not device_id:
            continue

        # Get storage device from database
        storage_device = db_manager.get_storage_device(device_id=device_id)

        if storage_device:
            # Calculate health and status
            health_score = 100  # Default to 100%
            health_status = "good"

            # In a real implementation, would query for corrupted files, etc.
            # For now, just use example data
            corrupted_files = 0
            missing_files = 0
            total_files = 0

            # Add to stats
            storage_stats[device_id] = {
                'health_score': health_score,
                'health_status': health_status,
                'corrupted_files': corrupted_files,
                'missing_files': missing_files,
                'total_files': total_files
            }

    # Get backup settings
    backup_settings = db_manager.get_backup_settings()

    # List backups
    backups_result = db_manager.list_backups()
    backups = []
    if backups_result['success']:
        backups = backups_result['backups']

    # Run integrity check
    integrity_result = db_manager.run_integrity_check()
    integrity_status = "unknown"
    if integrity_result['success']:
        integrity_status = integrity_result['integrity_status']

    # Check for disk space
    import shutil
    disk_space = {}
    try:
        db_path = db_manager.db_path
        disk_usage = shutil.disk_usage(os.path.dirname(db_path))
        disk_space = {
            'total': disk_usage.total,
            'used': disk_usage.used,
            'free': disk_usage.free,
            'percent_used': (disk_usage.used / disk_usage.total) * 100
        }
    except Exception as e:
        print(f"Error getting disk space: {str(e)}")

    # Get date of last vacuum
    last_vacuum = db_manager.get_configuration('last_vacuum_date')
    last_vacuum_date = None
    if last_vacuum and last_vacuum.value:
        last_vacuum_date = last_vacuum.value

    # Prepare database health metrics
    db_health = {
        'integrity_status': integrity_status,
        'integrity_check_date': db_manager.get_configuration('last_integrity_check_date'),
        'disk_usage_percent': disk_space.get('percent_used', 0),
        'disk_free': disk_space.get('free', 0),
        'disk_status': 'sufficient' if disk_space.get('percent_used', 0) < 80 else 'low',
        'vacuum_date': last_vacuum_date,
        'vacuum_status': 'recent' if last_vacuum_date else 'never',
        'missing_files': db_info.get('missing_files_count', 0),
        'missing_files_status': 'review_recommended' if db_info.get('missing_files_count', 0) > 0 else 'good'
    }

    # Calculate stats for tracked files
    file_stats = {
        'total': db_info.get('files_count', 0),
        'corrupted': db_info.get('corrupted_files_count', 0),
        'missing': db_info.get('missing_files_count', 0),
        'modified': db_info.get('modified_files_count', 0),
        'unchanged': db_info.get('unchanged_files_count', 0),
        'new': db_info.get('new_files_count', 0)
    }

    # Convert dates for better display
    from datetime import datetime, timezone
    if db_info.get('first_scan'):
        try:
            first_scan_date = datetime.fromisoformat(db_info['first_scan'].replace('Z', '+00:00'))
            db_info['first_scan_date'] = first_scan_date.strftime('%Y-%m-%d')
            # Calculate days since first scan
            days_since = (datetime.now(timezone.utc) - first_scan_date).days
            db_info['days_since_first_scan'] = days_since
        except Exception as e:
            print(f"Error formatting first scan date: {str(e)}")

    if db_info.get('last_scan'):
        try:
            last_scan_date = datetime.fromisoformat(db_info['last_scan'].replace('Z', '+00:00'))
            db_info['last_scan_date'] = last_scan_date.strftime('%Y-%m-%d')
            db_info['last_scan_time'] = last_scan_date.strftime('%H:%M')
        except Exception as e:
            print(f"Error formatting last scan date: {str(e)}")

    return render_template(
        'database_management.html',
        db_info=db_info,
        total_scans=total_scans,
        scans=scans,
        storage_devices=storage_devices,
        storage_stats=storage_stats,
        file_stats=file_stats,
        active_scan_count=active_scan_count,
        active_scans=active_scans,
        backup_settings=backup_settings,
        backups=backups,
        db_health=db_health
    )

@bp.route('/api/scan/start', methods=['POST'])
def api_scan_start():
    """
    API endpoint to start a scan.
    """
    # Get parameters from request
    try:
        data = request.get_json()
        path = data.get('path')
        name = data.get('name')
        algorithm = data.get('algorithm', 'sha256')
        threads = int(data.get('threads', 4))
        exclude_dirs = data.get('exclude_dirs', '').split(',') if data.get('exclude_dirs') else None
        exclude_patterns = data.get('exclude_patterns', '').split(',') if data.get('exclude_patterns') else None
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

    # Validate parameters
    if not path:
        return jsonify({'success': False, 'error': 'Path is required'}), 400

    if not os.path.exists(path):
        return jsonify({'success': False, 'error': f'Path does not exist: {path}'}), 400

    if not os.path.isdir(path):
        return jsonify({'success': False, 'error': f'Path is not a directory: {path}'}), 400

    # Create scanner
    scanner = FileScanner(db)

    # Add progress callback to report progress via Socket.IO
    scanner.add_progress_callback(handle_scan_progress)

    # Start scan in a background thread
    def run_scan():
        try:
            scan_id = scanner.scan(
                top_level_path=path,
                name=name,
                checksum_method=algorithm,
                threads=threads,
                exclude_dirs=exclude_dirs,
                exclude_patterns=exclude_patterns
            )

            # Remove from active scans when done
            if scan_id in active_scans:
                del active_scans[scan_id]

            # Emit completion event
            socketio.emit('scan_complete', {
                'scan_id': scan_id,
                'summary': scanner.get_scan_summary(scan_id)
            })
        except Exception as e:
            print(f"Scan error: {str(e)}")
            socketio.emit('scan_error', {
                'error': str(e)
            })

    scan_thread = threading.Thread(target=run_scan)
    scan_thread.daemon = True
    scan_thread.start()

    # Store the thread for status checking
    scan_id = scanner.current_scan.id
    active_scans[scan_id] = {
        'thread': scan_thread,
        'scanner': scanner,
        'start_time': datetime.now(),
        'path': path
    }

    return jsonify({
        'success': True,
        'scan_id': scan_id,
        'message': f'Scan started for {path}'
    })

@bp.route('/api/scan/stop/<int:scan_id>', methods=['POST'])
def api_scan_stop(scan_id):
    """
    API endpoint to stop a scan.

    Args:
        scan_id: ID of the scan to stop
    """
    global active_scans

    if scan_id not in active_scans:
        return jsonify({'success': False, 'error': 'Scan not found or already completed'}), 404

    # Stop the scan
    scanner = active_scans[scan_id]['scanner']
    scanner.stop()

    # Wait for the thread to finish
    active_scans[scan_id]['thread'].join(timeout=5)

    # Remove from active scans
    del active_scans[scan_id]

    return jsonify({
        'success': True,
        'message': f'Scan {scan_id} stopped'
    })

@bp.route('/api/scan/status/<int:scan_id>')
def api_scan_status(scan_id):
    """
    API endpoint to get scan status.

    Args:
        scan_id: ID of the scan
    """
    global active_scans

    if scan_id in active_scans:
        # Scan is running
        scanner = active_scans[scan_id]['scanner']
        return jsonify({
            'status': 'running',
            'scan_id': scan_id,
            'files_processed': scanner.files_processed,
            'total_files': scanner.total_files,
            'percent_complete': (scanner.files_processed / scanner.total_files * 100) if scanner.total_files > 0 else 0,
            'start_time': active_scans[scan_id]['start_time'].isoformat(),
            'path': active_scans[scan_id]['path']
        })

    # Check if scan exists in database
    scan = db.get_scan(scan_id)
    if not scan:
        return jsonify({'status': 'not_found'}), 404

    return jsonify({
        'status': scan.status,
        'scan_id': scan.id,
        'files_scanned': scan.files_scanned,
        'start_time': scan.start_time.isoformat() if scan.start_time else None,
        'end_time': scan.end_time.isoformat() if scan.end_time else None,
        'path': scan.top_level_path
    })

@bp.route('/api/devices')
def api_devices():
    """
    API endpoint to get storage devices.
    """
    devices = device_detector.detect_devices()
    return jsonify({'devices': devices})

# Database management API endpoints
@bp.route('/api/db/vacuum', methods=['POST'])
def api_db_vacuum():
    """API endpoint to vacuum the database."""
    try:
        db.vacuum()
        return jsonify({'success': True, 'message': 'Database vacuum completed successfully'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@bp.route('/api/db/reindex', methods=['POST'])
def api_db_reindex():
    """API endpoint to reindex the database."""
    try:
        db.reindex()
        return jsonify({'success': True, 'message': 'Database reindex completed successfully'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@bp.route('/api/db/reset', methods=['POST'])
def api_db_reset():
    """API endpoint to reset the database."""
    try:
        # Verification code from request
        data = request.get_json()
        confirmation = data.get('confirmation')

        if confirmation != 'RESET':
            return jsonify({'success': False, 'error': 'Invalid confirmation code'}), 400

        db.reset()
        return jsonify({'success': True, 'message': 'Database reset completed successfully'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@bp.route('/api/db/clear_old_scans', methods=['POST'])
def api_db_clear_old_scans():
    """API endpoint to clear old scans."""
    try:
        data = request.get_json()
        days = int(data.get('days', 30))

        count = db.clear_old_scans(days)
        return jsonify({'success': True, 'message': f'Cleared {count} old scans'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@bp.route('/api/db/purge_missing_files', methods=['POST'])
def api_db_purge_missing_files():
    """API endpoint to purge missing files."""
    try:
        data = request.get_json()
        days = int(data.get('days', 30))

        count = db.purge_missing_files(days)
        return jsonify({'success': True, 'message': f'Purged {count} missing files'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@bp.route('/api/db/backup', methods=['POST'])
def api_db_backup():
    """API endpoint to create a database backup."""
    try:
        data = request.get_json()
        name = data.get('name')

        backup_id = db.create_backup(name)
        return jsonify({'success': True, 'backup_id': backup_id, 'message': 'Backup created successfully'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@bp.route('/api/db/backup/<int:backup_id>/restore', methods=['POST'])
def api_db_restore(backup_id):
    """API endpoint to restore a database backup."""
    try:
        db.restore_backup(backup_id)
        return jsonify({'success': True, 'message': 'Backup restored successfully'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@bp.route('/api/db/backup/<int:backup_id>/delete', methods=['POST'])
def api_db_delete_backup(backup_id):
    """API endpoint to delete a database backup."""
    try:
        db.delete_backup(backup_id)
        return jsonify({'success': True, 'message': 'Backup deleted successfully'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

</code>

web/__main__.py:
<code>
"""
Main entry point for the web application.
"""
import os
import argparse
from bitarr.web import create_app, socketio
from bitarr.db.db_manager import DatabaseManager
from bitarr.db.init_db import init_db

def main():
    """
    Main entry point for the web application.
    """
    parser = argparse.ArgumentParser(description="Bitarr web application")
    parser.add_argument('--host', default='127.0.0.1', help='Host to bind to')
    parser.add_argument('--port', type=int, default=8286, help='Port to bind to')
    parser.add_argument('--debug', action='store_true', help='Enable debug mode')
    parser.add_argument('--init-db', action='store_true', help='Initialize the database')
    args = parser.parse_args()

    # Initialize database if requested
    if args.init_db:
        db_path = init_db()
        print(f"Database initialized at: {db_path}")

    # Get configuration from database
    try:
        db = DatabaseManager()
        config = db.get_all_configuration()

        # Override with configuration from database if available
        if 'web_ui_port' in config:
            args.port = int(config['web_ui_port'])
    except Exception as e:
        print(f"Warning: Could not load configuration from database: {str(e)}")

    # Create the app
    app = create_app()

    # Run the app
    socketio.run(app, host=args.host, port=args.port, debug=args.debug)

if __name__ == "__main__":
    main()

</code>

web/templates/storage_health.html:
<code>
{% extends 'layout.html' %}

{% block title %}Bitarr - Storage Health{% endblock %}

{% block content %}
<div class="storage-health">
    <h1>Storage Health</h1>

    <div class="device-filter-tabs">
        <button class="device-tab active" data-device="all">All Storage Devices</button>
        {% for device in storage_devices %}
            <button class="device-tab" data-device="{{ device.device_id }}">{{ device.name }}</button>
        {% endfor %}
    </div>

    <div class="card-grid">
        {% for device in storage_devices %}
            <div class="device-card" data-device-id="{{ device.device_id }}">
                <div class="card-header">
                    <div>
                        <h3 class="card-title">{{ device.name }}</h3>
                        <div class="card-subtitle">{{ device.device_type }} - {{ device.mount_point }}</div>
                    </div>

                    {% if device_health[device.device_id] and device_health[device.device_id].status_counts %}
                        {% set counts = device_health[device.device_id].status_counts %}
                        {% set total_files = counts.corrupted|default(0) + counts.missing|default(0) + counts.modified|default(0) + counts.unchanged|default(0) + counts.new|default(0) %}
                        {% set corruption_rate = (counts.corrupted|default(0) / total_files * 100) if total_files > 0 else 0 %}

                        {% if corruption_rate > 5 %}
                            <span class="status-indicator status-critical"></span>
                        {% elif corruption_rate > 1 %}
                            <span class="status-indicator status-warning"></span>
                        {% else %}
                            <span class="status-indicator status-good"></span>
                        {% endif %}
                    {% else %}
                        <span class="status-indicator status-good"></span>
                    {% endif %}
                </div>

                <div class="progress-bar-small">
                    {% if device_health[device.device_id] and device_health[device.device_id].status_counts %}
                        {% set counts = device_health[device.device_id].status_counts %}
                        {% set total_files = counts.corrupted|default(0) + counts.missing|default(0) + counts.modified|default(0) + counts.unchanged|default(0) + counts.new|default(0) %}
                        {% set corruption_rate = (counts.corrupted|default(0) / total_files * 100) if total_files > 0 else 0 %}

                        <div class="progress-fill {% if corruption_rate > 1 %}error-fill{% endif %}" style="width: {{ corruption_rate|round(1) }}%;"></div>
                    {% else %}
                        <div class="progress-fill" style="width: 0%;"></div>
                    {% endif %}
                </div>

                <div class="mini-stats">
                    <div class="mini-stat">
                        <div class="mini-stat-value">
                            {% if device_health[device.device_id] and device_health[device.device_id].status_counts %}
                                {% set counts = device_health[device.device_id].status_counts %}
                                {% set total_files = counts.corrupted|default(0) + counts.missing|default(0) + counts.modified|default(0) + counts.unchanged|default(0) + counts.new|default(0) %}
                                {% set corruption_rate = (counts.corrupted|default(0) / total_files * 100) if total_files > 0 else 0 %}
                                {{ corruption_rate|round(1) }}%
                            {% else %}
                                0.0%
                            {% endif %}
                        </div>
                        <div>Corruption Rate</div>
                    </div>

                    <div class="mini-stat">
                        <div class="mini-stat-value">
                            {% if device_health[device.device_id] and device_health[device.device_id].status_counts %}
                                {{ device_health[device.device_id].status_counts.corrupted|default(0)|thousands_separator }}
                            {% else %}
                                0
                            {% endif %}
                        </div>
                        <div>Corrupted Files</div>
                    </div>

                    <div class="mini-stat">
                        <div class="mini-stat-value">
                            {% if device_health[device.device_id] and device_health[device.device_id].status_counts %}
                                {{ device_health[device.device_id].status_counts.missing|default(0)|thousands_separator }}
                            {% else %}
                                0
                            {% endif %}
                        </div>
                        <div>Missing Files</div>
                    </div>
                </div>

                {% if device_health[device.device_id] and device_health[device.device_id].trend %}
                    <div style="margin-top: 15px;">
                        <div style="font-size: 14px; color: #6c757d;">
                            Corruption trend:
                            {% if device_health[device.device_id].trend > 0 %}
                                <span class="trend-indicator trend-up"> {{ device_health[device.device_id].trend|round(1) }}%</span>
                            {% elif device_health[device.device_id].trend < 0 %}
                                <span class="trend-indicator trend-down"> {{ (device_health[device.device_id].trend * -1)|round(1) }}%</span>
                            {% else %}
                                <span class="trend-indicator"> 0.0%</span>
                            {% endif %}
                            (last 30 days)
                        </div>
                    </div>
                {% endif %}

                <div class="device-actions" style="margin-top: 15px; text-align: right;">
                    <button class="btn small secondary view-device-btn" data-device-id="{{ device.device_id }}">View Details</button>
                </div>
            </div>
        {% endfor %}
    </div>

    <div class="section-title">Overall Health Trends</div>

    <div style="display: flex; gap: 20px; margin-bottom: 20px;">
        <div class="health-score" style="flex: 1;">
            <div class="score-label">Overall Health Score</div>

            {% set total_corrupted = 0 %}
            {% set total_missing = 0 %}
            {% set total_files = 0 %}

            {% for device_id, health in device_health.items() %}
                {% if health.status_counts %}
                    {% set counts = health.status_counts %}
                    {% set total_corrupted = total_corrupted + counts.corrupted|default(0) %}
                    {% set total_missing = total_missing + counts.missing|default(0) %}
                    {% set device_files = counts.corrupted|default(0) + counts.missing|default(0) + counts.modified|default(0) + counts.unchanged|default(0) + counts.new|default(0) %}
                    {% set total_files = total_files + device_files %}
                {% endif %}
            {% endfor %}

            {% set health_score = 100 - ((total_corrupted + total_missing) / total_files * 100) if total_files > 0 else 100 %}

            <div class="score-value
                {% if health_score > 95 %}good-score
                {% elif health_score > 80 %}warning-score
                {% else %}critical-score{% endif %}">
                {{ health_score|round(1) }}%
            </div>
            <div>Based on all storage devices</div>
        </div>

        <div style="flex: 3;">
            <div class="error-rate-chart">
                <!-- This will be replaced by a Chart.js chart -->
                <canvas id="corruptionRateChart" height="300"></canvas>
            </div>
        </div>
    </div>

    <div id="device-details-panel" class="details-panel" style="display: none;">
        <div class="details-header">
            <div>
                <h3 id="device-details-title">Storage Device Details</h3>
                <div id="device-details-subtitle" style="color: #6c757d;"></div>
            </div>
            <button class="btn secondary" id="runDiagnosticBtn">Run Full Diagnostic</button>
        </div>

        <div class="chart-container">
            <div style="flex: 1;">
                <h4>Corruption by File Type</h4>
                <div class="chart-container" style="height: 300px;">
                    <canvas id="fileTypeChart" height="300"></canvas>
                </div>
            </div>

            <div style="flex: 1;">
                <h4>Corruption by Directory</h4>
                <div class="chart-container" style="height: 300px;">
                    <canvas id="directoryChart" height="300"></canvas>
                </div>
            </div>
        </div>

        <div class="section-title">Recent Corruption Events</div>

        <div class="timeline" id="corruption-timeline">
            <!-- Timeline events will be populated dynamically -->
            <div class="empty-state" id="timeline-empty-state" style="display: none;">
                <div class="empty-state-icon"></div>
                <h3>No Corruption Events</h3>
                <p>No corruption events have been detected for this device.</p>
            </div>
        </div>

        <div style="margin-top: 20px;">
            <button class="btn secondary" id="viewFullHistoryBtn">View Full History</button>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize corruption rate chart
        initializeCorruptionRateChart();

        // Handle device tab selection
        const deviceTabs = document.querySelectorAll('.device-tab');
        const deviceCards = document.querySelectorAll('.device-card');
        const deviceDetailsPanel = document.getElementById('device-details-panel');

        deviceTabs.forEach(tab => {
            tab.addEventListener('click', function() {
                // Remove active class from all tabs
                deviceTabs.forEach(t => t.classList.remove('active'));

                // Add active class to clicked tab
                this.classList.add('active');

                // Get selected device ID
                const deviceId = this.dataset.device;

                // Show/hide device cards
                if (deviceId === 'all') {
                    deviceCards.forEach(card => card.style.display = '');
                    // Hide device details panel for "All Devices" view
                    if (deviceDetailsPanel) {
                        deviceDetailsPanel.style.display = 'none';
                    }
                } else {
                    deviceCards.forEach(card => {
                        if (card.dataset.deviceId === deviceId) {
                            card.style.display = '';
                        } else {
                            card.style.display = 'none';
                        }
                    });

                    // Show device details for the selected device
                    showDeviceDetails(deviceId);
                }
            });
        });

        // Handle "View Details" button clicks
        const viewDetailsButtons = document.querySelectorAll('.view-device-btn');
        viewDetailsButtons.forEach(button => {
            button.addEventListener('click', function() {
                const deviceId = this.dataset.deviceId;

                // Find and click the corresponding device tab
                const deviceTab = document.querySelector(`.device-tab[data-device="${deviceId}"]`);
                if (deviceTab) {
                    deviceTab.click();
                }
            });
        });

        // Run diagnostic button
        const runDiagnosticBtn = document.getElementById('runDiagnosticBtn');
        if (runDiagnosticBtn) {
            runDiagnosticBtn.addEventListener('click', function() {
                alert('Diagnostic functionality will be implemented in a future update.');
            });
        }

        // View full history button
        const viewFullHistoryBtn = document.getElementById('viewFullHistoryBtn');
        if (viewFullHistoryBtn) {
            viewFullHistoryBtn.addEventListener('click', function() {
                alert('Full history view will be implemented in a future update.');
            });
        }

        // Function to show device details
        function showDeviceDetails(deviceId) {
            if (!deviceDetailsPanel) return;

            // Show the details panel
            deviceDetailsPanel.style.display = 'block';

            // Find the device card for this ID
            const deviceCard = document.querySelector(`.device-card[data-device-id="${deviceId}"]`);
            if (!deviceCard) return;

            // Update the details panel with device information
            const deviceTitle = document.getElementById('device-details-title');
            const deviceSubtitle = document.getElementById('device-details-subtitle');

            if (deviceTitle && deviceSubtitle) {
                // Get device name and subtitle from the card
                const cardTitle = deviceCard.querySelector('.card-title');
                const cardSubtitle = deviceCard.querySelector('.card-subtitle');

                deviceTitle.textContent = cardTitle ? cardTitle.textContent : 'Device Details';
                deviceSubtitle.textContent = cardSubtitle ? cardSubtitle.textContent : '';
            }

            // Initialize charts for this device
            initializeDeviceCharts(deviceId);

            // Show/hide timeline based on whether there are corruption events
            const timelineEmptyState = document.getElementById('timeline-empty-state');
            const corruptionTimeline = document.getElementById('corruption-timeline');

            if (timelineEmptyState && corruptionTimeline) {
                const hasCorruptionEvents = deviceCard.querySelector('.mini-stat-value:nth-child(1)').textContent.trim() !== '0.0%';

                // Clear existing timeline events
                Array.from(corruptionTimeline.children).forEach(child => {
                    if (!child.id || child.id !== 'timeline-empty-state') {
                        child.remove();
                    }
                });

                if (hasCorruptionEvents) {
                    timelineEmptyState.style.display = 'none';

                    // Add some example timeline events
                    addTimelineEvents(corruptionTimeline, deviceId);
                } else {
                    timelineEmptyState.style.display = 'block';
                }
            }
        }

        // Add example timeline events (would be replaced with real data)
        function addTimelineEvents(timeline, deviceId) {
            // In a real implementation, this would get data from the server
            const events = [
                {
                    date: '2025-05-17',
                    count: 82,
                    path: '/home/user/projects',
                    directory: '/components/assets/images',
                    dirCount: 72
                },
                {
                    date: '2025-05-10',
                    count: 54,
                    path: '/home/user/documents',
                    directory: '/2025/Q1/Financial',
                    dirCount: 48
                }
            ];

            events.forEach(event => {
                const timelineItem = document.createElement('div');
                timelineItem.className = 'timeline-item';

                const timelineDate = document.createElement('div');
                timelineDate.className = 'timeline-date';
                timelineDate.textContent = event.date;

                const timelineContent = document.createElement('div');
                timelineContent.className = 'timeline-content';
                timelineContent.innerHTML = `
                    <strong>${event.count} new corrupted files detected</strong> in scan of ${event.path}
                    <div style="margin-top: 10px; font-size: 14px; color: #6c757d;">
                        Most affected directory: ${event.directory} (${event.dirCount} files)
                    </div>
                    <div style="margin-top: 10px;">
                        <button class="btn secondary">View Details</button>
                    </div>
                `;

                timelineItem.appendChild(timelineDate);
                timelineItem.appendChild(timelineContent);

                timeline.appendChild(timelineItem);
            });
        }

        // Initialize device charts
        function initializeDeviceCharts(deviceId) {
            // Initialize file type chart
            initializeFileTypeChart(deviceId);

            // Initialize directory chart
            initializeDirectoryChart(deviceId);
        }

        // Initialize corruption rate chart
        function initializeCorruptionRateChart() {
            const ctx = document.getElementById('corruptionRateChart');
            if (!ctx) return;

            // Get current date
            const now = new Date();

            // Create labels for the last 7 days
            const labels = [];
            for (let i = 6; i >= 0; i--) {
                const date = new Date(now);
                date.setDate(date.getDate() - i);
                labels.push(date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
            }

            // Create chart
            new Chart(ctx.getContext('2d'), {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Overall Corruption Rate (%)',
                        data: [1.2, 1.3, 1.5, 1.4, 1.7, 1.9, 2.1], // Example data
                        borderColor: '#dc3545',
                        backgroundColor: 'rgba(220, 53, 69, 0.1)',
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.raw + '%';
                                }
                            }
                        }
                    }
                }
            });
        }

        // Initialize file type chart
        function initializeFileTypeChart(deviceId) {
            const ctx = document.getElementById('fileTypeChart');
            if (!ctx) return;

            // In a real implementation, this would get data specific to the device
            // For now, using example data
            new Chart(ctx.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: ['Images', 'Documents', 'Videos', 'Code', 'Other'],
                    datasets: [{
                        label: 'Corrupted Files by Type',
                        data: [42, 15, 8, 3, 12], // Example data
                        backgroundColor: [
                            '#4a6cf7',
                            '#28a745',
                            '#dc3545',
                            '#ffc107',
                            '#6c757d'
                        ],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Corrupted Files'
                            }
                        }
                    }
                }
            });
        }

        // Initialize directory chart
        function initializeDirectoryChart(deviceId) {
            const ctx = document.getElementById('directoryChart');
            if (!ctx) return;

            // In a real implementation, this would get data specific to the device
            // For now, using example data
            new Chart(ctx.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: ['/images', '/documents', '/videos', '/code', '/other'],
                    datasets: [{
                        label: 'Corrupted Files by Directory',
                        data: [35, 12, 6, 2, 3], // Example data
                        backgroundColor: [
                            '#4a6cf7',
                            '#28a745',
                            '#dc3545',
                            '#ffc107',
                            '#6c757d'
                        ],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Corrupted Files'
                            }
                        }
                    }
                }
            });
        }
    });
</script>
{% endblock %}

</code>

web/templates/scan_details.html:
<code>
{% extends 'layout.html' %}

{% block title %}Bitarr - Scan Details{% endblock %}

{% block content %}
<div class="scan-details">
    <div class="page-header">
        <h1>Scan Details</h1>
        <div class="actions">
            <button class="btn secondary" onclick="history.back()">Back to Scan History</button>
            <button class="btn primary rescan-btn" data-path="{{ scan.top_level_path }}">Rescan Path</button>
        </div>
    </div>

    <div class="details-panel">
        <div class="details-header">
            <h2>{{ scan.name or 'Scan of ' + scan.top_level_path }}</h2>
            <div class="scan-meta">
                <div class="meta-item">
                    <span class="meta-label">Date:</span>
                    <span class="meta-value time-ago" data-timestamp="{{ scan.start_time }}">{{ scan.start_time }}</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Status:</span>
                    <span class="meta-value">
                        {% if scan.status == 'completed' %}
                            {% if scan.files_corrupted > 0 %}
                                <span class="status-indicator status-critical"></span> Critical
                            {% elif scan.files_missing > 0 %}
                                <span class="status-indicator status-warning"></span> Warning
                            {% else %}
                                <span class="status-indicator status-good"></span> Good
                            {% endif %}
                        {% elif scan.status == 'running' %}
                            <span class="status-indicator status-running"></span> Running
                        {% elif scan.status == 'failed' %}
                            <span class="status-indicator status-critical"></span> Failed
                        {% else %}
                            <span class="status-indicator status-warning"></span> {{ scan.status|title }}
                        {% endif %}
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Duration:</span>
                    <span class="meta-value">
                        {% if scan.end_time %}
                            {{ ((scan.end_time - scan.start_time).total_seconds() / 60)|round(1) }} minutes
                        {% else %}
                            In progress
                        {% endif %}
                    </span>
                </div>
            </div>
        </div>

        <div class="chart-container">
            <div class="pie-chart-container">
                <canvas id="fileStatusChart" width="180" height="180"></canvas>
                <div class="chart-legend">
                    <div class="legend-item">
                        <div class="legend-color unchanged-color"></div>
                        <div>{{ scan.files_unchanged|default(0)|thousands_separator }} Unchanged ({{ ((scan.files_unchanged|default(0) / scan.files_scanned|default(1)) * 100)|round(1) }}%)</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color modified-color"></div>
                        <div>{{ scan.files_modified|default(0)|thousands_separator }} Modified ({{ ((scan.files_modified|default(0) / scan.files_scanned|default(1)) * 100)|round(1) }}%)</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color corrupted-color"></div>
                        <div>{{ scan.files_corrupted|default(0)|thousands_separator }} Corrupted ({{ ((scan.files_corrupted|default(0) / scan.files_scanned|default(1)) * 100)|round(1) }}%)</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color missing-color"></div>
                        <div>{{ scan.files_missing|default(0)|thousands_separator }} Missing ({{ ((scan.files_missing|default(0) / scan.files_scanned|default(1)) * 100)|round(1) }}%)</div>
                    </div>
                    {% if scan.files_new %}
                    <div class="legend-item">
                        <div class="legend-color new-color"></div>
                        <div>{{ scan.files_new|thousands_separator }} New ({{ ((scan.files_new / scan.files_scanned|default(1)) * 100)|round(1) }}%)</div>
                    </div>
                    {% endif %}
                </div>
            </div>

            <div class="scan-summary">
                <h3>Scan Summary</h3>

                {% if scan.files_corrupted > 0 or scan.files_missing > 0 %}
                    <p>This scan detected <strong>{{ scan.files_corrupted }} potentially corrupted files</strong> and <strong>{{ scan.files_missing }} missing files</strong> compared to previous scans.</p>

                    {% if summary and summary.corruption_by_directory %}
                        <p>Most corruption was found in the <code>{{ summary.corruption_by_directory[0].directory }}</code> directory.</p>
                    {% endif %}
                {% else %}
                    <p>No file corruption or missing files detected in this scan.</p>
                {% endif %}

                {% if summary and summary.storage_devices %}
                    <p><strong>Storage Devices Involved:</strong> {{ summary.storage_devices|length }} devices detected in this scan:</p>
                    <ul class="device-list">
                        {% for device in summary.storage_devices %}
                            <li>
                                <strong>{{ device.name }}</strong> -
                                {% if device.corrupted_files %}{{ device.corrupted_files }}{% else %}0{% endif %} corrupted files,
                                {% if device.missing_files %}{{ device.missing_files }}{% else %}0{% endif %} missing files
                            </li>
                        {% endfor %}
                    </ul>
                {% endif %}

                <p>
                    The scan was completed in
                    {% if scan.end_time %}
                        {{ ((scan.end_time - scan.start_time).total_seconds() / 60)|round(1) }} minutes
                    {% else %}
                        (in progress)
                    {% endif %}.
                    Total space occupied by scanned files: {{ summary.total_size|default(0)|format_size }}.
                </p>

                {% if scan.error_message %}
                    <div class="error-message">
                        <h4>Error Message</h4>
                        <p>{{ scan.error_message }}</p>
                    </div>
                {% endif %}
            </div>
        </div>

        <div class="tabs">
            <button class="tab-button active" data-tab="all-files">All Files</button>
            {% if scan.files_corrupted > 0 %}
                <button class="tab-button" data-tab="corrupted-files">Corrupted Files</button>
            {% endif %}
            {% if scan.files_missing > 0 %}
                <button class="tab-button" data-tab="missing-files">Missing Files</button>
            {% endif %}
            {% if scan.files_modified > 0 %}
                <button class="tab-button" data-tab="modified-files">Modified Files</button>
            {% endif %}
            {% if errors %}
                <button class="tab-button" data-tab="errors">Errors ({{ errors|length }})</button>
            {% endif %}
        </div>

        <div class="tab-content" id="all-files">
            <div class="controls">
                <div class="search-container">
                    <input type="text" class="search-filter" placeholder="Filter files...">
                </div>
                <div class="filter-buttons">
                    <button class="btn small secondary filter-btn" data-filter="all">All</button>
                    <button class="btn small secondary filter-btn" data-filter="corrupted">Corrupted</button>
                    <button class="btn small secondary filter-btn" data-filter="missing">Missing</button>
                    <button class="btn small secondary filter-btn" data-filter="modified">Modified</button>
                    <button class="btn small secondary filter-btn" data-filter="unchanged">Unchanged</button>
                </div>
            </div>

            <div class="table-container files-table">
                <table>
                    <thead>
                        <tr>
                            <th>Status</th>
                            <th>Path / Filename</th>
                            <th>Storage Device</th>
                            <th>Size</th>
                            <th>Last Modified</th>
                            <th>Checksum</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% if summary.files %}
                            {% for file in summary.files %}
                                <tr class="file-row {{ file.status }}-row">
                                    <td>
                                        {% if file.status == 'corrupted' %}
                                            <span class="status-indicator status-critical"></span> Corrupted
                                        {% elif file.status == 'missing' %}
                                            <span class="status-indicator status-warning"></span> Missing
                                        {% elif file.status == 'modified' %}
                                            <span class="status-indicator status-good"></span> Modified
                                        {% elif file.status == 'unchanged' %}
                                            <span class="status-indicator status-good"></span> Unchanged
                                        {% elif file.status == 'new' %}
                                            <span class="status-indicator status-good"></span> New
                                        {% endif %}
                                    </td>
                                    <td class="file-path">{{ file.path }}</td>
                                    <td>{{ file.device_name }}</td>
                                    <td class="file-size" data-size="{{ file.size }}">
                                        {{ file.size|format_size }}
                                    </td>
                                    <td class="time-ago" data-timestamp="{{ file.last_modified }}">
                                        {{ file.last_modified }}
                                    </td>
                                    <td class="checksum">
                                        <span class="monospace">{{ file.checksum_value[:10] }}...</span>
                                        {% if file.status == 'corrupted' %}
                                            <br>
                                            <span class="monospace previous">(was: {{ file.previous_checksum[:10] }}...)</span>
                                        {% endif %}
                                    </td>
                                </tr>
                            {% endfor %}
                        {% else %}
                            <tr>
                                <td colspan="6" class="no-data">File details not available</td>
                            </tr>
                        {% endif %}
                    </tbody>
                </table>
            </div>

            <div class="pagination-controls">
                <div class="page-info">
                    Showing <span id="showingStart">1</span>-<span id="showingEnd">{{ summary.files|default([])|length }}</span> of <span id="totalFiles">{{ scan.files_scanned }}</span> files
                </div>
                <div>
                    <button id="loadMoreBtn" class="btn secondary">Load More Files</button>
                </div>
            </div>
        </div>

        {% if scan.files_corrupted > 0 %}
            <div class="tab-content" id="corrupted-files" style="display: none;">
                <div class="table-container files-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Path / Filename</th>
                                <th>Storage Device</th>
                                <th>Size</th>
                                <th>Last Modified</th>
                                <th>Current Checksum</th>
                                <th>Previous Checksum</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% if summary.files %}
                                {% for file in summary.files if file.status == 'corrupted' %}
                                    <tr>
                                        <td class="file-path">{{ file.path }}</td>
                                        <td>{{ file.device_name }}</td>
                                        <td class="file-size" data-size="{{ file.size }}">
                                            {{ file.size|format_size }}
                                        </td>
                                        <td class="time-ago" data-timestamp="{{ file.last_modified }}">
                                            {{ file.last_modified }}
                                        </td>
                                        <td class="checksum monospace">{{ file.checksum_value }}</td>
                                        <td class="checksum monospace">{{ file.previous_checksum }}</td>
                                    </tr>
                                {% else %}
                                    <tr>
                                        <td colspan="6" class="no-data">No corrupted files found</td>
                                    </tr>
                                {% endfor %}
                            {% else %}
                                <tr>
                                    <td colspan="6" class="no-data">File details not available</td>
                                </tr>
                            {% endif %}
                        </tbody>
                    </table>
                </div>
            </div>
        {% endif %}

        {% if scan.files_missing > 0 %}
            <div class="tab-content" id="missing-files" style="display: none;">
                <div class="table-container files-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Path / Filename</th>
                                <th>Storage Device</th>
                                <th>Last Known Size</th>
                                <th>Last Modified</th>
                                <th>Previous Checksum</th>
                                <th>Last Seen</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% if summary.files %}
                                {% for file in summary.files if file.status == 'missing' %}
                                    <tr>
                                        <td class="file-path">{{ file.path }}</td>
                                        <td>{{ file.device_name }}</td>
                                        <td class="file-size" data-size="{{ file.size }}">
                                            {{ file.size|format_size }}
                                        </td>
                                        <td class="time-ago" data-timestamp="{{ file.last_modified }}">
                                            {{ file.last_modified }}
                                        </td>
                                        <td class="checksum monospace">{{ file.previous_checksum }}</td>
                                        <td class="time-ago" data-timestamp="{{ file.last_seen }}">
                                            {{ file.last_seen }}
                                        </td>
                                    </tr>
                                {% else %}
                                    <tr>
                                        <td colspan="6" class="no-data">No missing files found</td>
                                    </tr>
                                {% endfor %}
                            {% else %}
                                <tr>
                                    <td colspan="6" class="no-data">File details not available</td>
                                </tr>
                            {% endif %}
                        </tbody>
                    </table>
                </div>
            </div>
        {% endif %}

        {% if scan.files_modified > 0 %}
            <div class="tab-content" id="modified-files" style="display: none;">
                <div class="table-container files-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Path / Filename</th>
                                <th>Storage Device</th>
                                <th>Size</th>
                                <th>Last Modified</th>
                                <th>Current Checksum</th>
                                <th>Previous Checksum</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% if summary.files %}
                                {% for file in summary.files if file.status == 'modified' %}
                                    <tr>
                                        <td class="file-path">{{ file.path }}</td>
                                        <td>{{ file.device_name }}</td>
                                        <td class="file-size" data-size="{{ file.size }}">
                                            {{ file.size|format_size }}
                                        </td>
                                        <td class="time-ago" data-timestamp="{{ file.last_modified }}">
                                            {{ file.last_modified }}
                                        </td>
                                        <td class="checksum monospace">{{ file.checksum_value }}</td>
                                        <td class="checksum monospace">{{ file.previous_checksum }}</td>
                                    </tr>
                                {% else %}
                                    <tr>
                                        <td colspan="6" class="no-data">No modified files found</td>
                                    </tr>
                                {% endfor %}
                            {% else %}
                                <tr>
                                    <td colspan="6" class="no-data">File details not available</td>
                                </tr>
                            {% endif %}
                        </tbody>
                    </table>
                </div>
            </div>
        {% endif %}

        {% if errors %}
            <div class="tab-content" id="errors" style="display: none;">
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Time</th>
                                <th>File Path</th>
                                <th>Error Type</th>
                                <th>Error Message</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for error in errors %}
                                <tr>
                                    <td class="time-ago" data-timestamp="{{ error.timestamp }}">
                                        {{ error.timestamp }}
                                    </td>
                                    <td class="file-path">{{ error.file_path }}</td>
                                    <td>{{ error.error_type }}</td>
                                    <td>{{ error.error_message }}</td>
                                </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
        {% endif %}

        <div class="actions">
            <button class="btn secondary" id="exportReportBtn">Export Report</button>
            <button class="btn primary rescan-btn" data-path="{{ scan.top_level_path }}">Rescan This Path</button>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Create pie chart for file status
        initializeFileStatusChart();

        // Handle tab switching
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        tabButtons.forEach(button => {
            button.addEventListener('click', function() {
                // Remove active class from all buttons
                tabButtons.forEach(btn => btn.classList.remove('active'));

                // Add active class to clicked button
                this.classList.add('active');

                // Hide all tab contents
                tabContents.forEach(content => content.style.display = 'none');

                // Show the selected tab content
                const tabId = this.dataset.tab;
                document.getElementById(tabId).style.display = 'block';
            });
        });

        // Handle file filtering
        const fileSearchFilter = document.querySelector('.search-filter');
        const fileRows = document.querySelectorAll('.file-row');

        if (fileSearchFilter) {
            fileSearchFilter.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase();

                fileRows.forEach(row => {
                    const filePath = row.querySelector('.file-path').textContent.toLowerCase();

                    if (filePath.includes(searchTerm)) {
                        row.style.display = '';
                    } else {
                        row.style.display = 'none';
                    }
                });

                // Update pagination info
                updateFilesPaginationInfo();
            });
        }

        // Handle filter buttons
        const filterButtons = document.querySelectorAll('.filter-btn');

        filterButtons.forEach(button => {
            button.addEventListener('click', function() {
                const filter = this.dataset.filter;

                // Remove active class from all filter buttons
                filterButtons.forEach(btn => btn.classList.remove('active'));

                // Add active class to clicked button
                this.classList.add('active');

                if (filter === 'all') {
                    // Show all rows
                    fileRows.forEach(row => row.style.display = '');
                } else {
                    // Show only rows with the selected status
                    fileRows.forEach(row => {
                        if (row.classList.contains(`${filter}-row`)) {
                            row.style.display = '';
                        } else {
                            row.style.display = 'none';
                        }
                    });
                }

                // Update pagination info
                updateFilesPaginationInfo();
            });
        });

        // Handle rescan buttons
        const rescanButtons = document.querySelectorAll('.rescan-btn');

        rescanButtons.forEach(button => {
            button.addEventListener('click', function() {
                const path = this.dataset.path;

                // Open new scan modal with path pre-filled
                const newScanModal = document.getElementById('newScanModal');
                const scanPathInput = document.getElementById('scanPath');

                if (newScanModal && scanPathInput) {
                    scanPathInput.value = path;
                    openModal(newScanModal);
                }
            });
        });

        // Handle export report button
        const exportReportBtn = document.getElementById('exportReportBtn');

        if (exportReportBtn) {
            exportReportBtn.addEventListener('click', function() {
                // TODO: Implement report export
                alert('Export functionality will be implemented in a future update.');
            });
        }

        // Handle loading more files
        const loadMoreBtn = document.getElementById('loadMoreBtn');

        if (loadMoreBtn) {
            loadMoreBtn.addEventListener('click', function() {
                // TODO: Implement loading more files

                // For now, just show a message
                alert('Loading more files will be implemented in a future update.');
            });
        }

        // Helper function to update files pagination info
        function updateFilesPaginationInfo() {
            const showingStart = document.getElementById('showingStart');
            const showingEnd = document.getElementById('showingEnd');
            const totalFiles = document.getElementById('totalFiles');

            if (showingStart && showingEnd && totalFiles) {
                const visibleRows = document.querySelectorAll('.file-row:not([style*="display: none"])');
                showingStart.textContent = visibleRows.length > 0 ? 1 : 0;
                showingEnd.textContent = visibleRows.length;
                // Keep total the same
            }
        }

        // Helper function to open a modal
        function openModal(modal) {
            if (modal) {
                modal.style.display = 'flex';
            }
        }

        // Function to initialize file status chart
        function initializeFileStatusChart() {
            const ctx = document.getElementById('fileStatusChart');
            if (!ctx) return;

            // Get chart data from the template
            const unchangedCount = {{ scan.files_unchanged|default(0) }};
            const modifiedCount = {{ scan.files_modified|default(0) }};
            const corruptedCount = {{ scan.files_corrupted|default(0) }};
            const missingCount = {{ scan.files_missing|default(0) }};
            const newCount = {{ scan.files_new|default(0) }};

            // Create data array (exclude categories with 0 count)
            const labels = [];
            const data = [];
            const backgroundColor = [];

            if (unchangedCount > 0) {
                labels.push('Unchanged');
                data.push(unchangedCount);
                backgroundColor.push('#28a745');
            }

            if (modifiedCount > 0) {
                labels.push('Modified');
                data.push(modifiedCount);
                backgroundColor.push('#1565c0');
            }

            if (corruptedCount > 0) {
                labels.push('Corrupted');
                data.push(corruptedCount);
                backgroundColor.push('#c62828');
            }

            if (missingCount > 0) {
                labels.push('Missing');
                data.push(missingCount);
                backgroundColor.push('#616161');
            }

            if (newCount > 0) {
                labels.push('New');
                data.push(newCount);
                backgroundColor.push('#00838f');
            }

            // Create the chart
            new Chart(ctx.getContext('2d'), {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: backgroundColor,
                        borderWidth: 0
                    }]
                },
                options: {
                    cutout: '50%',
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.raw || 0;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = Math.round((value / total) * 100);
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    },
                    responsive: true,
                    maintainAspectRatio: false
                }
            });
        }
    });
</script>
{% endblock %}

</code>

web/templates/index.html:
<code>
{% extends 'layout.html' %}

{% block title %}Bitarr - Dashboard{% endblock %}

{% block content %}
<div class="dashboard">
    <h1>Dashboard</h1>

    <div class="grid grid-4">
        <div class="stats-card">
            <div class="stats-title">Total Files</div>
            <div class="stats-value">{{ db_info.files_count|default(0) }}</div>
            <div class="stats-subtitle">Being monitored</div>
        </div>

        <div class="stats-card">
            <div class="stats-title">Storage Devices</div>
            <div class="stats-value">{{ storage_devices|length }}</div>
            <div class="stats-subtitle">Connected devices</div>
        </div>

        <div class="stats-card">
            <div class="stats-title">Scans Performed</div>
            <div class="stats-value">{{ db_info.scans_count|default(0) }}</div>
            <div class="stats-subtitle">Total scans</div>
        </div>

        <div class="stats-card">
            <div class="stats-title">Last Scan</div>
            <div class="stats-value time-ago" data-timestamp="{{ db_info.last_scan }}">
                {% if db_info.last_scan %}
                    {{ db_info.last_scan|default('Never') }}
                {% else %}
                    Never
                {% endif %}
            </div>
            <div class="stats-subtitle">Time since last scan</div>
        </div>
    </div>

    <div class="grid grid-2" style="margin-top: 20px;">
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">Recent Scans</h2>
                <a href="{{ url_for('routes.scan_history') }}" class="btn outline primary">View All</a>
            </div>
            <div class="card-body">
                {% if recent_scans %}
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Status</th>
                                    <th>Date</th>
                                    <th>Path</th>
                                    <th>Files</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for scan in recent_scans %}
                                <tr onclick="window.location.href='{{ url_for('routes.scan_details', scan_id=scan.id) }}'">
                                    <td>
                                        {% if scan.status == 'completed' %}
                                            {% if scan.files_corrupted > 0 or scan.files_missing > 0 %}
                                                <span class="badge badge-warning">Warning</span>
                                            {% else %}
                                                <span class="badge badge-success">Success</span>
                                            {% endif %}
                                        {% elif scan.status == 'running' %}
                                            <span class="badge badge-info">Running</span>
                                        {% elif scan.status == 'failed' %}
                                            <span class="badge badge-danger">Failed</span>
                                        {% else %}
                                            <span class="badge badge-secondary">{{ scan.status }}</span>
                                        {% endif %}
                                    </td>
                                    <td class="time-ago" data-timestamp="{{ scan.start_time }}">
                                        {{ scan.start_time }}
                                    </td>
                                    <td>{{ scan.top_level_path }}</td>
                                    <td>{{ scan.files_scanned }}</td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                {% else %}
                    <p>No scans performed yet. Click "New Scan" to get started.</p>
                {% endif %}
            </div>
        </div>

        <div class="card">
            <div class="card-header">
                <h2 class="card-title">Storage Devices</h2>
                <a href="{{ url_for('routes.storage_health') }}" class="btn outline primary">View Health</a>
            </div>
            <div class="card-body">
                {% if storage_devices %}
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Name</th>
                                    <th>Type</th>
                                    <th>Size</th>
                                    <th>Used</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for device in storage_devices %}
                                <tr>
                                    <td>{{ device.name }}</td>
                                    <td>{{ device.device_type }}</td>
                                    <td class="file-size" data-size="{{ device.total_size }}">
                                        {{ device.total_size }}
                                    </td>
                                    <td>
                                        <div class="progress-bar" style="width: 100%; margin: 0;">
                                            <div class="progress-fill" style="width: {{ device.usage_percent }}%;"></div>
                                        </div>
                                        {{ device.usage_percent|round(1) }}%
                                    </td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                {% else %}
                    <p>No storage devices detected. Please check your system configuration.</p>
                {% endif %}
            </div>
        </div>
    </div>

    <div class="card" style="margin-top: 20px;">
        <div class="card-header">
            <h2 class="card-title">Quick Start</h2>
        </div>
        <div class="card-body">
            <p>Welcome to Bitarr! Here's how to get started:</p>

            <ol>
                <li><strong>Perform a Scan</strong> - Click the "New Scan" button to select a directory to scan.</li>
                <li><strong>View Results</strong> - After the scan completes, view the results to see file integrity status.</li>
                <li><strong>Schedule Regular Scans</strong> - Set up scheduled scans to monitor your files automatically.</li>
                <li><strong>Check Storage Health</strong> - Monitor the health of your storage devices over time.</li>
            </ol>

            <p>Bitarr helps you detect file corruption, unauthorized modifications, and missing files across your storage devices.</p>
        </div>
        <div class="card-footer">
            <button id="quickStartScan" class="btn primary">Start Your First Scan</button>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Quick start scan button
    document.getElementById('quickStartScan').addEventListener('click', () => {
        document.getElementById('newScanButton').click();
    });
</script>
{% endblock %}

</code>

web/templates/layout.html:
<code>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Bitarr{% endblock %}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link rel="icon" href="{{ url_for('static', filename='img/favicon.ico') }}">
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    {% block head %}{% endblock %}
</head>
<body>
    <div class="app-container">
        <header class="app-header">
            <div class="header-left">
                <button id="menuToggle" class="menu-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <h1 class="app-title">Bitarr</h1>
            </div>
            <div class="header-right">
                <button id="newScanButton" class="btn primary">New Scan</button>
            </div>
        </header>

        <div class="app-body">
            <nav class="app-nav">
                <ul>
                    <li {% if request.path == url_for('routes.index') %}class="active"{% endif %}>
                        <a href="{{ url_for('routes.index') }}">
                            <span class="icon"></span>
                            <span class="text">Dashboard</span>
                        </a>
                    </li>
                    <li {% if request.path == url_for('routes.scan_history') %}class="active"{% endif %}>
                        <a href="{{ url_for('routes.scan_history') }}">
                            <span class="icon"></span>
                            <span class="text">Scan History</span>
                        </a>
                    </li>
                    <li {% if request.path == url_for('routes.storage_health') %}class="active"{% endif %}>
                        <a href="{{ url_for('routes.storage_health') }}">
                            <span class="icon"></span>
                            <span class="text">Storage Health</span>
                        </a>
                    </li>
                    <li {% if request.path == url_for('routes.scheduled_scans') %}class="active"{% endif %}>
                        <a href="{{ url_for('routes.scheduled_scans') }}">
                            <span class="icon"></span>
                            <span class="text">Scheduled Scans</span>
                        </a>
                    </li>
                    <li {% if request.path == url_for('routes.configuration') %}class="active"{% endif %}>
                        <a href="{{ url_for('routes.configuration') }}">
                            <span class="icon"></span>
                            <span class="text">Configuration</span>
                        </a>
                    </li>
                    <li {% if request.path == url_for('routes.database_management') %}class="active"{% endif %}>
                        <a href="{{ url_for('routes.database_management') }}">
                            <span class="icon"></span>
                            <span class="text">Database</span>
                        </a>
                    </li>
                </ul>
            </nav>

            <main class="app-main">
                {% with messages = get_flashed_messages(with_categories=true) %}
                    {% if messages %}
                        <div class="flash-messages">
                            {% for category, message in messages %}
                                <div class="flash-message {{ category }}">
                                    {{ message }}
                                </div>
                            {% endfor %}
                        </div>
                    {% endif %}
                {% endwith %}

                <div class="content">
                    {% block content %}{% endblock %}
                </div>
            </main>
        </div>

        <footer class="app-footer">
            <p>&copy; 2025 Bitarr - File Integrity Scanner</p>
        </footer>
    </div>

    <!-- New Scan Modal -->
    <div id="newScanModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>New Scan</h2>
                <button class="close-button">&times;</button>
            </div>
            <div class="modal-body">
                <form id="newScanForm">
                    <div class="form-group">
                        <label for="scanPath">Path to Scan</label>
                        <div class="input-with-button">
                            <input type="text" id="scanPath" name="path" required>
                            <button type="button" id="browsePath" class="btn secondary">Browse</button>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="scanName">Scan Name (Optional)</label>
                        <input type="text" id="scanName" name="name" placeholder="Scan of [path]">
                    </div>

                    <div class="form-group">
                        <label for="checksumMethod">Checksum Method</label>
                        <select id="checksumMethod" name="checksum_method">
                            <option value="sha256">SHA-256 (Recommended)</option>
                            <option value="sha512">SHA-512 (More Secure)</option>
                            <option value="blake3">BLAKE3 (Fast & Secure)</option>
                            <option value="xxhash64">xxHash64 (Fastest)</option>
                            <option value="md5">MD5 (Legacy)</option>
                            <option value="sha1">SHA-1 (Legacy)</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="scanThreads">Threads</label>
                        <input type="number" id="scanThreads" name="threads" value="4" min="1" max="32">
                        <div class="help-text">Number of parallel threads to use for scanning.</div>
                    </div>

                    <div class="form-group">
                        <label for="excludeDirs">Exclude Directories (Optional)</label>
                        <input type="text" id="excludeDirs" name="exclude_dirs" placeholder=".git, node_modules, .venv">
                        <div class="help-text">Comma-separated list of directory names to exclude.</div>
                    </div>

                    <div class="form-actions">
                        <button type="button" class="btn secondary close-modal">Cancel</button>
                        <button type="submit" class="btn primary">Start Scan</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Active Scan Modal -->
    <div id="activeScanModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Scan in Progress</h2>
                <button class="close-button">&times;</button>
            </div>
            <div class="modal-body">
                <div id="scanProgress">
                    <div class="progress-info">
                        <span id="scanStatus">Initializing...</span>
                        <span id="scanPercentage">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 0%"></div>
                    </div>
                    <div class="progress-details">
                        <div id="scanCurrentFile" class="scan-current-file">Preparing to scan...</div>
                        <div id="scanFileCount" class="scan-file-count">0 / 0 files</div>
                    </div>
                </div>

                <div class="scan-actions">
                    <button id="stopScanButton" class="btn danger">Stop Scan</button>
                </div>
            </div>
        </div>
    </div>

<script src="{{ url_for('static', filename='js/main.js') }}"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Navigation menu toggle
        const menuToggle = document.getElementById('menuToggle');
        const appNav = document.querySelector('.app-nav');

        if (menuToggle && appNav) {
            menuToggle.addEventListener('click', function() {
                appNav.classList.toggle('expanded');
            });
        }

        // Modal handling
        const openModalButtons = document.querySelectorAll('[data-open-modal]');
        const closeModalButtons = document.querySelectorAll('.close-modal, .close-button');
        const modals = document.querySelectorAll('.modal');

        // Open modal buttons
        openModalButtons.forEach(button => {
            button.addEventListener('click', function() {
                const modalId = this.dataset.openModal;
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.style.display = 'flex';
                }
            });
        });

        // Close modal buttons
        closeModalButtons.forEach(button => {
            button.addEventListener('click', function() {
                const modal = this.closest('.modal');
                if (modal) {
                    modal.style.display = 'none';
                }
            });
        });

        // Close modal when clicking outside
        window.addEventListener('click', function(event) {
            modals.forEach(modal => {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        });

        // New scan button
        const newScanButton = document.getElementById('newScanButton');
        const newScanModal = document.getElementById('newScanModal');

        if (newScanButton && newScanModal) {
            newScanButton.addEventListener('click', function() {
                newScanModal.style.display = 'flex';
            });
        }

        // New scan form submission
        const newScanForm = document.getElementById('newScanForm');
        if (newScanForm) {
            newScanForm.addEventListener('submit', function(event) {
                event.preventDefault();

                // Get form data
                const path = document.getElementById('scanPath').value;
                const name = document.getElementById('scanName').value;
                const algorithm = document.getElementById('checksumMethod').value;
                const threads = document.getElementById('scanThreads').value;
                const excludeDirs = document.getElementById('excludeDirs').value;

                // Validate path
                if (!path) {
                    alert('Please enter a path to scan');
                    return;
                }

                // Show loading state
                const submitButton = newScanForm.querySelector('button[type="submit"]');
                submitButton.textContent = 'Starting...';
                submitButton.disabled = true;

                // Prepare data for API
                const scanData = {
                    path: path,
                    name: name || undefined,
                    algorithm: algorithm,
                    threads: parseInt(threads, 10),
                    exclude_dirs: excludeDirs || undefined
                };

                // Send to API
                fetch('/api/scan/start', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(scanData)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Close the modal
                        newScanModal.style.display = 'none';

                        // Show active scan modal
                        const activeScanModal = document.getElementById('activeScanModal');
                        if (activeScanModal) {
                            activeScanModal.style.display = 'flex';

                            // Initialize scan progress updates via Socket.IO
                            initializeScanProgress(data.scan_id);
                        } else {
                            // If active scan modal doesn't exist, redirect to scan details
                            alert('Scan started successfully');
                            window.location.href = '/scan_details/' + data.scan_id;
                        }
                    } else {
                        alert('Error starting scan: ' + data.error);

                        // Restore button
                        submitButton.textContent = 'Start Scan';
                        submitButton.disabled = false;
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Error starting scan. Please try again.');

                    // Restore button
                    submitButton.textContent = 'Start Scan';
                    submitButton.disabled = false;
                });
            });
        }

        // Initialize Socket.IO for scan progress
        function initializeScanProgress(scanId) {
            if (typeof io === 'undefined') {
                console.error('Socket.IO not loaded');
                return;
            }

            const socket = io();

            // Elements for progress updates
            const scanStatus = document.getElementById('scanStatus');
            const scanPercentage = document.getElementById('scanPercentage');
            const scanCurrentFile = document.getElementById('scanCurrentFile');
            const scanFileCount = document.getElementById('scanFileCount');
            const progressFill = document.querySelector('.progress-fill');

            // Listen for scan progress events
            socket.on('scan_progress', function(data) {
                if (data.scan_id !== scanId) return;

                // Update progress display
                if (scanStatus) scanStatus.textContent = data.status.charAt(0).toUpperCase() + data.status.slice(1);
                if (scanPercentage) scanPercentage.textContent = `${data.percent_complete.toFixed(1)}%`;
                if (scanCurrentFile) scanCurrentFile.textContent = data.current_path || 'Processing...';
                if (scanFileCount) scanFileCount.textContent = `${data.files_processed} / ${data.total_files} files`;
                if (progressFill) progressFill.style.width = `${data.percent_complete}%`;

                // If scan completed or failed, handle completion
                if (data.status === 'completed' || data.status === 'failed') {
                    // Close active scan modal after short delay
                    setTimeout(function() {
                        const activeScanModal = document.getElementById('activeScanModal');
                        if (activeScanModal) {
                            activeScanModal.style.display = 'none';
                        }

                        // Redirect to scan details
                        window.location.href = '/scan_details/' + scanId;
                    }, 1000);
                }
            });

            // Handle scan completion event
            socket.on('scan_complete', function(data) {
                if (data.scan_id !== scanId) return;

                // Close active scan modal
                const activeScanModal = document.getElementById('activeScanModal');
                if (activeScanModal) {
                    activeScanModal.style.display = 'none';
                }

                // Redirect to scan details
                window.location.href = '/scan_details/' + data.scan_id;
            });

            // Handle stop scan button
            const stopScanButton = document.getElementById('stopScanButton');
            if (stopScanButton) {
                stopScanButton.addEventListener('click', function() {
                    if (confirm('Are you sure you want to stop the current scan?')) {
                        // Show loading state
                        stopScanButton.textContent = 'Stopping...';
                        stopScanButton.disabled = true;

                        // Send stop request to API
                        fetch(`/api/scan/stop/${scanId}`, {
                            method: 'POST'
                        })
                        .then(response => response.json())
                        .then(data => {
                            if (data.success) {
                                // Close the modal
                                const activeScanModal = document.getElementById('activeScanModal');
                                if (activeScanModal) {
                                    activeScanModal.style.display = 'none';
                                }

                                alert('Scan stopped successfully');
                            } else {
                                alert('Error stopping scan: ' + data.error);

                                // Restore button
                                stopScanButton.textContent = 'Stop Scan';
                                stopScanButton.disabled = false;
                            }
                        })
                        .catch(error => {
                            console.error('Error:', error);
                            alert('Error stopping scan');

                            // Restore button
                            stopScanButton.textContent = 'Stop Scan';
                            stopScanButton.disabled = false;
                        });
                    }
                });
            }
        }

        // Browse button for scan path
        const browsePath = document.getElementById('browsePath');
        const scanPath = document.getElementById('scanPath');

        if (browsePath && scanPath) {
            browsePath.addEventListener('click', function() {
                // In a real implementation, this would open a file dialog
                // For now, just show a message
                alert('File dialog would open here in a desktop application. For web-based usage, enter the path manually.');
            });
        }

        // Time ago formatting for timestamps
        const timeAgoElements = document.querySelectorAll('.time-ago');

        timeAgoElements.forEach(element => {
            const timestamp = element.dataset.timestamp;
            if (!timestamp) return;

            try {
                const date = new Date(timestamp);
                const now = new Date();
                const diff = now - date;

                let formattedDate;

                if (diff < 60000) { // Less than 1 minute
                    formattedDate = 'Just now';
                } else if (diff < 3600000) { // Less than 1 hour
                    const minutes = Math.floor(diff / 60000);
                    formattedDate = `${minutes} minute${minutes !== 1 ? 's' : ''} ago`;
                } else if (diff < 86400000) { // Less than 1 day
                    const hours = Math.floor(diff / 3600000);
                    formattedDate = `${hours} hour${hours !== 1 ? 's' : ''} ago`;
                } else if (diff < 2592000000) { // Less than 30 days
                    const days = Math.floor(diff / 86400000);
                    formattedDate = `${days} day${days !== 1 ? 's' : ''} ago`;
                } else {
                    // Format as date
                    const options = { year: 'numeric', month: 'short', day: 'numeric' };
                    formattedDate = date.toLocaleDateString(undefined, options);
                }

                element.textContent = formattedDate;
            } catch (e) {
                console.error('Error formatting date:', e);
            }
        });

        // Format file sizes
        const fileSizeElements = document.querySelectorAll('.file-size');

        fileSizeElements.forEach(element => {
            const size = element.dataset.size;
            if (!size) return;

            try {
                const sizeNumber = parseInt(size, 10);
                let formattedSize;

                if (sizeNumber < 1024) {
                    formattedSize = `${sizeNumber} B`;
                } else if (sizeNumber < 1048576) { // 1024 * 1024
                    formattedSize = `${(sizeNumber / 1024).toFixed(1)} KB`;
                } else if (sizeNumber < 1073741824) { // 1024 * 1024 * 1024
                    formattedSize = `${(sizeNumber / 1048576).toFixed(1)} MB`;
                } else {
                    formattedSize = `${(sizeNumber / 1073741824).toFixed(1)} GB`;
                }

                element.textContent = formattedSize;
            } catch (e) {
                console.error('Error formatting file size:', e);
            }
        });
    });
</script>

    {% block scripts %}{% endblock %}
</body>
</html>

</code>

web/templates/database_management.html:
<code>
{% extends 'layout.html' %}

{% block title %}Bitarr - Database Management{% endblock %}

{% block content %}
<div class="database-management">
    <h1>Database Management</h1>

    <!-- Sub-tabs Navigation -->
    <div class="sub-tabs">
        <div class="sub-tab active" data-tab="overview">Overview</div>
        <div class="sub-tab" data-tab="maintenance">Maintenance</div>
        <div class="sub-tab" data-tab="backups">Backups</div>
        <div class="sub-tab" data-tab="advanced">Advanced</div>
    </div>

    <!-- Overview Tab -->
    <div id="overview-tab" class="tab-content active">
        <h2 class="section-title">Database Summary</h2>
        <p>Click on a card to view more detailed information.</p>

        <div class="stats-card-container">
            <div class="stats-card">
                <div class="stats-card-title">Database Size</div>
                <div class="stats-card-value">{{ db_size_mb|default(0)|round(2) }} MB</div>
                <div class="stats-card-subtitle">SQLite database</div>
            </div>

            <div class="stats-card" id="showTotalScans" data-target="manage-scans">
                <div class="stats-card-title">Total Scans</div>
                <div class="stats-card-value">{{ total_scans|default(0)|thousands_separator }}</div>
                <div class="stats-card-subtitle">{{ unique_paths_count|default(0) }} unique paths <span style="float: right; color: var(--primary-color);">View All </span></div>
            </div>

            <div class="stats-card" id="showTrackedFiles">
                <div class="stats-card-title">Tracked Files</div>
                <div class="stats-card-value">{{ file_stats.total|default(0)|thousands_separator }}</div>
                <div class="stats-card-subtitle">{{ total_file_size|default(0)|format_size }} total size <span style="float: right; color: var(--primary-color);">View All </span></div>
            </div>

            <div class="stats-card" id="showStorageDevices">
                <div class="stats-card-title">Storage Devices</div>
                <div class="stats-card-value">{{ storage_devices|length }}</div>
                <div class="stats-card-subtitle">{{ storage_devices|selectattr('is_connected')|list|length }} currently connected <span style="float: right; color: var(--primary-color);">View All </span></div>
            </div>

            <div class="stats-card">
                <div class="stats-card-title">Oldest Scan</div>
                <div class="stats-card-value">{{ db_info.first_scan_date|default('N/A') }}</div>
                <div class="stats-card-subtitle">{{ db_info.days_since_first_scan|default(0) }} days ago</div>
            </div>

            <div class="stats-card">
                <div class="stats-card-title">Last Scan</div>
                <div class="stats-card-value">{{ db_info.last_scan_date|default('Never') }}</div>
                <div class="stats-card-subtitle">{% if db_info.last_scan_time %}at {{ db_info.last_scan_time }}{% else %}No scans performed{% endif %}</div>
            </div>
        </div>

        <h2 class="section-title">Database Health</h2>

        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Metric</th>
                        <th>Value</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Database Integrity</td>
                        <td>Last checked: {{ db_health.integrity_check_date|default('Never') }}</td>
                        <td>
                            {% if db_health.integrity_status == 'ok' %}
                                <span class="badge badge-success">Healthy</span>
                            {% elif db_health.integrity_status == 'error' %}
                                <span class="badge badge-danger">Error</span>
                            {% else %}
                                <span class="badge badge-secondary">Unknown</span>
                            {% endif %}
                            <button class="btn small secondary" id="runIntegrityCheckBtn">Run Integrity Check</button>
                        </td>
                    </tr>
                    <tr>
                        <td>Disk Space Used</td>
                        <td>{{ db_health.disk_usage_percent|round(1) }}% ({{ db_health.disk_free|format_size }} free)</td>
                        <td>
                            {% if db_health.disk_status == 'sufficient' %}
                                <span class="badge badge-success">Sufficient</span>
                            {% else %}
                                <span class="badge badge-warning">Low</span>
                            {% endif %}
                        </td>
                    </tr>
                    <tr>
                        <td>Vacuum Status</td>
                        <td>Last run: {{ db_health.vacuum_date|default('Never') }}</td>
                        <td>
                            {% if db_health.vacuum_status == 'recent' %}
                                <span class="badge badge-success">Recent</span>
                            {% else %}
                                <span class="badge badge-warning">Recommended</span>
                            {% endif %}
                            <button class="btn small secondary" id="optimizeDbBtn">Optimize Database</button>
                        </td>
                    </tr>
                    <tr>
                        <td>Indexes</td>
                        <td>{{ index_count }} indexes</td>
                        <td>
                            <span class="badge badge-success">Optimized</span>
                            <button class="btn small secondary" id="runReindexBtn">Reindex</button>
                        </td>
                    </tr>
                    <tr>
                        <td>Missing Files</td>
                        <td>{{ db_health.missing_files|default(0)|thousands_separator }} files</td>
                        <td>
                            {% if db_health.missing_files_status == 'review_recommended' %}
                                <span class="badge badge-warning">Review Recommended</span>
                                <button class="btn small secondary" id="purgeMissingFilesBtn">Purge Missing</button>
                            {% else %}
                                <span class="badge badge-success">Good</span>
                            {% endif %}
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="button-group" style="margin-top: 20px;">
            <button id="runVacuumBtn" class="btn secondary">Run Vacuum</button>
        </div>
    </div>

    <!-- Maintenance Tab -->
    <div id="maintenance-tab" class="tab-content">
        <div class="notification notification-warning">
            <div>
                <strong>Warning:</strong> Some maintenance operations may temporarily lock the database. Ensure no scans are running before proceeding.
            </div>
        </div>

        <h2 class="section-title">Database Reset Options</h2>

        <div class="card">
            <div class="card-body">
                <p style="margin-bottom: 15px;">Reset the database to clear scan history and tracked files. This operation cannot be undone.</p>

                <div class="form-row">
                    <div class="form-label">Reset Level:</div>
                    <div class="form-input">
                        <div style="margin-bottom: 10px;">
                            <input type="radio" id="resetScanHistory" name="resetLevel" value="scan_history" checked>
                            <label for="resetScanHistory">Scan History Only - Keeps schedules & configuration</label>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <input type="radio" id="resetFull" name="resetLevel" value="full">
                            <label for="resetFull">Full Reset - Keeps only configuration settings</label>
                        </div>
                        <div>
                            <input type="radio" id="resetComplete" name="resetLevel" value="complete">
                            <label for="resetComplete">Complete Reset - Resets everything to default values</label>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <button id="resetDatabaseBtn" class="btn danger">Reset Database</button>
                </div>
            </div>
        </div>

        <h2 class="section-title">Data Cleanup</h2>

        <div class="card">
            <div class="card-body">
                <div class="form-row">
                    <div class="form-label">Delete Scans Older Than:</div>
                    <div class="form-input">
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <select id="oldScansAge" style="max-width: 200px;">
                                <option value="30">30 days</option>
                                <option value="90">90 days</option>
                                <option value="180">180 days</option>
                                <option value="365">1 year</option>
                            </select>
                            <button id="clearOldScansBtn" class="btn secondary">Clear Old Scans</button>
                        </div>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-label">Purge Missing Files:</div>
                    <div class="form-input">
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <select id="missingFilesDays" style="max-width: 200px;">
                                <option value="30">Missing for 30+ days</option>
                                <option value="90">Missing for 90+ days</option>
                                <option value="180">Missing for 180+ days</option>
                            </select>
                            <button id="purgeMissingFilesBtn" class="btn secondary">Purge Missing Files</button>
                        </div>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-label">Clean Orphaned Records:</div>
                    <div class="form-input">
                        <button id="purgeOrphanedRecordsBtn" class="btn secondary">Clean Orphaned Records</button>
                        <div class="help-text">Remove orphaned records that don't have associated parent objects</div>
                    </div>
                </div>
            </div>
        </div>

        <h2 class="section-title">Performance Optimization</h2>

        <div class="card">
            <div class="card-body">
                <div class="form-row">
                    <div class="form-label">Database Optimization:</div>
                    <div class="form-input">
                        <button id="runVacuumBtn" class="btn secondary">Run Vacuum</button>
                        <div class="help-text">Reclaim unused space and optimize database file</div>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-label">Reindex Database:</div>
                    <div class="form-input">
                        <button id="runReindexBtn" class="btn secondary">Reindex Database</button>
                        <div class="help-text">Rebuild all indexes to improve query performance</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Backups Tab -->
    <div id="backups-tab" class="tab-content">
        <h2 class="section-title">Create Backup</h2>

        <div class="card">
            <div class="card-body">
                <div class="form-row">
                    <div class="form-label">Backup Name:</div>
                    <div class="form-input">
                        <input type="text" id="backupName" placeholder="Pre-update backup">
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <button id="createBackupBtn" class="btn primary">Create Backup</button>
                </div>
            </div>
        </div>

        <h2 class="section-title">Automatic Backups</h2>

        <div class="card">
            <div class="card-body">
                <div class="form-row">
                    <div class="form-label">Enable Automatic Backups:</div>
                    <div class="form-input">
                        <label class="toggle-switch">
                            <input type="checkbox" id="enableAutoBackups" {% if backup_settings.enabled %}checked{% endif %}>
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

                <div class="backup-options">
                    <div class="form-row">
                        <div class="form-label">Frequency:</div>
                        <div class="form-input">
                            <select id="backupFrequency">
                                <option value="daily" {% if backup_settings.frequency == 'daily' %}selected{% endif %}>Daily</option>
                                <option value="weekly" {% if backup_settings.frequency == 'weekly' %}selected{% endif %}>Weekly</option>
                                <option value="monthly" {% if backup_settings.frequency == 'monthly' %}selected{% endif %}>Monthly</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-label">Keep Backups:</div>
                        <div class="form-input">
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="number" id="backupRetain" value="{{ backup_settings.retain_count }}" min="1" max="100" style="max-width: 80px;">
                                <span>most recent backups</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <button id="saveBackupSettingsBtn" class="btn primary">Save Settings</button>
                </div>
            </div>
        </div>

        <h2 class="section-title">Backup History</h2>

        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Date & Time</th>
                        <th>Name</th>
                        <th>Size</th>
                        <th>Type</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    {% if backups %}
                        {% for backup in backups %}
                            <tr>
                                <td>{{ backup.date }}</td>
                                <td>{{ backup.name }}</td>
                                <td>{{ backup.size|format_size }}</td>
                                <td>
                                    {% if backup.type == 'auto' %}
                                        <span class="badge badge-info">Auto</span>
                                    {% else %}
                                        <span class="badge badge-secondary">Manual</span>
                                    {% endif %}
                                </td>
                                <td>
                                    <button class="btn small secondary restore-backup-btn" data-id="{{ backup.id }}">Restore</button>
                                    <button class="btn small danger delete-backup-btn" data-id="{{ backup.id }}">Delete</button>
                                </td>
                            </tr>
                        {% endfor %}
                    {% else %}
                        <tr>
                            <td colspan="5" class="no-data">No backups found. Create a backup to protect your data.</td>
                        </tr>
                    {% endif %}
                </tbody>
            </table>
        </div>
    </div>

    <!-- Advanced Tab -->
    <div id="advanced-tab" class="tab-content">
        <div class="notification notification-warning">
            <div>
                <strong>Advanced Mode:</strong> These operations are intended for expert users. Incorrect usage may result in data loss.
            </div>
        </div>

        <h2 class="section-title">Technical Operations</h2>

        <div class="card">
            <div class="card-body">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <button class="btn secondary" id="runIntegrityBtn">Run Integrity Check</button>
                    <button class="btn secondary" id="repairDatabaseBtn">Repair Database</button>

                    <button class="btn secondary" id="exportSchemaBtn">Export Schema</button>
                    <button class="btn secondary" id="rebuildIndexesBtn">Rebuild Indexes</button>
                </div>

                <h3 style="margin-top: 20px; font-size: 16px;">Export Options:</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
                    <button class="btn secondary" id="exportAllDataBtn">Export All Data</button>
                    <button class="btn secondary" id="exportConfigBtn">Export Configuration</button>
                </div>
            </div>
        </div>

        <h2 class="section-title">Database Information</h2>

        <div class="card">
            <div class="card-body">
                <div class="table-container">
                    <table>
                        <tbody>
                            <tr>
                                <td>SQLite Version</td>
                                <td>{{ db_info.sqlite_version|default('3.39.0') }}</td>
                            </tr>
                            <tr>
                                <td>Page Size</td>
                                <td>{{ db_info.page_size|default('4096') }} bytes</td>
                            </tr>
                            <tr>
                                <td>Journal Mode</td>
                                <td>{{ db_info.journal_mode|default('WAL') }}</td>
                            </tr>
                            <tr>
                                <td>Encoding</td>
                                <td>{{ db_info.encoding|default('UTF-8') }}</td>
                            </tr>
                            <tr>
                                <td>Number of Tables</td>
                                <td>{{ db_info.tables_count|default('7') }}</td>
                            </tr>
                            <tr>
                                <td>Number of Indexes</td>
                                <td>{{ index_count|default('18') }}</td>
                            </tr>
                            <tr>
                                <td>Database Path</td>
                                <td class="monospace">{{ db_info.database_path|default('/var/lib/bitarr/bitarr.db') }}</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Reset Database Modal -->
<div id="resetDatabaseModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 class="modal-title">Reset Database</h3>
            <button class="close-button">&times;</button>
        </div>

        <div class="modal-body">
            <div class="notification notification-danger">
                <div><strong>Warning:</strong> This action cannot be undone. All scan data will be permanently deleted.</div>
            </div>

            <p style="margin-top: 20px;">You are about to reset the database. This will:</p>

            <ul style="margin-bottom: 20px;">
                <li>Delete all scan history records ({{ total_scans|default(0) }} scans)</li>
                <li>Remove all file tracking data ({{ file_stats.total|default(0) }} files)</li>
                <li>Clear all checksum history</li>
                {% if active_scan_count > 0 %}
                    <li>Stop {{ active_scan_count }} currently running scan{% if active_scan_count > 1 %}s{% endif %}</li>
                {% endif %}
            </ul>

            <p>All configuration settings and scheduled scan definitions will be preserved.</p>

            <div class="form-row" style="margin-top: 20px;">
                <div class="form-label">Type "RESET" to confirm</div>
                <div class="form-input">
                    <input type="text" id="resetConfirmation" placeholder="Type RESET here">
                </div>
            </div>

            <div class="button-group" style="margin-top: 15px;">
                <button class="btn secondary close-modal">Cancel</button>
                <button class="btn danger" id="confirmResetBtn" disabled>Reset Database</button>
            </div>
        </div>
    </div>
</div>

<!-- Restore Backup Modal -->
<div id="restoreBackupModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 class="modal-title">Restore Backup</h3>
            <button class="close-button">&times;</button>
        </div>

        <div class="modal-body">
            <div class="notification notification-warning">
                <div><strong>Warning:</strong> Restoring a backup will replace your current database with the selected backup. All changes since the backup was created will be lost.</div>
            </div>

            <p style="margin-top: 20px;">You are about to restore the following backup:</p>

            <div class="table-container" style="margin: 15px 0;">
                <table>
                    <tbody>
                        <tr>
                            <td>Date:</td>
                            <td><strong id="restoreBackupDate"></strong></td>
                        </tr>
                        <tr>
                            <td>Name:</td>
                            <td><strong id="restoreBackupName"></strong></td>
                        </tr>
                        <tr>
                            <td>Size:</td>
                            <td><strong id="restoreBackupSize"></strong></td>
                        </tr>
                        <tr>
                            <td>Type:</td>
                            <td><strong id="restoreBackupType"></strong></td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="form-row" style="margin-top: 20px;">
                <div class="form-label">Type "RESTORE" to confirm</div>
                <div class="form-input">
                    <input type="text" id="restoreConfirmation" placeholder="Type RESTORE here">
                </div>
            </div>

            <div class="button-group" style="margin-top: 15px;">
                <button class="btn secondary close-modal">Cancel</button>
                <button class="btn danger" id="confirmRestoreBtn" disabled>Restore Backup</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}
{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Tab handling
        const subTabs = document.querySelectorAll('.sub-tab');
        const tabContents = document.querySelectorAll('.tab-content');

        subTabs.forEach(tab => {
            tab.addEventListener('click', function() {
                // Remove active class from all tabs
                subTabs.forEach(t => t.classList.remove('active'));

                // Hide all tab contents
                tabContents.forEach(content => content.style.display = 'none');

                // Add active class to clicked tab
                this.classList.add('active');

                // Show the selected tab content
                const tabId = this.dataset.tab + '-tab';
                document.getElementById(tabId).style.display = 'block';
            });
        });

        // Initialize tab display
        tabContents.forEach(content => {
            content.style.display = 'none';
        });
        document.getElementById('overview-tab').style.display = 'block';

        // Storage devices card click
        const showStorageDevicesCard = document.getElementById('showStorageDevices');
        const storageDevicesModal = document.getElementById('storageDevicesModal');

        if (showStorageDevicesCard && storageDevicesModal) {
            showStorageDevicesCard.addEventListener('click', function() {
                storageDevicesModal.style.display = 'flex';
            });
        }

        // Tracked files card click
        const showTrackedFilesCard = document.getElementById('showTrackedFiles');
        const trackedFilesModal = document.getElementById('trackedFilesModal');

        if (showTrackedFilesCard && trackedFilesModal) {
            showTrackedFilesCard.addEventListener('click', function() {
                trackedFilesModal.style.display = 'flex';
            });
        }

        // Close modal buttons
        const closeModalButtons = document.querySelectorAll('.close-modal, .close-button');
        const modals = document.querySelectorAll('.modal');

        closeModalButtons.forEach(button => {
            button.addEventListener('click', function() {
                const modal = this.closest('.modal');
                if (modal) {
                    modal.style.display = 'none';
                }
            });
        });

        // Close modal when clicking outside
        window.addEventListener('click', function(event) {
            modals.forEach(modal => {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        });

        // Run integrity check button
        const runIntegrityCheckBtn = document.getElementById('runIntegrityCheckBtn');
        const runIntegrityBtn = document.getElementById('runIntegrityBtn');

        function runIntegrityCheck(button) {
            if (!button) return;

            const originalText = button.textContent;
            button.textContent = 'Running...';
            button.disabled = true;

            fetch('/api/db/integrity_check')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        if (data.integrity_status === 'ok') {
                            alert('Database integrity check completed successfully. No issues found.');
                        } else {
                            alert('Integrity check found issues:\n\n' + (data.errors ? data.errors.join('\n') : 'Unknown issues'));
                        }
                    } else {
                        alert('Error running integrity check: ' + data.error);
                    }

                    // Restore button state
                    button.textContent = originalText;
                    button.disabled = false;
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Error running integrity check. Please try again.');

                    // Restore button state
                    button.textContent = originalText;
                    button.disabled = false;
                });
        }

        if (runIntegrityCheckBtn) {
            runIntegrityCheckBtn.addEventListener('click', function() {
                runIntegrityCheck(this);
            });
        }

        if (runIntegrityBtn) {
            runIntegrityBtn.addEventListener('click', function() {
                runIntegrityCheck(this);
            });
        }

        // Optimize database button
        const optimizeDbBtn = document.getElementById('optimizeDbBtn');
        const runVacuumBtn = document.getElementById('runVacuumBtn');

        function runVacuum(button) {
            if (!button) return;

            const originalText = button.textContent;
            button.textContent = 'Running...';
            button.disabled = true;

            fetch('/api/db/vacuum', {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Database optimization completed successfully.');
                } else {
                    alert('Error optimizing database: ' + data.error);
                }

                // Restore button state
                button.textContent = originalText;
                button.disabled = false;
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error optimizing database. Please try again.');

                // Restore button state
                button.textContent = originalText;
                button.disabled = false;
            });
        }

        if (optimizeDbBtn) {
            optimizeDbBtn.addEventListener('click', function() {
                runVacuum(this);
            });
        }

        if (runVacuumBtn) {
            runVacuumBtn.addEventListener('click', function() {
                runVacuum(this);
            });
        }

        // Reindex database button
        const runReindexBtn = document.getElementById('runReindexBtn');
        const rebuildIndexesBtn = document.getElementById('rebuildIndexesBtn');

        function runReindex(button) {
            if (!button) return;

            const originalText = button.textContent;
            button.textContent = 'Running...';
            button.disabled = true;

            fetch('/api/db/reindex', {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Database reindexing completed successfully.');
                } else {
                    alert('Error reindexing database: ' + data.error);
                }

                // Restore button state
                button.textContent = originalText;
                button.disabled = false;
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error reindexing database. Please try again.');

                // Restore button state
                button.textContent = originalText;
                button.disabled = false;
            });
        }

        if (runReindexBtn) {
            runReindexBtn.addEventListener('click', function() {
                runReindex(this);
            });
        }

        if (rebuildIndexesBtn) {
            rebuildIndexesBtn.addEventListener('click', function() {
                runReindex(this);
            });
        }

        // Reset database button
        const resetDatabaseBtn = document.getElementById('resetDatabaseBtn');
        const resetDatabaseModal = document.getElementById('resetDatabaseModal');
        const resetConfirmation = document.getElementById('resetConfirmation');
        const confirmResetBtn = document.getElementById('confirmResetBtn');
        const resetLevelRadios = document.getElementsByName('resetLevel');

        if (resetDatabaseBtn && resetDatabaseModal && resetConfirmation && confirmResetBtn) {
            resetDatabaseBtn.addEventListener('click', function() {
                resetDatabaseModal.style.display = 'flex';
                resetConfirmation.value = '';
                confirmResetBtn.disabled = true;
            });

            resetConfirmation.addEventListener('input', function() {
                confirmResetBtn.disabled = this.value !== 'RESET';
            });

            confirmResetBtn.addEventListener('click', function() {
                // Get selected reset level
                let selectedLevel = 'scan_history'; // default
                resetLevelRadios.forEach(radio => {
                    if (radio.checked) {
                        selectedLevel = radio.value;
                    }
                });

                const endpoint = '/api/db/reset/' + selectedLevel;

                // Show loading state
                confirmResetBtn.textContent = 'Resetting...';
                confirmResetBtn.disabled = true;

                fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ confirmation: 'RESET' })
                })
                .then(response => response.json())
                .then(data => {
                    // Close modal
                    resetDatabaseModal.style.display = 'none';

                    if (data.success) {
                        alert('Database has been reset successfully.');
                        // Reload page
                        window.location.reload();
                    } else {
                        alert('Error resetting database: ' + data.error);
                        confirmResetBtn.textContent = 'Reset Database';
                        confirmResetBtn.disabled = false;
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Error resetting database. Please try again.');

                    resetDatabaseModal.style.display = 'none';
                    confirmResetBtn.textContent = 'Reset Database';
                    confirmResetBtn.disabled = false;
                });
            });
        }

        // Restore Backup functionality
        const restoreBackupBtns = document.querySelectorAll('.restore-backup-btn');
        const restoreBackupModal = document.getElementById('restoreBackupModal');
        const restoreConfirmation = document.getElementById('restoreConfirmation');
        const confirmRestoreBtn = document.getElementById('confirmRestoreBtn');
        const restoreBackupDate = document.getElementById('restoreBackupDate');
        const restoreBackupName = document.getElementById('restoreBackupName');
        const restoreBackupSize = document.getElementById('restoreBackupSize');
        const restoreBackupType = document.getElementById('restoreBackupType');

        if (restoreBackupBtns.length > 0 && restoreBackupModal && restoreConfirmation && confirmRestoreBtn) {
            restoreBackupBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    const backupId = this.getAttribute('data-id');
                    const row = this.closest('tr');

                    // Get backup details from the row
                    const date = row.cells[0].textContent.trim();
                    const name = row.cells[1].textContent.trim();
                    const size = row.cells[2].textContent.trim();
                    const type = row.cells[3].textContent.trim();

                    // Update modal with backup details
                    if (restoreBackupDate) restoreBackupDate.textContent = date;
                    if (restoreBackupName) restoreBackupName.textContent = name;
                    if (restoreBackupSize) restoreBackupSize.textContent = size;
                    if (restoreBackupType) restoreBackupType.textContent = type;

                    // Set backup ID for restore action
                    confirmRestoreBtn.setAttribute('data-id', backupId);

                    // Show modal
                    restoreBackupModal.style.display = 'flex';
                    restoreConfirmation.value = '';
                    confirmRestoreBtn.disabled = true;
                });
            });

            restoreConfirmation.addEventListener('input', function() {
                confirmRestoreBtn.disabled = this.value !== 'RESTORE';
            });

            confirmRestoreBtn.addEventListener('click', function() {
                const backupId = this.getAttribute('data-id');
                if (!backupId) {
                    alert('Invalid backup ID.');
                    return;
                }

                const endpoint = '/api/db/backup/' + backupId + '/restore';

                // Show loading state
                confirmRestoreBtn.textContent = 'Restoring...';
                confirmRestoreBtn.disabled = true;

                fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ confirmation: 'RESTORE' })
                })
                .then(response => response.json())
                .then(data => {
                    // Close modal
                    restoreBackupModal.style.display = 'none';

                    if (data.success) {
                        alert('Backup has been restored successfully.');
                        // Reload page
                        window.location.reload();
                    } else {
                        alert('Error restoring backup: ' + data.error);
                        confirmRestoreBtn.textContent = 'Restore Backup';
                        confirmRestoreBtn.disabled = false;
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Error restoring backup. Please try again.');

                    restoreBackupModal.style.display = 'none';
                    confirmRestoreBtn.textContent = 'Restore Backup';
                    confirmRestoreBtn.disabled = false;
                });
            });
        }

        // Data cleanup functions
        const clearOldScansBtn = document.getElementById('clearOldScansBtn');
        const purgeMissingFilesBtn = document.getElementById('purgeMissingFilesBtn');
        const purgeOrphanedRecordsBtn = document.getElementById('purgeOrphanedRecordsBtn');

        if (clearOldScansBtn) {
            clearOldScansBtn.addEventListener('click', function() {
                const oldScansAge = document.getElementById('oldScansAge').value;

                if (confirm(`Are you sure you want to delete all scans older than ${oldScansAge} days?`)) {
                    clearOldScansBtn.textContent = 'Clearing...';
                    clearOldScansBtn.disabled = true;

                    fetch('/api/db/clear_old_scans', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ days: parseInt(oldScansAge) })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            if (data.scans_deleted > 0) {
                                alert(`Successfully deleted ${data.scans_deleted} scan(s) older than ${oldScansAge} days.`);
                            } else {
                                alert(`No scans found older than ${oldScansAge} days.`);
                            }

                            // Reload page to update stats
                            window.location.reload();
                        } else {
                            alert('Error clearing old scans: ' + data.error);
                            clearOldScansBtn.textContent = 'Clear Old Scans';
                            clearOldScansBtn.disabled = false;
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('Error clearing old scans. Please try again.');

                        clearOldScansBtn.textContent = 'Clear Old Scans';
                        clearOldScansBtn.disabled = false;
                    });
                }
            });
        }

        if (purgeMissingFilesBtn) {
            purgeMissingFilesBtn.addEventListener('click', function() {
                const missingFilesDaysSelect = document.getElementById('missingFilesDays');
                if (!missingFilesDaysSelect) return;

                const missingFilesDaysText = missingFilesDaysSelect.options[missingFilesDaysSelect.selectedIndex].text;
                const days = parseInt(missingFilesDaysSelect.value);

                if (confirm(`Are you sure you want to permanently delete files that have been ${missingFilesDaysText.toLowerCase()}?`)) {
                    purgeMissingFilesBtn.textContent = 'Purging...';
                    purgeMissingFilesBtn.disabled = true;

                    fetch('/api/db/purge_missing_files', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ days: days })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            if (data.files_purged > 0) {
                                alert(`Successfully purged ${data.files_purged} missing file(s).`);
                            } else {
                                alert(`No files found missing for more than ${days} days.`);
                            }

                            // Reload page to update stats
                            window.location.reload();
                        } else {
                            alert('Error purging missing files: ' + data.error);
                            purgeMissingFilesBtn.textContent = 'Purge Missing Files';
                            purgeMissingFilesBtn.disabled = false;
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('Error purging missing files. Please try again.');

                        purgeMissingFilesBtn.textContent = 'Purge Missing Files';
                        purgeMissingFilesBtn.disabled = false;
                    });
                }
            });
        }

        if (purgeOrphanedRecordsBtn) {
            purgeOrphanedRecordsBtn.addEventListener('click', function() {
                if (confirm('Are you sure you want to clean orphaned records? This will remove records that no longer have valid references.')) {
                    purgeOrphanedRecordsBtn.textContent = 'Cleaning...';
                    purgeOrphanedRecordsBtn.disabled = true;

                    fetch('/api/db/purge_orphaned_records', {
                        method: 'POST'
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            const totalOrphaned = data.orphaned_checksums_removed + data.orphaned_errors_removed;
                            if (totalOrphaned > 0) {
                                alert(`Successfully cleaned ${totalOrphaned} orphaned record(s).`);
                            } else {
                                alert('No orphaned records found.');
                            }
                        } else {
                            alert('Error cleaning orphaned records: ' + data.error);
                        }

                        purgeOrphanedRecordsBtn.textContent = 'Clean Orphaned Records';
                        purgeOrphanedRecordsBtn.disabled = false;
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('Error cleaning orphaned records. Please try again.');

                        purgeOrphanedRecordsBtn.textContent = 'Clean Orphaned Records';
                        purgeOrphanedRecordsBtn.disabled = false;
                    });
                }
            });
        }

        // Backup management functions
        const createBackupBtn = document.getElementById('createBackupBtn');
        const saveBackupSettingsBtn = document.getElementById('saveBackupSettingsBtn');
        const deleteBackupBtns = document.querySelectorAll('.delete-backup-btn');
        const enableAutoBackups = document.getElementById('enableAutoBackups');
        const backupOptionsRows = document.querySelectorAll('.backup-options .form-row');

        if (createBackupBtn) {
            createBackupBtn.addEventListener('click', function() {
                const backupName = document.getElementById('backupName').value.trim();

                createBackupBtn.textContent = 'Creating...';
                createBackupBtn.disabled = true;

                fetch('/api/db/backup', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ name: backupName || undefined })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        alert('Backup created successfully.');
                        // Reload page to show new backup
                        window.location.reload();
                    } else {
                        alert('Error creating backup: ' + data.error);
                        createBackupBtn.textContent = 'Create Backup';
                        createBackupBtn.disabled = false;
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Error creating backup. Please try again.');

                    createBackupBtn.textContent = 'Create Backup';
                    createBackupBtn.disabled = false;
                });
            });
        }

        if (enableAutoBackups && backupOptionsRows.length > 0) {
            enableAutoBackups.addEventListener('change', function() {
                const isEnabled = this.checked;

                backupOptionsRows.forEach(row => {
                    row.style.display = isEnabled ? 'flex' : 'none';
                });
            });

            // Initialize visibility based on current state
            const isEnabled = enableAutoBackups.checked;
            backupOptionsRows.forEach(row => {
                row.style.display = isEnabled ? 'flex' : 'none';
            });
        }

        if (saveBackupSettingsBtn) {
            saveBackupSettingsBtn.addEventListener('click', function() {
                const enabled = enableAutoBackups.checked;
                const frequency = document.getElementById('backupFrequency').value;
                const retainCount = parseInt(document.getElementById('backupRetain').value);

                // Validate inputs
                if (isNaN(retainCount) || retainCount < 1 || retainCount > 100) {
                    alert('Please enter a valid number of backups to keep (1-100).');
                    return;
                }

                saveBackupSettingsBtn.textContent = 'Saving...';
                saveBackupSettingsBtn.disabled = true;

                fetch('/api/db/backup/settings', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        enabled: enabled,
                        frequency: frequency,
                        retain_count: retainCount
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        alert('Backup settings saved successfully.');
                    } else {
                        alert('Error saving backup settings: ' + data.error);
                    }

                    saveBackupSettingsBtn.textContent = 'Save Settings';
                    saveBackupSettingsBtn.disabled = false;
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Error saving backup settings. Please try again.');

                    saveBackupSettingsBtn.textContent = 'Save Settings';
                    saveBackupSettingsBtn.disabled = false;
                });
            });
        }

        if (deleteBackupBtns.length > 0) {
            deleteBackupBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    const backupId = this.getAttribute('data-id');
                    if (!backupId) return;

                    const row = this.closest('tr');
                    const backupName = row.cells[1].textContent.trim();

                    if (confirm(`Are you sure you want to delete the backup "${backupName}"?`)) {
                        btn.textContent = 'Deleting...';
                        btn.disabled = true;

                        fetch('/api/db/backup/' + backupId, {
                            method: 'DELETE'
                        })
                        .then(response => response.json())
                        .then(data => {
                            if (data.success) {
                                // Remove row from table
                                row.remove();
                                alert('Backup deleted successfully.');
                            } else {
                                alert('Error deleting backup: ' + data.error);
                                btn.textContent = 'Delete';
                                btn.disabled = false;
                            }
                        })
                        .catch(error => {
                            console.error('Error:', error);
                            alert('Error deleting backup. Please try again.');

                            btn.textContent = 'Delete';
                            btn.disabled = false;
                        });
                    }
                });
            });
        }

        // Advanced export buttons
        const exportSchemaBtn = document.getElementById('exportSchemaBtn');
        const exportAllDataBtn = document.getElementById('exportAllDataBtn');
        const exportConfigBtn = document.getElementById('exportConfigBtn');

        if (exportSchemaBtn) {
            exportSchemaBtn.addEventListener('click', function() {
                window.location.href = '/api/db/export/schema';
            });
        }

        if (exportAllDataBtn) {
            exportAllDataBtn.addEventListener('click', function() {
                window.location.href = '/api/db/export/all_data';
            });
        }

        if (exportConfigBtn) {
            exportConfigBtn.addEventListener('click', function() {
                window.location.href = '/api/db/export/configuration';
            });
        }

        // Database repair button
        const repairDatabaseBtn = document.getElementById('repairDatabaseBtn');

        if (repairDatabaseBtn) {
            repairDatabaseBtn.addEventListener('click', function() {
                if (confirm('Are you sure you want to repair the database? This will create a backup and attempt to rebuild the database structure.')) {
                    repairDatabaseBtn.textContent = 'Repairing...';
                    repairDatabaseBtn.disabled = true;

                    fetch('/api/db/repair', {
                        method: 'POST'
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            alert('Database repair completed successfully.');
                            // Reload page
                            window.location.reload();
                        } else {
                            alert('Error repairing database: ' + data.error);
                            repairDatabaseBtn.textContent = 'Repair Database';
                            repairDatabaseBtn.disabled = false;
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('Error repairing database. Please try again.');

                        repairDatabaseBtn.textContent = 'Repair Database';
                        repairDatabaseBtn.disabled = false;
                    });
                }
            });
        }
    });
</script>
{% endblock %}

</code>

web/templates/configuration.html:
<code>
{% extends 'layout.html' %}

{% block title %}Bitarr - Configuration{% endblock %}

{% block content %}
<div class="configuration">
    <h1>Configuration</h1>

    <div class="card">
        <div class="card-header">
            <h2 class="card-title">Application Settings</h2>
        </div>
        <div class="card-body">
            <form id="configForm">
                <div class="form-grid">
                    <div class="form-group">
                        <label for="webUiPort">Web UI Port</label>
                        <input type="number" id="webUiPort" name="web_ui_port" value="{{ config.web_ui_port|default(8286) }}" min="1024" max="65535">
                        <div class="help-text">Port for the web interface (requires restart)</div>
                    </div>

                    <div class="form-group">
                        <label for="scanThreads">Scan Threads</label>
                        <input type="number" id="scanThreads" name="scan_threads" value="{{ config.scan_threads|default(4) }}" min="1" max="32">
                        <div class="help-text">Default number of threads for scanning</div>
                    </div>

                    <div class="form-group">
                        <label for="checksumMethod">Default Checksum Method</label>
                        <select id="checksumMethod" name="checksum_method">
                            {% for algorithm in algorithms %}
                                <option value="{{ algorithm }}" {% if config.checksum_method == algorithm %}selected{% endif %}>{{ algorithm }}</option>
                            {% endfor %}
                        </select>
                        <div class="help-text">Default method for calculating checksums</div>
                    </div>

                    <div class="form-group">
                        <label for="checksumBlockSize">Checksum Block Size (MB)</label>
                        <input type="number" id="checksumBlockSize" name="checksum_block_size" value="{{ config.checksum_block_size|default(4) }}" min="1" max="64">
                        <div class="help-text">Size of blocks read when calculating checksums</div>
                    </div>
                </div>

                <h3>Database Settings</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label for="dbAutoVacuum">Auto Vacuum</label>
                        <select id="dbAutoVacuum" name="db_auto_vacuum">
                            <option value="0" {% if config.db_auto_vacuum == 0 %}selected{% endif %}>None</option>
                            <option value="1" {% if config.db_auto_vacuum == 1 %}selected{% endif %}>Full</option>
                            <option value="2" {% if config.db_auto_vacuum == 2 %}selected{% endif %}>Incremental</option>
                        </select>
                        <div class="help-text">Database auto-vacuum mode</div>
                    </div>

                    <div class="form-group">
                        <label for="dbAutoBackup">Auto Backup</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="dbAutoBackup" name="db_auto_backup" {% if config.db_auto_backup %}checked{% endif %}>
                            <label for="dbAutoBackup"></label>
                        </div>
                        <div class="help-text">Enable automatic database backups</div>
                    </div>

                    <div class="form-group">
                        <label for="dbBackupFrequency">Backup Frequency</label>
                        <select id="dbBackupFrequency" name="db_backup_frequency">
                            <option value="daily" {% if config.db_backup_frequency == 'daily' %}selected{% endif %}>Daily</option>
                            <option value="weekly" {% if config.db_backup_frequency == 'weekly' %}selected{% endif %}>Weekly</option>
                            <option value="monthly" {% if config.db_backup_frequency == 'monthly' %}selected{% endif %}>Monthly</option>
                        </select>
                        <div class="help-text">How often to perform database backups</div>
                    </div>

                    <div class="form-group">
                        <label for="dbBackupRetain">Backups to Retain</label>
                        <input type="number" id="dbBackupRetain" name="db_backup_retain" value="{{ config.db_backup_retain|default(10) }}" min="1" max="100">
                        <div class="help-text">Number of backup copies to keep</div>
                    </div>
                </div>

                <div class="form-actions">
                    <button type="submit" class="btn primary">Save Configuration</button>
                    <button type="button" id="resetConfigButton" class="btn outline">Reset to Defaults</button>
                </div>
            </form>
        </div>
    </div>

    <div class="card" style="margin-top: 20px;">
        <div class="card-header">
            <h2 class="card-title">Checksum Algorithms</h2>
        </div>
        <div class="card-body">
            <div class="algorithm-cards">
                {% for algorithm in algorithms %}
                    {% if algo_info and algorithm in algo_info %}
                        <div class="algorithm-card">
                            <h3>{{ algorithm }}</h3>
                            <div class="algorithm-details">
                                <div class="detail-item">
                                    <span class="detail-label">Description:</span>
                                    <span class="detail-value">{{ algo_info[algorithm]['description'] }}</span>
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Speed:</span>
                                    <span class="detail-value">{{ algo_info[algorithm]['speed'] }}</span>
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Security:</span>
                                    <span class="detail-value">{{ algo_info[algorithm]['security'] }}</span>
                                </div>
                                <div class="detail-item">
                                    <span class="detail-label">Recommendation:</span>
                                    <span class="detail-value">{{ algo_info[algorithm]['recommendation'] }}</span>
                                </div>
                            </div>
                        </div>
                    {% endif %}
                {% endfor %}
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        const configForm = document.getElementById('configForm');
        const resetConfigButton = document.getElementById('resetConfigButton');

        // Handle form submission
        configForm.addEventListener('submit', function(event) {
            event.preventDefault();
            const formData = new FormData(configForm);
            const config = {};

            // Convert form data to config object
            for (const [key, value] of formData.entries()) {
                // Convert checkbox values
                if (key === 'db_auto_backup') {
                    config[key] = true;
                } else if (key === 'checksum_method' || key === 'db_backup_frequency') {
                    config[key] = value;
                } else if (key.includes('_port') || key.includes('_threads') || key.includes('_retain') ||
                        key.includes('_vacuum') || key.includes('_block_size')) {
                    // Convert numeric values
                    config[key] = parseInt(value, 10);
                } else {
                    config[key] = value;
                }
            }

            // Check if db_auto_backup checkbox is unchecked
            if (!formData.has('db_auto_backup')) {
                config['db_auto_backup'] = false;
            }

            // Display saving indicator
            const saveButton = configForm.querySelector('button[type="submit"]');
            const originalText = saveButton.textContent;
            saveButton.textContent = 'Saving...';
            saveButton.disabled = true;

            // Send to API
            fetch('/api/configuration', {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(config)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Highlight saved settings
                    for (const key in config) {
                        const element = document.getElementById(key.replace('_', ''));
                        if (element) {
                            element.classList.add('setting-changed');
                            setTimeout(() => {
                                element.classList.remove('setting-changed');
                            }, 2000);
                        }
                    }
                    // Show success message
                    alert('Configuration saved successfully');
                } else {
                    alert('Error saving configuration: ' + data.error);
                }

                // Restore button
                saveButton.textContent = originalText;
                saveButton.disabled = false;
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error saving configuration. Please try again.');

                // Restore button
                saveButton.textContent = originalText;
                saveButton.disabled = false;
            });
        });

        // Handle reset button
        resetConfigButton.addEventListener('click', function() {
            if (confirm('Reset all configuration to default values? This cannot be undone.')) {
                // Show loading state
                resetConfigButton.textContent = 'Resetting...';
                resetConfigButton.disabled = true;

                fetch('/api/configuration/reset', {
                    method: 'POST'
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        alert('Configuration reset to defaults');
                        // Reload page to show new values
                        location.reload();
                    } else {
                        alert('Error resetting configuration: ' + data.error);
                        // Restore button
                        resetConfigButton.textContent = 'Reset to Defaults';
                        resetConfigButton.disabled = false;
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Error resetting configuration');
                    // Restore button
                    resetConfigButton.textContent = 'Reset to Defaults';
                    resetConfigButton.disabled = false;
                });
            }
        });

        // Toggle dependencies
        const dbAutoBackup = document.getElementById('dbAutoBackup');
        const dbBackupFrequency = document.getElementById('dbBackupFrequency');
        const dbBackupRetain = document.getElementById('dbBackupRetain');

        function updateBackupControls() {
            const isEnabled = dbAutoBackup.checked;
            dbBackupFrequency.disabled = !isEnabled;
            dbBackupRetain.disabled = !isEnabled;
        }

        dbAutoBackup.addEventListener('change', updateBackupControls);
        updateBackupControls();
    });
</script>
{% endblock %}

</code>

web/templates/scheduled_scans.html:
<code>
{% extends 'layout.html' %}

{% block title %}Bitarr - Scheduled Scans{% endblock %}

{% block content %}
<div class="scheduled-scans">
    <h1>Scheduled Scans</h1>

    <div class="sub-tabs">
        <div class="sub-tab active" data-view="list">List View</div>
        <div class="sub-tab" data-view="calendar">Calendar View</div>
    </div>

    <div class="controls">
        <div class="search-container">
            <input type="text" id="searchFilter" class="search-filter" placeholder="Filter scheduled scans...">
        </div>
        <div class="action-buttons">
            {% if active_scans %}
                <div class="notification-warning" style="margin: 0;">
                    <span class="status-indicator status-running"></span> Scan in progress: {{ next(iter(active_scans.values())).get('path', 'Unknown') }}
                </div>
            {% endif %}
            <button id="newScheduleBtn" class="btn primary">New Schedule</button>
        </div>
    </div>

    <div class="view" id="list-view">
        <div class="card">
            <div class="card-body">
                {% if schedules %}
                    <div class="table-container">
                        <table id="schedulesTable">
                            <thead>
                                <tr>
                                    <th>Status</th>
                                    <th>Name</th>
                                    <th>Top-Level Path</th>
                                    <th>Schedule</th>
                                    <th>Next Run</th>
                                    <th>Last Run</th>
                                    <th>Last Status</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for schedule in schedules %}
                                    <tr class="schedule-row" data-schedule-id="{{ schedule.id }}">
                                        <td>
                                            {% if schedule.is_active %}
                                                {% if schedule.status == 'running' %}
                                                    <span class="status-indicator status-running"></span> Running
                                                {% else %}
                                                    <span class="status-indicator status-good"></span> Active
                                                {% endif %}
                                            {% else %}
                                                <span class="status-indicator status-disabled"></span> Disabled
                                            {% endif %}
                                        </td>
                                        <td>{{ schedule.name }}</td>
                                        <td class="path">
                                            {% set paths = schedule.paths|from_json if schedule.paths else [] %}
                                            {% if paths|length > 1 %}
                                                {{ paths[0] }} <span class="badge">+{{ paths|length - 1 }}</span>
                                            {% elif paths|length == 1 %}
                                                {{ paths[0] }}
                                            {% else %}
                                                (No paths)
                                            {% endif %}
                                        </td>
                                        <td>{{ schedule.frequency|title }}{% if schedule.frequency == 'daily' %} (at {{ schedule.parameters|from_json|attr('hour', '00') }}:{{ schedule.parameters|from_json|attr('minute', '00')|string|zfill(2) }}){% endif %}</td>
                                        <td class="time-ago" data-timestamp="{{ schedule.next_run }}">
                                            {% if schedule.next_run %}
                                                {{ schedule.next_run }}
                                            {% else %}
                                                -
                                            {% endif %}
                                        </td>
                                        <td class="time-ago" data-timestamp="{{ schedule.last_run }}">
                                            {% if schedule.last_run %}
                                                {{ schedule.last_run }}
                                            {% else %}
                                                Never
                                            {% endif %}
                                        </td>
                                        <td>
                                            {% if schedule.last_run %}
                                                {% if schedule.last_status == 'completed' %}
                                                    <span class="badge badge-success">Completed</span>
                                                {% elif schedule.last_status == 'failed' %}
                                                    <span class="badge badge-danger">Failed</span>
                                                {% elif schedule.last_status == 'partial' %}
                                                    <span class="badge badge-warning">Partial</span>
                                                {% else %}
                                                    <span class="badge badge-secondary">{{ schedule.last_status|title }}</span>
                                                {% endif %}
                                            {% else %}
                                                <span class="badge badge-secondary">Not run yet</span>
                                            {% endif %}
                                        </td>
                                        <td>
                                            <button class="btn small secondary edit-schedule-btn" data-schedule-id="{{ schedule.id }}">Edit</button>
                                            {% if schedule.status == 'running' %}
                                                <button class="btn small danger stop-scan-btn" data-scan-id="{{ schedule.current_scan_id }}">Stop</button>
                                            {% else %}
                                                <button class="btn small primary run-now-btn" data-schedule-id="{{ schedule.id }}">Run Now</button>
                                            {% endif %}
                                        </td>
                                    </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                {% else %}
                    <div class="empty-state">
                        <div class="empty-state-icon"></div>
                        <h3>No Scheduled Scans</h3>
                        <p>You haven't created any scheduled scans yet. Schedule a scan to automate your file integrity monitoring.</p>
                        <button id="firstScheduleBtn" class="btn primary">Create Your First Schedule</button>
                    </div>
                {% endif %}
            </div>
        </div>
    </div>

    <div class="view" id="calendar-view" style="display: none;">
        <div class="card">
            <div class="card-body">
                <div class="calendar-view">
                    <div class="calendar-header">
                        <div class="calendar-nav">
                            <button id="prevMonthBtn" class="btn secondary"></button>
                        </div>
                        <div class="calendar-title" id="currentMonth">{{ now.strftime('%B %Y') }}</div>
                        <div class="calendar-nav">
                            <button id="nextMonthBtn" class="btn secondary"></button>
                        </div>
                    </div>

                    <div class="calendar-grid" id="calendarGrid">
                        <div class="calendar-day-header">Sun</div>
                        <div class="calendar-day-header">Mon</div>
                        <div class="calendar-day-header">Tue</div>
                        <div class="calendar-day-header">Wed</div>
                        <div class="calendar-day-header">Thu</div>
                        <div class="calendar-day-header">Fri</div>
                        <div class="calendar-day-header">Sat</div>

                        <!-- Calendar days will be populated via JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="notification notification-info">
        <div>Scheduled scans that would overlap with running scans will be queued and start when resources are available.</div>
    </div>
</div>

<!-- New/Edit Schedule Modal -->
<div id="scheduleModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 class="modal-title" id="scheduleModalTitle">New Scheduled Scan</h3>
            <button class="close-button">&times;</button>
        </div>
        <div class="modal-body">
            <form id="scheduleForm">
                <input type="hidden" id="scheduleId" name="id" value="">

                <div class="form-group">
                    <div class="form-row">
                        <div class="form-label">Name</div>
                        <div class="form-input">
                            <input type="text" id="scheduleName" name="name" placeholder="Give this schedule a descriptive name" required>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-label">Status</div>
                        <div class="form-input">
                            <label class="toggle-switch">
                                <input type="checkbox" id="scheduleActive" name="is_active" checked>
                                <span class="slider"></span>
                            </label>
                            <span style="margin-left: 10px;">Active</span>
                        </div>
                    </div>
                </div>

                <h4>Top-Level Paths</h4>
                <div class="path-list" id="pathList">
                    <!-- Paths will be populated dynamically -->
                </div>

                <div class="form-row">
                    <div class="input-group" style="width: 100%;">
                        <input type="text" id="newPath" placeholder="Add new path..." class="monospace" style="flex: 1;">
                        <button type="button" id="addPathBtn" class="btn secondary">Add</button>
                    </div>
                </div>

                <h4>Schedule Settings</h4>

                <div class="form-row">
                    <div class="form-label">Frequency</div>
                    <div class="form-input">
                        <div class="radios">
                            <div class="radio-option">
                                <input type="radio" id="freqDaily" name="frequency" value="daily">
                                <label for="freqDaily">Daily</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="freqWeekly" name="frequency" value="weekly">
                                <label for="freqWeekly">Weekly</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="freqMonthly" name="frequency" value="monthly" checked>
                                <label for="freqMonthly">Monthly</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="freqQuarterly" name="frequency" value="quarterly">
                                <label for="freqQuarterly">Quarterly</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="freqCustom" name="frequency" value="custom">
                                <label for="freqCustom">Custom</label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Daily options -->
                <div class="schedule-option" id="dailyOptions" style="display: none;">
                    <div class="form-row">
                        <div class="form-label">Start time</div>
                        <div class="form-input">
                            <select id="dailyHour" name="daily_hour">
                                {% for hour in range(24) %}
                                    <option value="{{ hour }}">{{ '%02d'|format(hour) }}:00</option>
                                {% endfor %}
                            </select>
                            <div class="help-text">Choose a time when system usage is typically low.</div>
                        </div>
                    </div>
                </div>

                <!-- Weekly options -->
                <div class="schedule-option" id="weeklyOptions" style="display: none;">
                    <div class="form-row">
                        <div class="form-label">Day of week</div>
                        <div class="form-input">
                            <select id="weeklyDay" name="weekly_day">
                                <option value="0">Monday</option>
                                <option value="1">Tuesday</option>
                                <option value="2">Wednesday</option>
                                <option value="3">Thursday</option>
                                <option value="4">Friday</option>
                                <option value="5">Saturday</option>
                                <option value="6">Sunday</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-label">Start time</div>
                        <div class="form-input">
                            <select id="weeklyHour" name="weekly_hour">
                                {% for hour in range(24) %}
                                    <option value="{{ hour }}">{{ '%02d'|format(hour) }}:00</option>
                                {% endfor %}
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Monthly options -->
                <div class="schedule-option" id="monthlyOptions">
                    <div class="form-row">
                        <div class="form-label">Day of month</div>
                        <div class="form-input">
                            <select id="monthlyDay" name="monthly_day">
                                <option value="1">1st of month</option>
                                <option value="15">15th of month</option>
                                <option value="last">Last day of month</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-label">Start time</div>
                        <div class="form-input">
                            <select id="monthlyHour" name="monthly_hour">
                                {% for hour in range(24) %}
                                    <option value="{{ hour }}">{{ '%02d'|format(hour) }}:00</option>
                                {% endfor %}
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Quarterly options -->
                <div class="schedule-option" id="quarterlyOptions" style="display: none;">
                    <div class="form-row">
                        <div class="form-label">Day of quarter</div>
                        <div class="form-input">
                            <select id="quarterlyDay" name="quarterly_day">
                                <option value="1">1st day of quarter</option>
                                <option value="15">15th day of quarter</option>
                                <option value="last">Last day of quarter</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-label">Start time</div>
                        <div class="form-input">
                            <select id="quarterlyHour" name="quarterly_hour">
                                {% for hour in range(24) %}
                                    <option value="{{ hour }}">{{ '%02d'|format(hour) }}:00</option>
                                {% endfor %}
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Custom options -->
                <div class="schedule-option" id="customOptions" style="display: none;">
                    <div class="form-row">
                        <div class="form-label">Interval</div>
                        <div class="form-input">
                            <input type="number" id="customInterval" name="custom_interval" value="7" min="1" max="365">
                            <select id="customUnit" name="custom_unit">
                                <option value="days">days</option>
                                <option value="weeks">weeks</option>
                                <option value="months">months</option>
                                <option value="years">years</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-label">Start time</div>
                        <div class="form-input">
                            <select id="customHour" name="custom_hour">
                                {% for hour in range(24) %}
                                    <option value="{{ hour }}">{{ '%02d'|format(hour) }}:00</option>
                                {% endfor %}
                            </select>
                        </div>
                    </div>
                </div>

                <h4>Advanced Options</h4>

                <div class="form-row">
                    <div class="form-label">Max Runtime</div>
                    <div class="form-input">
                        <input type="number" id="maxRuntime" name="max_runtime" value="12" style="width: 80px;">
                        <span style="margin-left: 5px;">hours</span>
                        <div class="help-text">Maximum duration for this scan. 0 = unlimited.</div>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-label">Priority</div>
                    <div class="form-input">
                        <select id="priority" name="priority">
                            <option value="0">Low (yield to other scans)</option>
                            <option value="1" selected>Normal</option>
                            <option value="2">High (take precedence)</option>
                        </select>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-label">Checksum Method</div>
                    <div class="form-input">
                        <select id="checksumMethod" name="checksum_method">
                            <option value="sha256">SHA-256 (Recommended)</option>
                            <option value="sha512">SHA-512 (More Secure)</option>
                            <option value="blake3">BLAKE3 (Fast & Secure)</option>
                            <option value="xxhash64">xxHash64 (Fastest)</option>
                            <option value="md5">MD5 (Legacy)</option>
                            <option value="sha1">SHA-1 (Legacy)</option>
                        </select>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-label">Scan Threads</div>
                    <div class="form-input">
                        <input type="number" id="scanThreads" name="scan_threads" value="4" min="1" max="32">
                        <div class="help-text">Number of parallel threads to use for scanning.</div>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-label">Exclude Directories</div>
                    <div class="form-input">
                        <input type="text" id="excludeDirs" name="exclude_dirs" placeholder=".git, node_modules, .venv">
                        <div class="help-text">Comma-separated list of directory names to exclude.</div>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-label">Notifications</div>
                    <div class="form-input">
                        <div>
                            <input type="checkbox" id="notifyComplete" name="notify_complete" checked>
                            <label for="notifyComplete">On completion</label>
                        </div>
                        <div>
                            <input type="checkbox" id="notifyErrors" name="notify_errors" checked>
                            <label for="notifyErrors">On errors only</label>
                        </div>
                        <div class="help-text">Notification functionality will be available in a future update.</div>
                    </div>
                </div>

                <div class="button-group">
                    <button type="button" class="btn secondary close-modal">Cancel</button>
                    <button type="submit" class="btn primary">Save Schedule</button>
                </div>
            </form>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Sub-tabs handling
        const subTabs = document.querySelectorAll('.sub-tab');
        const views = document.querySelectorAll('.view');

        subTabs.forEach(tab => {
            tab.addEventListener('click', function() {
                // Remove active class from all tabs
                subTabs.forEach(t => t.classList.remove('active'));

                // Add active class to clicked tab
                this.classList.add('active');

                // Hide all views
                views.forEach(view => view.style.display = 'none');

                // Show the selected view
                const viewId = this.dataset.view + '-view';
                document.getElementById(viewId).style.display = 'block';

                // If calendar view, initialize calendar
                if (this.dataset.view === 'calendar') {
                    initializeCalendar();
                }
            });
        });

        // Handle search filter
        const searchFilter = document.getElementById('searchFilter');
        const schedulesTable = document.getElementById('schedulesTable');

        if (searchFilter && schedulesTable) {
            searchFilter.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase();
                const tableRows = schedulesTable.querySelectorAll('tbody tr');

                tableRows.forEach(row => {
                    const name = row.querySelector('td:nth-child(2)').textContent.toLowerCase();
                    const path = row.querySelector('.path').textContent.toLowerCase();

                    if (name.includes(searchTerm) || path.includes(searchTerm)) {
                        row.style.display = '';
                    } else {
                        row.style.display = 'none';
                    }
                });
            });
        }

        // New Schedule button
        const newScheduleBtn = document.getElementById('newScheduleBtn');
        const firstScheduleBtn = document.getElementById('firstScheduleBtn');
        const scheduleModal = document.getElementById('scheduleModal');
        const scheduleForm = document.getElementById('scheduleForm');
        const closeModalButtons = document.querySelectorAll('.close-modal, .close-button');

        function openScheduleModal(isEdit = false, scheduleId = null) {
            // Reset form
            scheduleForm.reset();

            // Clear path list
            const pathList = document.getElementById('pathList');
            pathList.innerHTML = '';

            // Update modal title
            const modalTitle = document.getElementById('scheduleModalTitle');
            modalTitle.textContent = isEdit ? 'Edit Scheduled Scan' : 'New Scheduled Scan';

            // Set schedule ID if editing
            const scheduleIdInput = document.getElementById('scheduleId');
            scheduleIdInput.value = scheduleId || '';

            // If editing, populate form with schedule data
            if (isEdit && scheduleId) {
                // In a real implementation, this would fetch the schedule data from the server
                // For now, we'll use dummy data
                const dummySchedule = {
                    id: scheduleId,
                    name: 'Development Projects',
                    is_active: true,
                    paths: ['/home/user/projects', '/home/user/documents'],
                    frequency: 'monthly',
                    parameters: {
                        day_of_month: '1',
                        hour: '3',
                        minute: '0'
                    },
                    max_runtime: 12,
                    priority: 1,
                    checksum_method: 'sha256',
                    scan_threads: 4,
                    exclude_dirs: '.git, node_modules, .venv',
                    notify_complete: true,
                    notify_errors: true
                };

                // Populate form fields
                document.getElementById('scheduleName').value = dummySchedule.name;
                document.getElementById('scheduleActive').checked = dummySchedule.is_active;

                // Add paths
                dummySchedule.paths.forEach(path => {
                    addPath(path);
                });

                // Set frequency
                document.querySelector(`input[name="frequency"][value="${dummySchedule.frequency}"]`).checked = true;
                updateScheduleOptions();

                // Set other fields based on frequency
                if (dummySchedule.frequency === 'daily') {
                    document.getElementById('dailyHour').value = dummySchedule.parameters.hour;
                } else if (dummySchedule.frequency === 'weekly') {
                    document.getElementById('weeklyDay').value = dummySchedule.parameters.day_of_week;
                    document.getElementById('weeklyHour').value = dummySchedule.parameters.hour;
                } else if (dummySchedule.frequency === 'monthly') {
                    document.getElementById('monthlyDay').value = dummySchedule.parameters.day_of_month;
                    document.getElementById('monthlyHour').value = dummySchedule.parameters.hour;
                } else if (dummySchedule.frequency === 'quarterly') {
                    document.getElementById('quarterlyDay').value = dummySchedule.parameters.day_of_quarter;
                    document.getElementById('quarterlyHour').value = dummySchedule.parameters.hour;
                } else if (dummySchedule.frequency === 'custom') {
                    document.getElementById('customInterval').value = dummySchedule.parameters.interval;
                    document.getElementById('customUnit').value = dummySchedule.parameters.unit;
                    document.getElementById('customHour').value = dummySchedule.parameters.hour;
                }

                // Set advanced options
                document.getElementById('maxRuntime').value = dummySchedule.max_runtime;
                document.getElementById('priority').value = dummySchedule.priority;
                document.getElementById('checksumMethod').value = dummySchedule.checksum_method;
                document.getElementById('scanThreads').value = dummySchedule.scan_threads;
                document.getElementById('excludeDirs').value = dummySchedule.exclude_dirs;
                document.getElementById('notifyComplete').checked = dummySchedule.notify_complete;
                document.getElementById('notifyErrors').checked = dummySchedule.notify_errors;
            }

            // Open modal
            scheduleModal.style.display = 'flex';
        }

        // New Schedule button click
        if (newScheduleBtn) {
            newScheduleBtn.addEventListener('click', function() {
                openScheduleModal();
            });
        }

        // First Schedule button click
        if (firstScheduleBtn) {
            firstScheduleBtn.addEventListener('click', function() {
                openScheduleModal();
            });
        }

        // Edit Schedule button click
        const editScheduleButtons = document.querySelectorAll('.edit-schedule-btn');

        editScheduleButtons.forEach(button => {
            button.addEventListener('click', function() {
                const scheduleId = this.dataset.scheduleId;
                openScheduleModal(true, scheduleId);
            });
        });

        // Run Now button click
        const runNowButtons = document.querySelectorAll('.run-now-btn');

        runNowButtons.forEach(button => {
            button.addEventListener('click', function() {
                const scheduleId = this.dataset.scheduleId;

                // In a real implementation, this would send a request to the server
                alert(`Schedule ${scheduleId} will be run now.`);
            });
        });

        // Stop Scan button click
        const stopScanButtons = document.querySelectorAll('.stop-scan-btn');

        stopScanButtons.forEach(button => {
            button.addEventListener('click', function() {
                const scanId = this.dataset.scanId;

                // In a real implementation, this would send a request to the server
                alert(`Scan ${scanId} will be stopped.`);
            });
        });

        // Close modal buttons
        closeModalButtons.forEach(button => {
            button.addEventListener('click', function() {
                scheduleModal.style.display = 'none';
            });
        });

        // Close modal when clicking outside
        window.addEventListener('click', function(event) {
            if (event.target === scheduleModal) {
                scheduleModal.style.display = 'none';
            }
        });

        // Add path button
        const addPathBtn = document.getElementById('addPathBtn');
        const newPathInput = document.getElementById('newPath');

        if (addPathBtn && newPathInput) {
            addPathBtn.addEventListener('click', function() {
                const path = newPathInput.value.trim();

                if (path) {
                    addPath(path);
                    newPathInput.value = '';
                }
            });

            // Also add path on Enter key
            newPathInput.addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    addPathBtn.click();
                }
            });
        }

        // Function to add a path to the list
        function addPath(path) {
            const pathList = document.getElementById('pathList');

            const pathItem = document.createElement('div');
            pathItem.className = 'path-item';
            pathItem.dataset.path = path;

            const pathText = document.createElement('div');
            pathText.className = 'path-text';
            pathText.textContent = path;

            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn secondary';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', function() {
                pathItem.remove();
            });

            pathItem.appendChild(pathText);
            pathItem.appendChild(removeBtn);

            pathList.appendChild(pathItem);
        }

        // Handle frequency radio buttons
        const frequencyRadios = document.querySelectorAll('input[name="frequency"]');

        frequencyRadios.forEach(radio => {
            radio.addEventListener('change', updateScheduleOptions);
        });

        // Update schedule options based on selected frequency
        function updateScheduleOptions() {
            const selectedFrequency = document.querySelector('input[name="frequency"]:checked').value;

            // Hide all schedule options
            document.getElementById('dailyOptions').style.display = 'none';
            document.getElementById('weeklyOptions').style.display = 'none';
            document.getElementById('monthlyOptions').style.display = 'none';
            document.getElementById('quarterlyOptions').style.display = 'none';
            document.getElementById('customOptions').style.display = 'none';

            // Show selected schedule options
            if (selectedFrequency === 'daily') {
                document.getElementById('dailyOptions').style.display = 'block';
            } else if (selectedFrequency === 'weekly') {
                document.getElementById('weeklyOptions').style.display = 'block';
            } else if (selectedFrequency === 'monthly') {
                document.getElementById('monthlyOptions').style.display = 'block';
            } else if (selectedFrequency === 'quarterly') {
                document.getElementById('quarterlyOptions').style.display = 'block';
            } else if (selectedFrequency === 'custom') {
                document.getElementById('customOptions').style.display = 'block';
            }
        }

        // Initialize schedule options on page load
        updateScheduleOptions();

        // Form submission
        if (scheduleForm) {
            scheduleForm.addEventListener('submit', function(event) {
                event.preventDefault();

                // Validate form
                const scheduleName = document.getElementById('scheduleName').value.trim();
                const pathList = document.getElementById('pathList');
                const paths = Array.from(pathList.children).map(item => item.dataset.path);

                if (!scheduleName) {
                    alert('Please enter a name for the schedule.');
                    return;
                }

                if (paths.length === 0) {
                    alert('Please add at least one path to scan.');
                    return;
                }

                // Get form data
                const formData = new FormData(this);

                // Get frequency parameters
                const frequency = formData.get('frequency');
                let parameters = {};

                if (frequency === 'daily') {
                    parameters = {
                        hour: formData.get('daily_hour'),
                        minute: 0
                    };
                } else if (frequency === 'weekly') {
                    parameters = {
                        day_of_week: formData.get('weekly_day'),
                        hour: formData.get('weekly_hour'),
                        minute: 0
                    };
                } else if (frequency === 'monthly') {
                    parameters = {
                        day_of_month: formData.get('monthly_day'),
                        hour: formData.get('monthly_hour'),
                        minute: 0
                    };
                } else if (frequency === 'quarterly') {
                    parameters = {
                        day_of_quarter: formData.get('quarterly_day'),
                        hour: formData.get('quarterly_hour'),
                        minute: 0
                    };
                } else if (frequency === 'custom') {
                    parameters = {
                        interval: formData.get('custom_interval'),
                        unit: formData.get('custom_unit'),
                        hour: formData.get('custom_hour'),
                        minute: 0
                    };
                }

                // Create schedule data
                const scheduleData = {
                    id: formData.get('id'),
                    name: scheduleName,
                    is_active: formData.get('is_active') === 'on',
                    paths: paths,
                    frequency: frequency,
                    parameters: parameters,
                    max_runtime: parseInt(formData.get('max_runtime')),
                    priority: parseInt(formData.get('priority')),
                    checksum_method: formData.get('checksum_method'),
                    scan_threads: parseInt(formData.get('scan_threads')),
                    exclude_dirs: formData.get('exclude_dirs'),
                    notify_complete: formData.get('notify_complete') === 'on',
                    notify_errors: formData.get('notify_errors') === 'on'
                };

                // In a real implementation, this would send a request to the server
                console.log('Saving schedule:', scheduleData);

                // Close modal
                scheduleModal.style.display = 'none';

                // Show success message
                alert('Schedule saved successfully!');

                // Reload page
                // window.location.reload();
            });
        }

        // Calendar view
        let currentDate = new Date({{ now.year }}, {{ now.month - 1 }}, 1);
        const calendarGrid = document.getElementById('calendarGrid');
        const currentMonthElement = document.getElementById('currentMonth');
        const prevMonthBtn = document.getElementById('prevMonthBtn');
        const nextMonthBtn = document.getElementById('nextMonthBtn');

        // Initialize calendar
        function initializeCalendar() {
            if (!calendarGrid) return;

            // Clear existing calendar days
            const existingDays = calendarGrid.querySelectorAll('.calendar-day:not(.calendar-day-header)');
            existingDays.forEach(day => day.remove());

            // Update month title
            if (currentMonthElement) {
                currentMonthElement.textContent = currentDate.toLocaleString('default', { month: 'long', year: 'numeric' });
            }

            // Get first day of month and number of days in month
            const firstDay = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1).getDay();
            const daysInMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0).getDate();

            // Add empty cells for days before first day of month
            for (let i = 0; i < firstDay; i++) {
                const emptyDay = document.createElement('div');
                emptyDay.className = 'calendar-day';
                calendarGrid.appendChild(emptyDay);
            }

            // Create calendar days
            for (let day = 1; day <= daysInMonth; day++) {
                const calendarDay = document.createElement('div');
                calendarDay.className = 'calendar-day';

                // Add day number
                const dayNumber = document.createElement('div');
                dayNumber.className = 'calendar-day-number';
                dayNumber.textContent = day;

                // Check if this is today
                const today = new Date();
                if (currentDate.getFullYear() === today.getFullYear() &&
                    currentDate.getMonth() === today.getMonth() &&
                    day === today.getDate()) {
                    calendarDay.classList.add('today');
                }

                calendarDay.appendChild(dayNumber);

                // Add scheduled scans for this day
                addScheduledScansToDay(calendarDay, day, currentDate.getMonth(), currentDate.getFullYear());

                calendarGrid.appendChild(calendarDay);
            }
        }

        // Add scheduled scans to a calendar day
        function addScheduledScansToDay(dayElement, day, month, year) {
            // Format date as YYYY-MM-DD for comparison
            const formattedDate = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;

            // Get scheduled scans from the page data
            const schedules = Array.from(document.querySelectorAll('.schedule-row'));

            // Find schedules for this day
            schedules.forEach(schedule => {
                const nextRunElement = schedule.querySelector('td:nth-child(5)');
                if (!nextRunElement) return;

                const nextRunDate = nextRunElement.getAttribute('data-timestamp');
                if (!nextRunDate) return;

                // If this schedule runs on the current day, add it to the calendar
                if (nextRunDate.includes(formattedDate)) {
                    const scheduleName = schedule.querySelector('td:nth-child(2)').textContent;
                    const scheduleId = schedule.getAttribute('data-schedule-id');
                    const scheduleStatus = schedule.querySelector('td:first-child').textContent.trim();

                    const scheduleEvent = document.createElement('div');
                    scheduleEvent.className = `calendar-event ${scheduleStatus === 'Running' ? 'type-1' : scheduleStatus === 'Active' ? 'type-2' : 'type-3'}`;
                    scheduleEvent.textContent = scheduleName;
                    scheduleEvent.dataset.scheduleId = scheduleId;

                    scheduleEvent.addEventListener('click', function() {
                        // Open the edit modal for this schedule
                        document.querySelector(`.edit-schedule-btn[data-schedule-id="${scheduleId}"]`).click();
                    });

                    dayElement.appendChild(scheduleEvent);
                }
            });
        }

        // Initialize calendar navigation
        if (prevMonthBtn && nextMonthBtn) {
            prevMonthBtn.addEventListener('click', function() {
                currentDate.setMonth(currentDate.getMonth() - 1);
                initializeCalendar();
            });

            nextMonthBtn.addEventListener('click', function() {
                currentDate.setMonth(currentDate.getMonth() + 1);
                initializeCalendar();
            });
        }

        // Initialize calendar on page load if calendar view is active
        if (document.querySelector('.sub-tab[data-view="calendar"]')?.classList.contains('active')) {
            initializeCalendar();
        }
    });
</script>
{% endblock %}

</code>

web/templates/scan_history.html:
<code>
{% extends 'layout.html' %}

{% block title %}Bitarr - Scan History{% endblock %}

{% block content %}
<div class="scan-history">
    <h1>Scan History</h1>

    <div class="controls">
        <div class="search-container">
            <input type="text" id="searchFilter" class="search-filter" placeholder="Search by path or date...">
        </div>
    </div>

    <div class="card">
        <div class="card-body">
            {% if scans %}
                <div class="table-container">
                    <table id="scansTable">
                        <thead>
                            <tr>
                                <th>Status</th>
                                <th>Date & Time</th>
                                <th>Top-Level Path</th>
                                <th>Files</th>
                                <th>Total Size</th>
                                <th>File Status Summary</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for scan in scans %}
                            <tr class="scan-row" data-scan-id="{{ scan.id }}">
                                <td>
                                    {% if scan.status == 'completed' %}
                                        {% if scan.files_corrupted > 0 %}
                                            <span class="status-indicator status-critical"></span> Critical
                                        {% elif scan.files_missing > 0 %}
                                            <span class="status-indicator status-warning"></span> Warning
                                        {% else %}
                                            <span class="status-indicator status-good"></span> Good
                                        {% endif %}
                                    {% elif scan.status == 'running' %}
                                        <span class="status-indicator status-running"></span> Running
                                    {% elif scan.status == 'failed' %}
                                        <span class="status-indicator status-critical"></span> Failed
                                    {% else %}
                                        <span class="status-indicator status-warning"></span> {{ scan.status|title }}
                                    {% endif %}
                                </td>
                                <td class="time-ago" data-timestamp="{{ scan.start_time }}">
                                    {{ scan.start_time }}
                                </td>
                                <td class="path">{{ scan.top_level_path }}</td>
                                <td>{{ scan.files_scanned|default(0)|thousands_separator }}</td>
                                <td class="file-size" data-size="{{ scan.total_size|default(0) }}">
                                    {{ scan.total_size|default(0)|format_size }}
                                </td>
                                <td class="file-stats">
                                    {% if scan.files_unchanged %}
                                        <span class="stat-pill unchanged">{{ scan.files_unchanged|thousands_separator }} Unchanged</span>
                                    {% endif %}
                                    {% if scan.files_modified %}
                                        <span class="stat-pill modified">{{ scan.files_modified|thousands_separator }} Modified</span>
                                    {% endif %}
                                    {% if scan.files_corrupted %}
                                        <span class="stat-pill corrupted">{{ scan.files_corrupted|thousands_separator }} Corrupted</span>
                                    {% endif %}
                                    {% if scan.files_missing %}
                                        <span class="stat-pill missing">{{ scan.files_missing|thousands_separator }} Missing</span>
                                    {% endif %}
                                    {% if scan.files_new %}
                                        <span class="stat-pill new">{{ scan.files_new|thousands_separator }} New</span>
                                    {% endif %}
                                </td>
                                <td>
                                    <a href="{{ url_for('routes.scan_details', scan_id=scan.id) }}" class="btn small primary">Details</a>
                                    <button class="btn small secondary rescan-btn" data-path="{{ scan.top_level_path }}">Rescan</button>
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>

                <div class="pagination-controls">
                    <div class="page-info">
                        Showing <span id="showingStart">1</span>-<span id="showingEnd">{{ scans|length }}</span> of <span id="totalScans">{{ total_scans|default(scans|length) }}</span> scan records
                    </div>
                    <div>
                        <button id="prevPageBtn" class="btn secondary" {% if current_page == 1 %}disabled{% endif %}>Previous</button>
                        <button id="nextPageBtn" class="btn secondary" {% if current_page * page_size >= total_scans|default(scans|length) %}disabled{% endif %}>Next</button>
                    </div>
                </div>
            {% else %}
                <div class="empty-state">
                    <div class="empty-state-icon"></div>
                    <h3>No Scans Yet</h3>
                    <p>You haven't performed any file scans yet. Start a new scan to begin monitoring your files.</p>
                    <button id="firstScanBtn" class="btn primary">Start Your First Scan</button>
                </div>
            {% endif %}
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Handle search filter
        const searchFilter = document.getElementById('searchFilter');
        const scansTable = document.getElementById('scansTable');

        if (searchFilter && scansTable) {
            searchFilter.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase();
                const tableRows = scansTable.querySelectorAll('tbody tr');

                tableRows.forEach(row => {
                    const path = row.querySelector('.path').textContent.toLowerCase();
                    const timestamp = row.querySelector('.time-ago').dataset.timestamp.toLowerCase();

                    if (path.includes(searchTerm) || timestamp.includes(searchTerm)) {
                        row.style.display = '';
                    } else {
                        row.style.display = 'none';
                    }
                });

                // Update pagination info
                updatePaginationInfo();
            });
        }

        // Handle pagination
        const prevPageBtn = document.getElementById('prevPageBtn');
        const nextPageBtn = document.getElementById('nextPageBtn');

        if (prevPageBtn && nextPageBtn) {
            prevPageBtn.addEventListener('click', function() {
                if (!this.disabled) {
                    // Handle previous page navigation
                    window.location.href = "{{ url_for('routes.scan_history', page=current_page-1) }}";
                }
            });

            nextPageBtn.addEventListener('click', function() {
                if (!this.disabled) {
                    // Handle next page navigation
                    window.location.href = "{{ url_for('routes.scan_history', page=current_page+1) }}";
                }
            });
        }

        // Handle rescan buttons
        const rescanButtons = document.querySelectorAll('.rescan-btn');

        rescanButtons.forEach(button => {
            button.addEventListener('click', function() {
                const path = this.dataset.path;

                // Open new scan modal with path pre-filled
                const newScanModal = document.getElementById('newScanModal');
                const scanPathInput = document.getElementById('scanPath');

                if (newScanModal && scanPathInput) {
                    scanPathInput.value = path;
                    openModal(newScanModal);
                }
            });
        });

        // First scan button
        const firstScanBtn = document.getElementById('firstScanBtn');
        if (firstScanBtn) {
            firstScanBtn.addEventListener('click', function() {
                document.getElementById('newScanButton').click();
            });
        }

        // Helper function to open a modal
        function openModal(modal) {
            if (modal) {
                modal.style.display = 'flex';
            }
        }

        // Helper function to update pagination info
        function updatePaginationInfo() {
            const showingStart = document.getElementById('showingStart');
            const showingEnd = document.getElementById('showingEnd');
            const totalScans = document.getElementById('totalScans');

            if (showingStart && showingEnd && totalScans) {
                const visibleRows = scansTable.querySelectorAll('tbody tr:not([style*="display: none"])');
                showingStart.textContent = visibleRows.length > 0 ? 1 : 0;
                showingEnd.textContent = visibleRows.length;
                // Keep total the same
            }
        }
    });
</script>
{% endblock %}

</code>

web/templates/layouts/base.html:
<code>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Bitarr - File Integrity Scanner{% endblock %}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
    {% block styles %}{% endblock %}
</head>
<body>
    <header>
        <div class="header-container">
            <h1 class="title">Bitarr</h1>
            <nav class="main-nav">
                <ul>
                    <li><a href="{{ url_for('home') }}" class="{{ 'active' if request.endpoint == 'home' else '' }}">Home</a></li>
                    <li><a href="{{ url_for('scan_history') }}" class="{{ 'active' if request.endpoint == 'scan_history' else '' }}">Scan History</a></li>
                    <li><a href="{{ url_for('scheduled_scans') }}" class="{{ 'active' if request.endpoint == 'scheduled_scans' else '' }}">Scheduled Scans</a></li>
                    <li><a href="{{ url_for('storage_health') }}" class="{{ 'active' if request.endpoint == 'storage_health' else '' }}">Storage Health</a></li>
                    <li><a href="{{ url_for('configuration') }}" class="{{ 'active' if request.endpoint == 'configuration' else '' }}">Configuration</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main>
        <div class="container">
            {% block content %}{% endblock %}
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 Bitarr - File Integrity Scanner</p>
        </div>
    </footer>

    <script src="{{ url_for('static', filename='js/socket.io.min.js') }}"></script>
    <script src="{{ url_for('static', filename='js/main.js') }}"></script>
    {% block scripts %}{% endblock %}
</body>
</html>

</code>

